/**
 * Story Generation Service - Advanced Version
 *
 * Handles dynamic story generation using LLM for chapters 2-12.
 * Implements advanced prompting techniques:
 * - RAG (Retrieval Augmented Generation) with story bible grounding
 * - Few-shot learning with example passages
 * - Smart context windowing for token efficiency
 * - Consistency verification and self-checking
 * - Structured output parsing with validation
 */

import AsyncStorage from '@react-native-async-storage/async-storage';
import { llmService } from './LLMService';
import { llmTrace, createTraceId, log } from '../utils/llmTrace';
import {
  loadGeneratedStory,
  saveGeneratedChapter,
  getStoryContext,
  saveStoryContext,
} from '../storage/generatedStoryStorage';
import { getStoryEntry, formatCaseNumber, buildRealizedNarrative } from '../data/storyContent';
import { CHARACTER_REFERENCE } from '../data/characterReference';
import {
  TIMELINE,
  ABSOLUTE_FACTS,
  STORY_STRUCTURE,
  REVEAL_TIMING,
  SETUP_PAYOFF_REGISTRY,
  WRITING_STYLE,
  EXAMPLE_PASSAGES,
  CONSISTENCY_RULES,
  GENERATION_CONFIG,
  ENGAGEMENT_REQUIREMENTS,
  MICRO_TENSION_TECHNIQUES,
  SENTENCE_RHYTHM,
  ICEBERG_TECHNIQUE,
  SUBTEXT_REQUIREMENTS,
} from '../data/storyBible';
import {
  getScenesByCategory,
  getMixedScenes,
  MANY_SHOT_METADATA,
} from '../data/manyShot/index';

// Note: STORY_STRUCTURE.chapterBeatTypes is now used for tempo variation

// Story configuration
const TOTAL_CHAPTERS = STORY_STRUCTURE?.totalChapters || 12;
const SUBCHAPTERS_PER_CHAPTER = STORY_STRUCTURE?.subchaptersPerChapter || 3;
const MIN_WORDS_PER_SUBCHAPTER = GENERATION_CONFIG.wordCount.minimum; // 800 words
const TARGET_WORDS = GENERATION_CONFIG.wordCount.target; // 900 words
const DECISION_SUBCHAPTER = SUBCHAPTERS_PER_CHAPTER;
const MAX_RETRIES = GENERATION_CONFIG.qualitySettings?.maxRetries || 1;

// Text truncation lengths for prompts and logging (in characters)
const TRUNCATE_SUMMARY = 500;       // For brief narrative summaries in prompts
const TRUNCATE_VALIDATION = 3000;  // For full narrative in validation contexts
const TRUNCATE_DESCRIPTION = 300;  // For thread/choice descriptions
const TRUNCATE_PREVIEW = 100;      // For short previews/logging

const formatSubchapterLabel = (subchapter) => ['A', 'B', 'C'][subchapter - 1] || String(subchapter);

const fillTemplate = (template, replacements, { label } = {}) => {
  let result = String(template || '');
  for (const [key, value] of Object.entries(replacements || {})) {
    const safeValue = value == null ? '' : String(value);
    const pattern = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
    result = result.replace(pattern, safeValue);
  }

  const unresolved = result.match(/\{\{[^}]+\}\}/g);
  if (unresolved && unresolved.length > 0) {
    const contextLabel = label ? ` (${label})` : '';
    const message = `Unresolved template placeholders${contextLabel}: ${[...new Set(unresolved)].join(', ')}`;
    console.error(`[StoryGenerationService] ${message}`);
    throw new Error(message);
  }

  return result;
};

// ============================================================================
// PATH PERSONALITY SYSTEM - Tracks cumulative player behavior for coherent narrative
// ============================================================================
const PATH_PERSONALITY_TRAITS = {
  // Maps choice patterns to narrative personality
  AGGRESSIVE: {
    keywords: ['confront', 'direct', 'immediate', 'force', 'demand', 'pressure'],
    narrativeStyle: 'Jack acts decisively, confronting obstacles head-on',
    dialogueTone: 'more direct and confrontational',
    riskTolerance: 'high',
  },
  METHODICAL: {
    keywords: ['investigate', 'gather', 'evidence', 'careful', 'plan', 'wait'],
    narrativeStyle: 'Jack proceeds cautiously, gathering information before acting',
    dialogueTone: 'more measured and analytical',
    riskTolerance: 'low',
  },
  BALANCED: {
    narrativeStyle: 'Jack balances intuition with evidence',
    dialogueTone: 'adapts to the situation',
    riskTolerance: 'moderate',
  },
};

// ============================================================================
// DECISION CONSEQUENCE REGISTRY - Tracks what each choice means for continuity
// ============================================================================
// Note: Chapter 1C decision consequences are now dynamically generated since 1C is LLM-generated.
// This registry is populated dynamically by _ensureDecisionConsequences() and _ensureDecisionConsequencesFast()
// when players make choices. The hardcoded entries below are fallback templates.
const DECISION_CONSEQUENCES = {
  // Chapter 1 decision consequences - generated dynamically based on LLM output
  // The actual consequences depend on what 1C's decision options are (generated by LLM)
  // Fallback template for personality tracking (A = methodical, B = aggressive)
  '001C': {
    A: {
      immediate: 'Jack chose the methodical, evidence-focused approach',
      ongoing: ['More careful approach', 'More complete evidence trail', 'Slower but thorough investigation'],
      characterImpact: { trust: +10, aggression: -5, thoroughness: +15 },
    },
    B: {
      immediate: 'Jack chose the direct, confrontational approach',
      ongoing: ['More adversarial relationships', 'Faster revelation of threats', 'Higher personal risk'],
      characterImpact: { trust: -10, aggression: +15, thoroughness: -5 },
    },
  },
  // Additional chapter consequences are generated dynamically by the LLM
};

// ============================================================================
// JSON SCHEMAS FOR STRUCTURED OUTPUT
// These schemas force Gemini to return valid JSON, eliminating parse errors
// ============================================================================

// ============================================================================
// BRANCHING NARRATIVE SCHEMA - Interactive story segments with player choices
// ============================================================================
// Structure: Opening -> Choice1 (3 options) -> Middle branches (3) -> Choice2 (3 each) -> Endings (9 total)
// Total paths: 9 unique experiences per subchapter
// Word budget: 300-350 words per segment (3 segments = 900-1050 per path), ~4500+ words total per subchapter

/**
 * Schema for a single tappable detail within narrative text
 */
const DETAIL_SCHEMA = {
  type: 'object',
  properties: {
    phrase: {
      type: 'string',
      description: 'The exact phrase in the narrative text that can be tapped (must appear verbatim in the segment text)',
    },
    note: {
      type: 'string',
      description: 'Jack\'s internal observation when the player taps this detail (15-25 words)',
    },
    evidenceCard: {
      type: 'string',
      description: 'If this detail becomes evidence, the card label (2-4 words). Leave empty if purely atmospheric.',
    },
  },
  required: ['phrase', 'note'],
};

/**
 * Schema for a single choice option at a branch point
 */
const CHOICE_OPTION_SCHEMA = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
      description: 'Unique identifier for this option: "1A", "1B", "1C" for first choice, "2A", "2B", "2C" for second',
    },
    label: {
      type: 'string',
      description: 'Short action label (2-5 words, imperative). Must be a DIFFERENT ACTION from other options - not the same action with different intensity. E.g., "Ask about the file", "Examine her desk", "Change the subject". NOTE: For option C (1C or 2C), make this a WILDCARD choice - unexpected, creative, or unconventional action that adds fun and variation.',
    },
    response: {
      type: 'string',
      description: 'The narrative response when player selects this option (300-350 words). Continue the scene based on this choice.',
    },
    summary: {
      type: 'string',
      description: 'One-sentence summary of what happens when player takes this path (15-25 words). Used for decision context. E.g., "Jack takes a direct approach, confronting the witness and pressuring them for information."',
    },
    details: {
      type: 'array',
      items: DETAIL_SCHEMA,
      description: '0-2 tappable details within this response segment',
    },
  },
  required: ['key', 'label', 'response', 'summary'],
};

/**
 * Schema for a choice point in the narrative
 */
const CHOICE_POINT_SCHEMA = {
  type: 'object',
  properties: {
    prompt: {
      type: 'string',
      description: 'Brief context for the choice (shown to player, 5-15 words). E.g., "How does Jack respond?"',
    },
    options: {
      type: 'array',
      items: CHOICE_OPTION_SCHEMA,
      minItems: 3,
      maxItems: 3,
      description: 'Exactly 3 options for the player to choose from',
    },
  },
  required: ['prompt', 'options'],
};

/**
 * Schema for a second-level choice (after first choice, leading to endings)
 */
const SECOND_CHOICE_SCHEMA = {
  type: 'object',
  properties: {
    afterChoice: {
      type: 'string',
      description: 'Which first choice this follows: "1A", "1B", or "1C"',
    },
    prompt: {
      type: 'string',
      description: 'Brief context for this choice point (5-15 words)',
    },
    options: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          key: {
            type: 'string',
            description: 'Unique identifier: "1A-2A", "1A-2B", "1A-2C", etc.',
          },
          label: {
            type: 'string',
            description: 'Short action label (2-5 words). NOTE: For 2C options (e.g., 1A-2C, 1B-2C, 1C-2C), make this a WILDCARD choice - unexpected, creative, or unconventional action that adds fun and variation.',
          },
          response: {
            type: 'string',
            description: 'The ending narrative segment (300-350 words). Conclude this path of the subchapter.',
          },
          summary: {
            type: 'string',
            description: 'One-sentence summary of what happens in this path ending (15-25 words). Used for decision context. E.g., "Jack confronts the suspect directly, learning the truth but alerting their accomplices."',
          },
          details: {
            type: 'array',
            items: DETAIL_SCHEMA,
            description: '0-2 tappable details within this ending segment',
          },
        },
        required: ['key', 'label', 'response', 'summary'],
      },
      minItems: 3,
      maxItems: 3,
    },
  },
  required: ['afterChoice', 'prompt', 'options'],
};

/**
 * Complete schema for a branching narrative subchapter
 */
const BRANCHING_NARRATIVE_SCHEMA = {
  type: 'object',
  properties: {
    opening: {
      type: 'object',
      description: 'The opening segment, shared by all paths (300-350 words)',
      properties: {
        text: {
          type: 'string',
          description: 'Opening narrative that sets the scene and leads to the first choice (300-350 words)',
        },
        details: {
          type: 'array',
          items: DETAIL_SCHEMA,
          description: '1-2 tappable details in the opening',
        },
      },
      required: ['text'],
    },
    firstChoice: CHOICE_POINT_SCHEMA,
    secondChoices: {
      type: 'array',
      items: SECOND_CHOICE_SCHEMA,
      minItems: 3,
      maxItems: 3,
      description: 'Three second-choice points, one for each first choice option (1A, 1B, 1C)',
    },
  },
  required: ['opening', 'firstChoice', 'secondChoices'],
};

/**
 * Schema for regular subchapters (no decision point)
 */
const STORY_CONTENT_SCHEMA = {
  type: 'object',
  properties: {
    // NOTE: beatSheet, jackActionStyle, jackRiskLevel, jackBehaviorDeclaration, storyDay
    // were moved to <internal_planning> in system prompt - Gemini 3's native thinking
    // handles these internally without outputting them, reducing token usage by ~20%.
    title: {
      type: 'string',
      description: 'Evocative chapter title, 2-5 words',
    },
    bridge: {
      type: 'string',
      description: 'One short, compelling sentence hook for this subchapter (max 15 words)',
    },
    previously: {
      type: 'string',
      description: 'A concise 1-2 sentence recap of the previous subchapter (max 40 words), third-person past tense.',
    },
    // BRANCHING NARRATIVE - Interactive story with player choices
    // Structure: Opening (300-350w) -> Choice1 (3 opts) -> Middles (3x 300-350w) -> Choice2 (3 each) -> Endings (9x 300-350w)
    // Total: ~4000+ words generated, player experiences 850-950 words per path
    branchingNarrative: {
      type: 'object',
      description: 'Interactive branching narrative with 2 choice points and 9 possible paths',
      properties: {
        opening: {
          type: 'object',
          properties: {
            text: {
              type: 'string',
              description: 'Opening scene shared by all paths (300-350 words). Set the scene, build to first choice.',
            },
            details: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  phrase: { type: 'string', description: 'Exact phrase from text that can be tapped' },
                  note: { type: 'string', description: 'Jack\'s observation (15-25 words)' },
                  evidenceCard: { type: 'string', description: 'Evidence card label if applicable (2-4 words), or empty' },
                },
                required: ['phrase', 'note'],
              },
            },
          },
          required: ['text'],
        },
        firstChoice: {
          type: 'object',
          properties: {
            prompt: { type: 'string', description: 'Choice context (5-15 words). E.g., "How does Jack respond?"' },
            options: {
              type: 'array',
              minItems: 3,
              maxItems: 3,
              items: {
                type: 'object',
                properties: {
                  key: { type: 'string', description: '"1A", "1B", or "1C"' },
                  label: { type: 'string', description: 'Action label (2-5 words). Different ACTION from other options, not same action with different intensity. NOTE: For option 1C, make this a WILDCARD choice - unexpected, creative, or unconventional action that adds fun and variation.' },
                  response: { type: 'string', description: 'Narrative response (300-350 words)' },
                  details: {
                    type: 'array',
                    items: {
                      type: 'object',
                      properties: {
                        phrase: { type: 'string' },
                        note: { type: 'string' },
                        evidenceCard: { type: 'string' },
                      },
                      required: ['phrase', 'note'],
                    },
                  },
                },
                required: ['key', 'label', 'response'],
              },
            },
          },
          required: ['prompt', 'options'],
        },
        secondChoices: {
          type: 'array',
          minItems: 3,
          maxItems: 3,
          description: 'Three second-choice points, one following each first choice (1A, 1B, 1C)',
          items: {
            type: 'object',
            properties: {
              afterChoice: { type: 'string', description: 'Which first choice this follows: "1A", "1B", or "1C"' },
              prompt: { type: 'string', description: 'Choice context (5-15 words)' },
              options: {
                type: 'array',
                minItems: 3,
                maxItems: 3,
                items: {
                  type: 'object',
                  properties: {
                    key: { type: 'string', description: '"1A-2A", "1A-2B", "1A-2C", etc.' },
                    label: { type: 'string', description: 'Action label (2-5 words). Different ACTION from other options. NOTE: For 2C options (1A-2C, 1B-2C, 1C-2C), make this a WILDCARD choice - unexpected, creative, or unconventional action that adds fun and variation.' },
                    response: { type: 'string', description: 'Ending segment (300-350 words). Conclude this path.' },
                    details: {
                      type: 'array',
                      items: {
                        type: 'object',
                        properties: {
                          phrase: { type: 'string' },
                          note: { type: 'string' },
                          evidenceCard: { type: 'string' },
                        },
                        required: ['phrase', 'note'],
                      },
                    },
                  },
                  required: ['key', 'label', 'response'],
                },
              },
            },
            required: ['afterChoice', 'prompt', 'options'],
          },
        },
      },
      required: ['opening', 'firstChoice', 'secondChoices'],
    },
    // NOTE: chapterSummary removed - 'previously' + 'narrative' already provide this; was never displayed
    // NOTE: puzzleCandidates removed - puzzle uses static word list now
    briefing: {
      type: 'object',
      description: 'Mission briefing for the evidence board puzzle',
      properties: {
        summary: {
          type: 'string',
          description: 'One sentence objective for this subchapter, e.g., "Find the connection between the warehouse records and the missing witness."',
        },
        objectives: {
          type: 'array',
          items: { type: 'string' },
          description: '2-3 specific directives for the player, e.g., "Cross-reference the shipping manifests", "Identify the code words used"',
        },
      },
      required: ['summary', 'objectives'],
    },
    // NOTE: consistencyFacts removed - was deleted before storage anyway; narrative threads handle continuity
    // NOTE: previousThreadsAddressed removed - was deleted before storage; thread tracking handled in system prompt
    narrativeThreads: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          type: {
            type: 'string',
            enum: ['appointment', 'revelation', 'investigation', 'relationship', 'physical_state', 'promise', 'threat'],
            description: 'Category of narrative thread'
          },
          description: {
            type: 'string',
            description: 'Brief description of the thread (e.g., "Jack agreed to meet his contact at the docks at midnight")'
          },
          status: {
            type: 'string',
            enum: ['active', 'resolved', 'failed'],
            description: 'Whether this thread is still pending, was resolved, or failed'
          },
          urgency: {
            type: 'string',
            enum: ['critical', 'normal', 'background'],
            description: 'How urgent is this thread? critical=must resolve within 1-2 chapters'
          },
          characters: {
            type: 'array',
            items: { type: 'string' },
            description: 'Characters involved in this thread'
          },
          dueChapter: {
            type: 'number',
            description: 'Chapter number by which this MUST be resolved (critical=current+1, normal=current+3)'
          }
        },
        required: ['type', 'description', 'status', 'urgency']
      },
      description: 'Active story threads: promises, meetings, investigations, relationships, injuries, threats.'
    },
  },
  required: ['title', 'bridge', 'previously', 'branchingNarrative', 'briefing', 'narrativeThreads'],
};

/**
 * Schema for decision-only generation (first pass of two-pass decision generation)
 * This ensures the decision structure is always complete before narrative generation
 */
const DECISION_ONLY_SCHEMA = {
  type: 'object',
  properties: {
    decisionContext: {
      type: 'string',
      description: 'Brief description of the narrative situation leading to this choice (2-3 sentences)',
    },
    decision: {
      type: 'object',
      description: 'The binary choice - generate this FIRST before any narrative',
      properties: {
        intro: {
          type: 'string',
          description: '1-2 sentences framing the impossible choice Jack faces',
        },
        optionA: {
          type: 'object',
          properties: {
            key: { type: 'string', description: 'Always "A"' },
            title: { type: 'string', description: 'Action statement in imperative mood, e.g., "Confront Wade directly"' },
            focus: { type: 'string', description: 'Two sentences: What this path prioritizes and what it risks.' },
            personalityAlignment: {
              type: 'string',
              enum: ['aggressive', 'methodical', 'neutral'],
              description: 'Which player personality type would naturally choose this option',
            },
            narrativeSetup: {
              type: 'string',
              description: 'How the narrative should build toward this option being presented (1-2 sentences)',
            },
          },
          required: ['key', 'title', 'focus', 'personalityAlignment', 'narrativeSetup'],
        },
        optionB: {
          type: 'object',
          properties: {
            key: { type: 'string', description: 'Always "B"' },
            title: { type: 'string', description: 'Action statement in imperative mood, e.g., "Gather more evidence first"' },
            focus: { type: 'string', description: 'Two sentences: What this path prioritizes and what it risks.' },
            personalityAlignment: {
              type: 'string',
              enum: ['aggressive', 'methodical', 'neutral'],
              description: 'Which player personality type would naturally choose this option',
            },
            narrativeSetup: {
              type: 'string',
              description: 'How the narrative should build toward this option being presented (1-2 sentences)',
            },
          },
          required: ['key', 'title', 'focus', 'personalityAlignment', 'narrativeSetup'],
        },
      },
      required: ['intro', 'optionA', 'optionB'],
    },
    keyMoments: {
      type: 'array',
      items: { type: 'string' },
      description: '3-5 key moments/beats the narrative must include to naturally lead to this decision',
    },
    emotionalArc: {
      type: 'string',
      description: 'The emotional journey Jack experiences in this scene (tension, revelation, confrontation, etc.)',
    },
  },
  required: ['decisionContext', 'decision', 'keyMoments', 'emotionalArc'],
};

/**
 * Schema for decision point subchapters (end of each chapter)
 * NOTE: Same slimmed schema as STORY_CONTENT_SCHEMA - dead fields moved to system prompt
 */
const DECISION_CONTENT_SCHEMA = {
  type: 'object',
  properties: {
    // NOTE: beatSheet, jackActionStyle, jackRiskLevel, jackBehaviorDeclaration, storyDay
    // were moved to <internal_planning> in system prompt - Gemini 3's native thinking
    // handles these internally without outputting them, reducing token usage by ~20%.
    title: {
      type: 'string',
      description: 'Evocative chapter title, 2-5 words',
    },
    bridge: {
      type: 'string',
      description: 'One short, compelling sentence hook for this subchapter (max 15 words)',
    },
    previously: {
      type: 'string',
      description: 'A concise 1-2 sentence recap of the previous subchapter (max 40 words), third-person past tense.',
    },
    // Decision structure for chapter-ending choices
    // Testing if pathDecisions complexity is causing Gemini schema rejection
    decision: {
      type: 'object',
      description: 'Single decision point with intro and two options (A and B). Each option has key, title, focus, and personalityAlignment.',
      properties: {
        intro: { type: 'string', description: '1-2 sentences framing the decision moment (max 50 words)' },
        optionA: {
          type: 'object',
          properties: {
            key: { type: 'string', description: 'Option identifier: "A"' },
            title: { type: 'string', description: 'Short imperative action (3-8 words)' },
            focus: { type: 'string', description: 'What this choice prioritizes (1 sentence)' },
            personalityAlignment: { type: 'string', enum: ['aggressive', 'cautious', 'balanced'] },
          },
          required: ['key', 'title', 'focus', 'personalityAlignment'],
        },
        optionB: {
          type: 'object',
          properties: {
            key: { type: 'string', description: 'Option identifier: "B"' },
            title: { type: 'string', description: 'Short imperative action (3-8 words)' },
            focus: { type: 'string', description: 'What this choice prioritizes (1 sentence)' },
            personalityAlignment: { type: 'string', enum: ['aggressive', 'cautious', 'balanced'] },
          },
          required: ['key', 'title', 'focus', 'personalityAlignment'],
        },
      },
      required: ['intro', 'optionA', 'optionB'],
    },
    // BRANCHING NARRATIVE for decision subchapters - same structure as regular, but builds to the decision
    branchingNarrative: {
      type: 'object',
      description: 'Interactive branching narrative building to the decision moment. 2 choice points, 9 possible paths.',
      properties: {
        opening: {
          type: 'object',
          properties: {
            text: { type: 'string', description: 'Opening scene (300-350 words). Build tension toward the decision.' },
            details: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  phrase: { type: 'string' },
                  note: { type: 'string' },
                  evidenceCard: { type: 'string' },
                },
                required: ['phrase', 'note'],
              },
            },
          },
          required: ['text'],
        },
        firstChoice: {
          type: 'object',
          properties: {
            prompt: { type: 'string', description: 'Choice context (5-15 words)' },
            options: {
              type: 'array',
              minItems: 3,
              maxItems: 3,
              items: {
                type: 'object',
                properties: {
                  key: { type: 'string' },
                  label: { type: 'string', description: 'Action label (2-5 words). NOTE: For option 1C, make this a WILDCARD choice - unexpected, creative, or unconventional action that adds fun and variation.' },
                  response: { type: 'string', description: 'Narrative response (300-350 words)' },
                  summary: { type: 'string', description: 'One-sentence summary of what happens (15-25 words). Used for decision context.' },
                  details: { type: 'array', items: { type: 'object', properties: { phrase: { type: 'string' }, note: { type: 'string' }, evidenceCard: { type: 'string' } }, required: ['phrase', 'note'] } },
                },
                required: ['key', 'label', 'response', 'summary'],
              },
            },
          },
          required: ['prompt', 'options'],
        },
        secondChoices: {
          type: 'array',
          minItems: 3,
          maxItems: 3,
          items: {
            type: 'object',
            properties: {
              afterChoice: { type: 'string' },
              prompt: { type: 'string' },
              options: {
                type: 'array',
                minItems: 3,
                maxItems: 3,
                items: {
                  type: 'object',
                  properties: {
                    key: { type: 'string' },
                    label: { type: 'string', description: 'Action label (2-5 words). NOTE: For 2C options (1A-2C, 1B-2C, 1C-2C), make this a WILDCARD choice - unexpected, creative, or unconventional action that adds fun and variation.' },
                    response: { type: 'string', description: 'Ending segment (300-350 words). Conclude at the decision moment.' },
                    summary: { type: 'string', description: 'One-sentence summary of this path ending (15-25 words). Used for decision context.' },
                    details: { type: 'array', items: { type: 'object', properties: { phrase: { type: 'string' }, note: { type: 'string' }, evidenceCard: { type: 'string' } }, required: ['phrase', 'note'] } },
                  },
                  required: ['key', 'label', 'response', 'summary'],
                },
              },
            },
            required: ['afterChoice', 'prompt', 'options'],
          },
        },
      },
      required: ['opening', 'firstChoice', 'secondChoices'],
    },
    // NOTE: chapterSummary removed - 'previously' + 'narrative' already provide this
    // NOTE: puzzleCandidates removed - puzzle uses static word list now
    briefing: {
      type: 'object',
      description: 'Mission briefing',
      properties: {
        summary: {
          type: 'string',
          description: 'One sentence objective for this subchapter, e.g., "Uncover the truth behind the conflicting testimonies."',
        },
        objectives: {
          type: 'array',
          items: { type: 'string' },
          description: '2-3 specific directives for the player',
        },
      },
      required: ['summary', 'objectives'],
    },
    // NOTE: consistencyFacts removed - was deleted before storage anyway
    // NOTE: previousThreadsAddressed removed - was deleted before storage; handled in system prompt
    narrativeThreads: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          type: {
            type: 'string',
            enum: ['appointment', 'revelation', 'investigation', 'relationship', 'physical_state', 'promise', 'threat'],
            description: 'Category of narrative thread'
          },
          description: {
            type: 'string',
            description: 'Brief description of the thread'
          },
          status: {
            type: 'string',
            enum: ['active', 'resolved', 'failed'],
            description: 'Whether this thread is still pending, was resolved, or failed'
          },
          urgency: {
            type: 'string',
            enum: ['critical', 'normal', 'background'],
            description: 'How urgent is this thread? critical=must resolve within 1-2 chapters'
          },
          characters: {
            type: 'array',
            items: { type: 'string' },
            description: 'Characters involved in this thread'
          },
          dueChapter: {
            type: 'number',
            description: 'Chapter number by which this MUST be resolved (critical=current+1, normal=current+3)'
          }
        },
        required: ['type', 'description', 'status', 'urgency']
      },
      description: 'Active story threads: promises, meetings, investigations, relationships, injuries, threats.'
    },
  },
  required: ['title', 'bridge', 'previously', 'decision', 'branchingNarrative', 'briefing', 'narrativeThreads'],
};

// ============================================================================
// PATHDECISIONS SCHEMA - Minimal schema for 9 path-specific decisions (second call)
// This is called AFTER main content generation to add path-specific decision options
// ============================================================================
const PATH_DECISION_OPTION_SCHEMA = {
  type: 'object',
  properties: {
    key: { type: 'string' },
    title: { type: 'string' },
    focus: { type: 'string' },
    personalityAlignment: { type: 'string' },
  },
};

const SINGLE_PATH_DECISION_SCHEMA = {
  type: 'object',
  properties: {
    intro: { type: 'string' },
    optionA: PATH_DECISION_OPTION_SCHEMA,
    optionB: PATH_DECISION_OPTION_SCHEMA,
  },
};

// Array format for pathDecisions - 9 items, one per unique path
const PATHDECISIONS_ONLY_SCHEMA = {
  type: 'object',
  properties: {
    pathDecisions: {
      type: 'array',
      description: '9 path-specific decision points, one for each unique path through this subchapter',
      items: {
        type: 'object',
        properties: {
          pathKey: { type: 'string', description: 'Path identifier: 1A-2A, 1A-2B, 1A-2C, 1B-2A, 1B-2B, 1B-2C, 1C-2A, 1C-2B, 1C-2C' },
          intro: { type: 'string', description: 'Path-specific intro text (1-2 sentences framing the decision for this path)' },
          optionA: {
            type: 'object',
            properties: {
              key: { type: 'string', description: 'Always "A"' },
              title: { type: 'string', description: 'Short imperative action (3-8 words)' },
              focus: { type: 'string', description: 'What this choice prioritizes (1 sentence)' },
              personalityAlignment: { type: 'string', enum: ['aggressive', 'cautious', 'balanced'] },
            },
            required: ['key', 'title', 'focus', 'personalityAlignment'],
          },
          optionB: {
            type: 'object',
            properties: {
              key: { type: 'string', description: 'Always "B"' },
              title: { type: 'string', description: 'Short imperative action (3-8 words)' },
              focus: { type: 'string', description: 'What this choice prioritizes (1 sentence)' },
              personalityAlignment: { type: 'string', enum: ['aggressive', 'cautious', 'balanced'] },
            },
            required: ['key', 'title', 'focus', 'personalityAlignment'],
          },
        },
        required: ['pathKey', 'intro', 'optionA', 'optionB'],
      },
      minItems: 9,
      maxItems: 9,
    },
  },
  required: ['pathDecisions'],
};

// ============================================================================
// PATHDECISIONS SYSTEM PROMPT - Story context for path-specific decisions
// Per Gemini 3 best practices: XML tags, persona, explicit constraints
// ============================================================================
const buildPathDecisionsSystemPrompt = () => {
  const { protagonist, antagonist, setting } = ABSOLUTE_FACTS;
  return `<identity>
You are the author of "Dead Letters," crafting path-specific decision variants for ${protagonist.fullName}'s investigation.
You understand that different player journeys through the branching narrative lead to genuinely different discoveries, and those discoveries MUST shape what decisions make sense.
</identity>

<story_context>
- PROTAGONIST: ${protagonist.fullName}, ${protagonist.age}, ${protagonist.formerTitle.toLowerCase()}. ${protagonist.currentStatus}
- SETTING: ${setting.city}, ${setting.atmosphere}. A city with a hidden second layer called "the Under-Map" threaded through its infrastructure.
- TONE: Modern mystery thriller that slowly reveals an original fantasy world. Noir-adjacent but not pastiche.
- ANTAGONIST: ${antagonist.trueName}, ${antagonist.occupation}. Her philosophy: "${antagonist.philosophy}"
</story_context>

<core_mandate>
Each of the 9 branching paths represents a DIFFERENT player experience. The decisions you generate must reflect what THAT specific player discovered, not generic options that could apply to any path.

CRITICAL: If a player discovered a name, their decision should involve that name. If they witnessed a threshold react, their decision should involve that threshold. The discoveries ARE the decision drivers.
</core_mandate>

<output_contract>
Return ONLY valid JSON matching the schema. No commentary.
</output_contract>`;
};

// ============================================================================
// PATHDECISIONS PROMPT TEMPLATE - Structured per Gemini 3 best practices
// Uses XML tags, explicit planning, few-shot examples, causality mapping
// IMPORTANT: Uses SUMMARIES (15-25 words each) instead of full narrative content.
// Full narrative excerpts trigger Gemini's RECITATION safety filter.
// ============================================================================
const PATHDECISIONS_PROMPT_TEMPLATE = `<task>
Generate 9 UNIQUE path-specific decision variants for Case {{caseNumber}} (Chapter {{chapter}}.{{subchapter}}) of "Dead Letters."
Each path represents a different player journey. Different discoveries require different decisions.
</task>

<path_structure>
The 9 paths follow this format: [FIRST_CHOICE]-[ENDING]
- FIRST_CHOICE (1A, 1B, 1C): How the player APPROACHED the scene (their investigative style)
- ENDING (2A, 2B, 2C): What the player DISCOVERED as a result

Path keys: 1A-2A, 1A-2B, 1A-2C, 1B-2A, 1B-2B, 1B-2C, 1C-2A, 1C-2B, 1C-2C
</path_structure>

<player_approaches>
These are the three ways the player could have approached this scene:
- 1A: "{{firstChoice1ALabel}}" → {{firstChoice1ASummary}}
- 1B: "{{firstChoice1BLabel}}" → {{firstChoice1BSummary}}
- 1C: "{{firstChoice1CLabel}}" → {{firstChoice1CSummary}}
</player_approaches>

<path_discoveries>
These are what each path discovered (the ending they experienced):
{{pathSummaries}}
</path_discoveries>

<path_details>
Detailed notes for each path (use these to stay grounded; do not invent entities not mentioned):
{{pathStructuredNotes}}
</path_details>

<canonical_decision_reference>
The main narrative pass generated this base decision (use as inspiration, not constraint):
- Option A: "{{optionATitle}}" ({{optionAFocus}})
- Option B: "{{optionBTitle}}" ({{optionBFocus}})
</canonical_decision_reference>

<reasoning_instructions>
Before generating each path's decision, internally reason through:
1. WHAT did this player discover? (Extract the key revelation from the path notes)
2. HOW does that discovery change what options make sense? (Causality mapping)
3. WHAT would Jack specifically do with THIS information? (Character consistency)
4. WHY would the options differ from other paths? (Differentiation check)
</reasoning_instructions>

<causality_rules>
Discoveries MUST drive decisions. Follow these causality patterns:

DISCOVERY TYPE → DECISION PATTERN:
- Found a NAME → Options involve: confronting the person, researching them, or using the name as leverage
- Found a SYMBOL/GLYPH → Options involve: following it, documenting it, testing it, or using it as bait
- Witnessed an ANOMALY → Options involve: investigating immediately, retreating to process, or provoking it further
- Gained EVIDENCE → Options involve: confronting someone with it, verifying it independently, or using it as protection
- Learned a LOCATION → Options involve: going there immediately, surveilling it first, or using it to lure someone

If the discovery doesn't fit these patterns, derive the decision logically from what was learned.
</causality_rules>

<few_shot_examples>
GOOD path-specific decisions (note how discoveries drive the options):

Example 1 - Path 1A-2A (Discovery: Found Blackwell's courier with a symbol-marked envelope)
{
  "pathKey": "1A-2A",
  "intro": "The courier's envelope bears the same symbol Jack saw on the threshold. Blackwell's network runs deeper than he thought.",
  "optionA": {
    "key": "A",
    "title": "Follow the courier to Blackwell",
    "focus": "Use this connection to trace Blackwell's location directly, aggressive but potentially revealing.",
    "personalityAlignment": "aggressive"
  },
  "optionB": {
    "key": "B",
    "title": "Photograph the envelope, let them go",
    "focus": "Document the symbol connection without alerting Blackwell's network to Jack's interest.",
    "personalityAlignment": "cautious"
  }
}

Example 2 - Path 1B-2C (Discovery: The threshold flickered when Jack spoke the name aloud)
{
  "pathKey": "1B-2C",
  "intro": "The threshold responded to the name. Proof that the Under-Map is not just symbols; it is listening.",
  "optionA": {
    "key": "A",
    "title": "Speak the name again and step through",
    "focus": "Test whether the threshold will open fully. Risk everything to see what is on the other side.",
    "personalityAlignment": "aggressive"
  },
  "optionB": {
    "key": "B",
    "title": "Record the coordinates, retreat to research",
    "focus": "Document this reactive threshold before attempting anything irreversible.",
    "personalityAlignment": "cautious"
  }
}

Example 3 - Path 1C-2B (Discovery: Found a ledger with names of the disappeared, including Jack's old case)
{
  "pathKey": "1C-2B",
  "intro": "The ledger connects Jack's failed case to Blackwell's operation. The guilt he's carried might have a different shape.",
  "optionA": {
    "key": "A",
    "title": "Confront Blackwell with the ledger",
    "focus": "Force a direct confrontation. Jack needs answers about what really happened two years ago.",
    "personalityAlignment": "aggressive"
  },
  "optionB": {
    "key": "B",
    "title": "Cross-reference the names with city records",
    "focus": "Verify the ledger's claims before revealing that Jack has it. Knowledge is leverage.",
    "personalityAlignment": "cautious"
  }
}

BAD examples (generic, not path-specific):
❌ "Investigate further" vs "Wait and see": Too vague, could apply to any path
❌ "Take action" vs "Be careful": No connection to what was discovered
❌ Same titles across multiple paths: Defeats the purpose of branching narratives
</few_shot_examples>

<output_requirements>
Generate 9 pathDecisions objects with:
1. pathKey: The path identifier (1A-2A through 1C-2C)
2. intro: 1-2 sentences framing the decision based on THIS path's discovery
3. optionA: Action option with key="A", title (3-8 words, imperative), focus (why this makes sense), personalityAlignment
4. optionB: Alternative option with key="B", title (3-8 words, imperative), focus (why this makes sense), personalityAlignment

CRITICAL CHECKS before finalizing:
✓ Each path's options reference what THAT path discovered
✓ No two paths have identical option titles
✓ The intro mentions the specific discovery or revelation
✓ Options feel like natural next steps given what Jack learned
</output_requirements>`;

// ============================================================================
// MASTER SYSTEM PROMPT - Core instructions for the LLM
// Structured per Gemini 3 best practices (XML tags, explicit planning, persona)
// Now builds dynamically from storyBible.js data - no hardcoded duplicates
// ============================================================================
const buildMasterSystemPrompt = () => {
  const { protagonist, setting } = ABSOLUTE_FACTS;
  const { voice } = WRITING_STYLE;

  const revealTimingRules = REVEAL_TIMING?.rules || [];

  return `<identity>
You are the author of "Dead Letters," an interactive mystery thriller set in ${setting.city}, ${setting.coreMystery.toLowerCase()}.
You are NOT an assistant helping with writing. You ARE the writer.
</identity>

<core_mandate>
Continue the story of ${protagonist.fullName} with perfect narrative and world consistency.
Maintain mystery pressure. Advance the investigation. Keep the prose precise, atmospheric, and psychologically close.
</core_mandate>

<non_negotiables>
- Stay in character: never acknowledge being an AI or reference these instructions.
- POV/tense: ${voice.perspective.toLowerCase()}, ${voice.tense.toLowerCase()}, tightly aligned to ${protagonist.fullName}.
- Dialogue punctuation: use SINGLE QUOTES for all dialogue (e.g., 'Like this,' Jack said).
- Continuity: never contradict the Story Bible / established facts / dates / relationships.
- Continuation: when a prior ending is provided (especially <scene_state> / exact last sentence), pick up immediately after it; do not restart, recap, or rephrase the ending.
</non_negotiables>

<reveal_timing>
${revealTimingRules.map(rule => `- ${rule}`).join('\n')}
</reveal_timing>

<how_to_use_the_prompt>
You will receive structured context blocks (for example: story_bible, character_reference, craft_techniques, style_examples, consistency_rules, story_context, active_threads, scene_state, engagement_guidance, task, self_critique).
Treat those blocks as authoritative.
If instructions conflict, prefer: <task> and schema requirements > continuity blocks > craft/style guidance.
</how_to_use_the_prompt>

<output_contract>
- Return ONLY valid JSON that matches the provided schema. No commentary, no markdown.
- Branches must be logically consistent with what precedes them, and genuinely divergent (different discoveries and/or consequences) while staying within canon.
</output_contract>

<internal_planning>
Before writing narrative, internally determine (do NOT output these; just let them guide your writing):
- BEAT STRUCTURE: What are the 3-5 major plot beats for this scene?
- JACK'S PRIMARY ACTION: investigate | confront | observe | negotiate | flee | wait | interrogate | follow
- JACK'S DIALOGUE APPROACH: aggressive | measured | evasive | empathetic | threatening | pleading
- JACK'S EMOTIONAL STATE: determined | desperate | cautious | angry | regretful | suspicious | resigned
- JACK'S PHYSICAL BEHAVIOR: tense | relaxed | aggressive | defensive | stealthy | commanding
- PERSONALITY ALIGNMENT: Does this match the player's path personality (aggressive/methodical/balanced)?
- STORY DAY: This is Day N of the ${TOTAL_CHAPTERS}-day timeline (Chapter N = Day N)
These decisions should manifest naturally in the prose without being explicitly stated.
</internal_planning>

<thread_accounting_rule>
MANDATORY: Every thread in ACTIVE_THREADS with urgency="critical" is NON-NEGOTIABLE. You will be rejected if you skip them.

For EVERY critical thread:
1. Characters MUST take visible action on it (not just think about it)
2. Show progress through dialogue or concrete actions (not narration or exposition)
3. If physically impossible to address in this scene, Jack must explicitly acknowledge why he can't act on it yet

FAILURE TO ADDRESS CRITICAL THREADS = AUTOMATIC REJECTION. No exceptions.
</thread_accounting_rule>

<thread_escalation_rule>
OVERDUE THREAD PENALTY: Any thread active for 2+ chapters without meaningful progress triggers MANDATORY action.

You MUST do ONE of:
1. Advance it significantly this chapter (reveal new info, confront someone, discover evidence)
2. Resolve it completely with in-narrative payoff
3. Mark it "failed" with Jack explicitly giving up and explaining why

Ignoring overdue threads = generation failure. This is a hard requirement.
</thread_escalation_rule>

<craft_quality_checklist>
Before finalizing your narrative, internally verify these craft elements (do NOT output these; just ensure your writing embodies them):
- SENSORY GROUNDING: ${MICRO_TENSION_TECHNIQUES.elements.find(e => e.includes('sensory')) || 'Include a recurring sensory detail (a sound, smell, texture) that anchors the scene physically'}
- MICRO-REVELATION: ${ENGAGEMENT_REQUIREMENTS.revelationGradient.levels.micro}
- FORWARD MOMENTUM: ${ENGAGEMENT_REQUIREMENTS.finalLineHook.description}
- PERSONAL STAKES: ${ENGAGEMENT_REQUIREMENTS.personalStakes.requirement}
- EMOTIONAL PEAK: ${ENGAGEMENT_REQUIREMENTS.emotionalAnchor.rule}
- VARIED RHYTHM: ${SENTENCE_RHYTHM.rules[0]}
</craft_quality_checklist>`;
};

// ============================================================================
// FEW-SHOT EXAMPLES FOR STYLE GROUNDING
// ============================================================================
const STYLE_EXAMPLES = `
## EXAMPLE: ATMOSPHERIC OPENING (EXCELLENT)
"${EXAMPLE_PASSAGES.atmosphericOpening}"

## EXAMPLE: DIALOGUE (EXCELLENT)
"${EXAMPLE_PASSAGES.dialogueExample}"

## EXAMPLE: INTERNAL MONOLOGUE (EXCELLENT)
"${EXAMPLE_PASSAGES.internalMonologue}"

## EXAMPLE: TENSE MOMENT (EXCELLENT)
"${EXAMPLE_PASSAGES.tenseMoment}"

## EXAMPLE: CHARACTER CONFRONTATION (EXCELLENT)
"${EXAMPLE_PASSAGES.characterConfrontation}"

## EXAMPLE: EMOTIONAL REVELATION (EXCELLENT)
"${EXAMPLE_PASSAGES.emotionalRevelation}"

## EXAMPLE: CHASE/ACTION SEQUENCE (EXCELLENT)
"${EXAMPLE_PASSAGES.chaseSequence}"

## EXAMPLE: INVESTIGATION SCENE (EXCELLENT)
"${EXAMPLE_PASSAGES.investigationScene}"

## EXAMPLE: QUIET CHARACTER MOMENT (EXCELLENT)
"${EXAMPLE_PASSAGES.quietMoment}"

## EXAMPLE: DECISION SETUP (EXCELLENT)
"${EXAMPLE_PASSAGES.decisionSetup}"

---
Study these examples carefully. Note the:
- Varied sentence lengths (punchy shorts mixed with longer flowing ones)
- Sensory grounding (rain, neon, whiskey, smoke)
- Metaphors that feel noir-specific, not generic
- Dialogue that reveals character without exposition
- Physical action interleaved with internal thought
- Tension built through what's NOT said

Your writing should feel like it belongs in the same novel as these passages.
`;

// ============================================================================
// EXTENDED STYLE EXAMPLES - Full scenes for deep pattern learning
// ============================================================================
const buildExtendedStyleExamples = () => {
  // Import dynamically to avoid circular dependencies
  const { EXTENDED_STYLE_GROUNDING, ANNOTATED_EXAMPLES, NEGATIVE_EXAMPLES } = require('../data/storyBible');

  return `
## EXTENDED EXAMPLE: COMPLETE TENSION SCENE
Study how this scene builds tension through dialogue, physical action, and emotional undercurrent:

${EXTENDED_STYLE_GROUNDING.tensionScene}

---

## EXTENDED EXAMPLE: REVELATION MOMENT
Study how this scene delivers a game-changing revelation while maintaining emotional impact:

${EXTENDED_STYLE_GROUNDING.revelationScene}

---

## EXTENDED EXAMPLE: CHAPTER ENDING (CLIFFHANGER)
Study how this scene creates unbearable forward momentum:

${EXTENDED_STYLE_GROUNDING.chapterEnding}

---

## EXTENDED EXAMPLE: DIALOGUE UNDER TENSION (SUBTEXT)
Study how every line carries surface meaning AND hidden subtext:

${EXTENDED_STYLE_GROUNDING.dialogueUnderTension}

---

## ANNOTATED EXAMPLE: Physical Emotion
"${ANNOTATED_EXAMPLES.physicalEmotionExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.physicalEmotionExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Dialogue Subtext
"${ANNOTATED_EXAMPLES.dialogueSubtextExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.dialogueSubtextExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Tension Building
"${ANNOTATED_EXAMPLES.tensionBuildingExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.tensionBuildingExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Chapter Hook
"${ANNOTATED_EXAMPLES.chapterHookExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.chapterHookExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Sensory World-Building
"${ANNOTATED_EXAMPLES.sensoryWorldBuildingExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.sensoryWorldBuildingExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Character Through Action
"${ANNOTATED_EXAMPLES.characterThroughActionExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.characterThroughActionExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Crowd As Character
"${ANNOTATED_EXAMPLES.crowdAsCharacterExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.crowdAsCharacterExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Dialogue Revealing Class
"${ANNOTATED_EXAMPLES.dialogueRevealingClassExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.dialogueRevealingClassExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Threat Through Normality
"${ANNOTATED_EXAMPLES.threatThroughNormalityExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.threatThroughNormalityExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Complex Emotion Through Object
"${ANNOTATED_EXAMPLES.complexEmotionThroughObjectExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.complexEmotionThroughObjectExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Waiting As Character
"${ANNOTATED_EXAMPLES.waitingAsCharacterExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.waitingAsCharacterExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Psychological Complicity
"${ANNOTATED_EXAMPLES.psychologicalComplicityExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.psychologicalComplicityExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Accepting Darkness
"${ANNOTATED_EXAMPLES.acceptingDarknessExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.acceptingDarknessExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Silent Reconnection
"${ANNOTATED_EXAMPLES.silentReconnectionExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.silentReconnectionExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Burnout Monologue
"${ANNOTATED_EXAMPLES.burnoutMonologueExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.burnoutMonologueExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Memory Erasure
"${ANNOTATED_EXAMPLES.memoryErasureExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.memoryErasureExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Dark Empowerment
"${ANNOTATED_EXAMPLES.darkEmpowermentExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.darkEmpowermentExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Physical Decay As Trauma
"${ANNOTATED_EXAMPLES.physicalDecayAsTraumaExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.physicalDecayAsTraumaExample.annotations.map(a => `- ${a}`).join('\n')}

## ANNOTATED EXAMPLE: Victim Humanization
"${ANNOTATED_EXAMPLES.victimHumanizationExample.passage}"

WHY THIS WORKS:
${ANNOTATED_EXAMPLES.victimHumanizationExample.annotations.map(a => `- ${a}`).join('\n')}

---

## WHAT NOT TO WRITE - NEGATIVE EXAMPLES

### BAD: Telling Instead of Showing
"${NEGATIVE_EXAMPLES.tellDontShow.badVersion}"

PROBLEMS:
${NEGATIVE_EXAMPLES.tellDontShow.problems.map(p => `- ${p}`).join('\n')}

### GOOD VERSION:
"${NEGATIVE_EXAMPLES.tellDontShow.goodVersion}"

---

### BAD: Overwritten Dialogue
"${NEGATIVE_EXAMPLES.overwrittenDialogue.badVersion}"

PROBLEMS:
${NEGATIVE_EXAMPLES.overwrittenDialogue.problems.map(p => `- ${p}`).join('\n')}

### GOOD VERSION:
"${NEGATIVE_EXAMPLES.overwrittenDialogue.goodVersion}"

---

### BAD: Flat Pacing
"${NEGATIVE_EXAMPLES.flatPacing.badVersion}"

PROBLEMS:
${NEGATIVE_EXAMPLES.flatPacing.problems.map(p => `- ${p}`).join('\n')}

### GOOD VERSION:
"${NEGATIVE_EXAMPLES.flatPacing.goodVersion}"

---

### BAD: Heavy Foreshadowing
"${NEGATIVE_EXAMPLES.heavyForeshadowing.badVersion}"

PROBLEMS:
${NEGATIVE_EXAMPLES.heavyForeshadowing.problems.map(p => `- ${p}`).join('\n')}

### GOOD VERSION:
"${NEGATIVE_EXAMPLES.heavyForeshadowing.goodVersion}"
`;
};

// ============================================================================
// MANY-SHOT SCENE EXAMPLES - Pattern learning from Mystic River
// ============================================================================
const buildManyShotExamples = (beatType, chapterBeatType, limit = 15) => {
  // Map beat types and chapter types to relevant scene categories
  const categoryMap = {
    // Subchapter beat types
    'Opening/Hook (A)': ['setup', 'atmospheric', 'internal_monologue'],
    'Development/Conflict (B)': ['dialogue_tension', 'confrontation', 'investigation'],
    'Resolution/Decision (C)': ['decision_point', 'revelation', 'aftermath'],

    // Chapter beat types
    'CHASE': ['action', 'dialogue_tension'],
    'BOTTLE_EPISODE': ['dialogue_tension', 'internal_monologue', 'confrontation'],
    'CONFRONTATION': ['confrontation', 'dialogue_tension', 'revelation'],
    'BETRAYAL': ['revelation', 'aftermath', 'darkest_moment'],
    'INVESTIGATION': ['investigation', 'interrogation', 'internal_monologue'],
    'SETUP': ['setup', 'atmospheric'],
    'CLIMAX': ['action', 'confrontation', 'revelation'],
    'RESOLUTION': ['aftermath', 'decision_point', 'revelation'],
  };

  // Determine which categories to use
  let categories = [];

  // First try chapter beat type
  if (chapterBeatType?.type && categoryMap[chapterBeatType.type]) {
    categories = categoryMap[chapterBeatType.type];
  }
  // Fall back to subchapter beat type
  else if (beatType && categoryMap[beatType]) {
    categories = categoryMap[beatType];
  }
  // Default mix
  else {
    categories = ['dialogue_tension', 'internal_monologue', 'investigation'];
  }

  // Get scenes from selected categories
  const scenesPerCategory = Math.ceil(limit / categories.length);
  const selectedScenes = categories.flatMap(category =>
    getScenesByCategory(category, scenesPerCategory)
  ).slice(0, limit);

  if (selectedScenes.length === 0) {
    return ''; // No many-shot examples available
  }

  // Build the many-shot section
  const categoryNames = categories.map(c => {
    const metadata = MANY_SHOT_METADATA[c];
    return `${c} (${metadata?.totalExamples || 0} examples)`;
  }).join(', ');

  return `
## MANY-SHOT LEARNING: ${categories[0].toUpperCase()} SCENES
Study these ${selectedScenes.length} scene excerpts from Dennis Lehane's "Mystic River" to absorb patterns for ${categoryNames}:

${selectedScenes.map((scene, i) => `---
EXAMPLE ${i + 1}:
${scene}
`).join('\n')}

---
These scenes demonstrate the natural rhythm, dialogue patterns, and emotional beats characteristic of masterful noir fiction. Let them guide your voice, pacing, and scene construction.
`;
};

// ============================================================================
// VOICE DNA - Character-specific speech patterns
// ============================================================================
const buildVoiceDNASection = (charactersInScene = [], context = {}, currentChapter = 2) => {
  const { VOICE_DNA } = require('../data/characterReference');

  // Only Jack and Victoria have canonical voice DNA - LLM has freedom for other characters
  const voicesToInclude = ['jack'];

  // Add Victoria if she's in the scene
  charactersInScene.forEach(char => {
    const normalizedChar = char.toLowerCase();
    if (normalizedChar.includes('victoria') || normalizedChar.includes('blackwell')) {
      voicesToInclude.push('victoria');
    }
  });

  // Deduplicate
  const uniqueVoices = [...new Set(voicesToInclude)];

  // Extract recent dialogue from last 2 chapters
  const recentDialogue = extractRecentDialogue(context, currentChapter, uniqueVoices);

  let voiceSection = `
## CHARACTER VOICE DNA
Use these patterns to maintain consistent character voices:

`;

  uniqueVoices.forEach(voiceKey => {
    const voice = VOICE_DNA[voiceKey];
    if (!voice) return;

    voiceSection += `### ${voice.name}
**Sentence Patterns:**
${voice.sentencePatterns.map(p => `- ${p}`).join('\n')}

**Vocabulary Tendencies:**
${voice.vocabularyTendencies.map(v => `- ${v}`).join('\n')}

**Physical Tells:**
${voice.physicalTells.map(t => `- ${t}`).join('\n')}

**Dialogue Rhythm:**
${voice.dialogueRhythm.map(r => `- ${r}`).join('\n')}
`;

    // Add recent dialogue examples if available
    if (recentDialogue[voiceKey] && recentDialogue[voiceKey].length > 0) {
      voiceSection += `
**Recent Dialogue Examples:**
${recentDialogue[voiceKey].map(d => `- "${d}"`).join('\n')}
`;
    }

    voiceSection += '\n';
  });

  return voiceSection;
};

/**
 * Extract recent dialogue from the last 2 chapters for specified characters
 */
const extractRecentDialogue = (context, currentChapter, characterKeys) => {
  const dialogueMap = {};
  characterKeys.forEach(key => { dialogueMap[key] = []; });

  if (!context.chapters || context.chapters.length === 0) {
    return dialogueMap;
  }

  // Get last 2 chapters of content
  const startChapter = Math.max(1, currentChapter - 2);
  const chaptersToScan = [];

  for (let ch = startChapter; ch < currentChapter; ch++) {
    const chapterData = context.chapters.find(c => c.chapter === ch);
    if (chapterData && chapterData.subchapters) {
      chapterData.subchapters.forEach(sub => {
        if (sub.narrative) {
          chaptersToScan.push(sub.narrative);
        }
        // Also check branching narrative paths if they exist
        if (sub.branchingNarrative) {
          const bn = sub.branchingNarrative;
          if (bn.opening?.text) chaptersToScan.push(bn.opening.text);
          if (bn.firstChoice?.options) {
            bn.firstChoice.options.forEach(opt => {
              if (opt.response) chaptersToScan.push(opt.response);
            });
          }
          if (bn.secondChoices) {
            bn.secondChoices.forEach(sc => {
              if (sc.options) {
                sc.options.forEach(opt => {
                  if (opt.response) chaptersToScan.push(opt.response);
                });
              }
            });
          }
        }
      });
    }
  }

  // Extract dialogue using simple regex matching
  // Looking for patterns like: "..." said Victoria, Victoria said "...", "dialogue."
  characterKeys.forEach(charKey => {
    const charNames = getCharacterNameVariants(charKey);
    const allText = chaptersToScan.join(' ');

    charNames.forEach(name => {
      // Pattern 1: "dialogue" said Name / Name said "dialogue"
      const pattern1 = new RegExp(`[""]([^""]{10,100})[""]\\s*(?:said|asked|replied|whispered|muttered)\\s+${name}`, 'gi');
      const pattern2 = new RegExp(`${name}\\s+(?:said|asked|replied|whispered|muttered)\\s*[""]([^""]{10,100})[""]`, 'gi');

      let matches1 = allText.matchAll(pattern1);
      let matches2 = allText.matchAll(pattern2);

      for (const match of matches1) {
        if (dialogueMap[charKey].length < 3) {
          dialogueMap[charKey].push(match[1].trim());
        }
      }

      for (const match of matches2) {
        if (dialogueMap[charKey].length < 3) {
          dialogueMap[charKey].push(match[1].trim());
        }
      }
    });
  });

  return dialogueMap;
};

/**
 * Get name variants for character matching
 * NOTE: Only Jack and Victoria are canonical - other characters are LLM-generated
 */
const getCharacterNameVariants = (charKey) => {
  const variants = {
    jack: ['Jack', 'Halloway'],
    victoria: ['Victoria', 'Blackwell'],
  };
  return variants[charKey] || [charKey];
};

class StoryGenerationService {
  constructor() {
    this.generatedStory = null;
    this.storyContext = null;
    this.isGenerating = false;
    this.consistencyLog = []; // Track facts for consistency checking
    this.pendingGenerations = new Map(); // Cache for in-flight generation promises
    this.pathPersonality = null; // Tracks cumulative player behavior pattern
    this.decisionConsequences = new Map(); // Tracks ongoing effects of player choices
    this.characterStates = new Map(); // Tracks character relationship/trust states
    this.narrativeThreads = []; // Active story threads that must be maintained

    // ========== Token Usage Tracking ==========
    // Track cumulative token usage across session for cost visibility
    this.tokenUsage = {
      totalPromptTokens: 0,
      totalCachedTokens: 0,
      totalCompletionTokens: 0,
      totalTokens: 0,
      callCount: 0,
      sessionStart: Date.now(),
    };

    // ========== Dynamic Personality Classification ==========
    // LLM-based player personality analysis (cached by choice history hash)
    this.dynamicPersonalityCache = {
      choiceHistoryHash: null,
      personality: null,
      timestamp: null,
    };

    // ========== NEW: Story Arc Planning System ==========
    this.storyArc = null; // Global story arc generated at start for consistency
    this.chapterOutlines = new Map(); // Pre-generated chapter outlines for seamless flow
    this.indexedFacts = null; // Smart fact index by relevance
    this.consistencyCheckpoints = new Map(); // Periodic state validation snapshots
    this.generatedConsequences = new Map(); // Dynamically generated decision consequences

    // ========== Thread Escalation System ==========
    // Tracks how many times a thread has been acknowledged without progress
    // After 2+ acknowledgments, threads become OVERDUE and must be resolved/failed
    this.threadAcknowledgmentCounts = new Map(); // threadId -> acknowledgment count

    // ========== Thread Archive System ==========
    // Stores resolved/failed threads compactly to reduce memory while preserving callback potential
    // Threads are archived when resolved and pruned after 3 chapters of distance
    this.archivedThreads = []; // Compressed archive of resolved threads
    this.maxArchivedThreads = 50; // Cap on archived thread storage
    this.archiveChapterRetention = 3; // Keep archived threads for N chapters after resolution

    // ========== Generation Retry Tracking ==========
    this.generationAttempts = new Map(); // Track retry attempts per content
    this.maxGenerationAttempts = 3; // Max attempts before failing

    // ========== Generation Concurrency Limiter ==========
    // Sequential only - no concurrent LLM requests
    // Concurrent requests cause network issues on mobile (connections killed after ~4 min)
    // and React Native doesn't support streaming so heartbeats don't help
    this.maxConcurrentGenerations = 1; // Sequential LLM calls only
    this.activeGenerationCount = 0; // Current in-flight generations
    this.generationWaitQueue = []; // Queue of { resolve, reject, key } for waiting generations

    // ========== A+ QUALITY: Setup/Payoff Registry ==========
    this._initializeSetupPayoffRegistry();

    // ========== CONTEXT CACHING OPTIMIZATION ==========
    // Cache for static prompt content (Story Bible, Character Reference, etc.)
    this.staticCacheKey = null; // Key for the static content cache
    this.staticCacheVersion = 2; // Increment when static content changes

    // Cache for "chapter start" prefixes (static + story up to previous chapter).
    // This lets subchapters within a chapter send only the delta (current chapter so far).
    this.chapterStartCacheVersion = 1; // Increment when chapter cache format changes
    this.chapterStartCacheKeys = new Map(); // logicalKey -> cacheKey

    // ========== PROMPT LOGGING FOR DEBUGGING ==========
    // Stores cache content locally so we can log the complete prompt sent to LLM
    this.chapterStartCacheContent = new Map(); // cacheKey -> { systemInstruction, content }
  }

  // ==========================================================================
  // TOKEN USAGE TRACKING - Monitor costs and efficiency
  // ==========================================================================

  /**
   * Log and track token usage from an LLM response
   * Provides prominent console logging and cumulative tracking for cost visibility
   * @param {Object} usage - Token usage object from LLM response
   * @param {string} context - Context string for the log (e.g., "Chapter 2.A")
   */
  _trackTokenUsage(usage, context) {
    if (!usage) return;

    const promptTokens = usage.promptTokens || 0;
    const cachedTokens = usage.cachedTokens || 0;
    const completionTokens = usage.completionTokens || 0;
    const totalTokens = usage.totalTokens || (promptTokens + completionTokens);

    // Update cumulative totals
    this.tokenUsage.totalPromptTokens += promptTokens;
    this.tokenUsage.totalCachedTokens += cachedTokens;
    this.tokenUsage.totalCompletionTokens += completionTokens;
    this.tokenUsage.totalTokens += totalTokens;
    this.tokenUsage.callCount += 1;

    // Calculate cache efficiency (percentage of prompt tokens that were cached)
    const cacheEfficiency = promptTokens > 0 ? Math.round((cachedTokens / promptTokens) * 100) : 0;

    // Estimate cost (Gemini 3 Flash pricing: $0.10/1M input, $0.40/1M output, 50% discount on cached)
    // Source: https://ai.google.dev/pricing
    const inputCost = ((promptTokens - cachedTokens) * 0.10 / 1000000) + (cachedTokens * 0.05 / 1000000);
    const outputCost = completionTokens * 0.40 / 1000000;
    const callCost = inputCost + outputCost;

    // Cumulative cost
    const cumulativeInputCost = ((this.tokenUsage.totalPromptTokens - this.tokenUsage.totalCachedTokens) * 0.10 / 1000000) +
                                (this.tokenUsage.totalCachedTokens * 0.05 / 1000000);
    const cumulativeOutputCost = this.tokenUsage.totalCompletionTokens * 0.40 / 1000000;
    const cumulativeCost = cumulativeInputCost + cumulativeOutputCost;

    // Session duration
    const sessionMinutes = Math.round((Date.now() - this.tokenUsage.sessionStart) / 60000);

    // Token usage logging - only in verbose mode
    log.debug('StoryGen', `📊 ${context}: ${promptTokens.toLocaleString()} in (${cacheEfficiency}% cached), ${completionTokens.toLocaleString()} out, $${callCost.toFixed(4)}`);
  }

  /**
   * Get current token usage statistics
   * @returns {Object} Token usage stats with cost estimates
   */
  getTokenUsageStats() {
    const cumulativeInputCost = ((this.tokenUsage.totalPromptTokens - this.tokenUsage.totalCachedTokens) * 0.10 / 1000000) +
                                (this.tokenUsage.totalCachedTokens * 0.05 / 1000000);
    const cumulativeOutputCost = this.tokenUsage.totalCompletionTokens * 0.40 / 1000000;
    const sessionMinutes = Math.round((Date.now() - this.tokenUsage.sessionStart) / 60000);

    return {
      ...this.tokenUsage,
      estimatedCost: cumulativeInputCost + cumulativeOutputCost,
      cacheEfficiency: this.tokenUsage.totalPromptTokens > 0
        ? Math.round((this.tokenUsage.totalCachedTokens / this.tokenUsage.totalPromptTokens) * 100)
        : 0,
      sessionDurationMinutes: sessionMinutes,
    };
  }

  // ==========================================================================
  // DYNAMIC PERSONALITY CLASSIFICATION - LLM-based player behavior analysis
  // ==========================================================================

  /**
   * Generate a hash of choice history for cache invalidation
   * @param {Array} choiceHistory - Player's choice history
   * @returns {string} Hash string
   */
  _hashChoiceHistory(choiceHistory) {
    if (!choiceHistory || choiceHistory.length === 0) return 'empty';
    return choiceHistory.map(c => `${c.caseNumber}:${c.optionKey}`).join('|');
  }

  /**
   * URL-safe short hash for cache keys (do NOT use raw ":" / "|" strings in cache identifiers).
   * Deterministic, lightweight, and safe across JS runtimes.
   */
  _hashChoiceHistoryForCache(choiceHistory) {
    const s = this._hashChoiceHistory(choiceHistory);
    // FNV-1a 32-bit
    let h = 0x811c9dc5;
    for (let i = 0; i < s.length; i++) {
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 0x01000193);
    }
    // Convert to unsigned and base36 for compactness.
    return (h >>> 0).toString(36);
  }

  /**
   * Dynamically classify player personality using LLM
   * Uses Gemini to analyze actual choice patterns and provide richer personality assessment
   * Falls back to keyword-based analysis if LLM fails
   * @param {Array} choiceHistory - Player's choice history
   * @returns {Promise<Object>} Personality classification with narrativeStyle, dialogueTone, riskTolerance
   */
  async _classifyPersonalityDynamic(choiceHistory) {
    // If no choices yet, return balanced default
    if (!choiceHistory || choiceHistory.length === 0) {
      return {
        ...PATH_PERSONALITY_TRAITS.BALANCED,
        source: 'default',
      };
    }

    // Check cache - if choice history hasn't changed, use cached result
    const currentHash = this._hashChoiceHistory(choiceHistory);
    if (this.dynamicPersonalityCache.choiceHistoryHash === currentHash &&
        this.dynamicPersonalityCache.personality) {
      log.debug('StoryGen', '🧠 Using cached personality classification');
      return this.dynamicPersonalityCache.personality;
    }

    log.debug('StoryGen', `🧠 Classifying player personality (${choiceHistory.length} choices)...`);

    try {
      // Build choice summary for LLM
      const choiceSummary = choiceHistory.map(choice => {
        const chapter = this._extractChapterFromCase(choice.caseNumber);
        const consequence = DECISION_CONSEQUENCES[choice.caseNumber]?.[choice.optionKey];
        return {
          chapter,
          choice: choice.optionKey,
          description: consequence?.immediate || `Chose option ${choice.optionKey}`,
        };
      });

      const classificationPrompt = `Analyze this player's decision pattern in an interactive mystery thriller (modern city + hidden fantasy layer) and classify their play style.

PLAYER'S CHOICES:
${choiceSummary.map(c => `- Chapter ${c.chapter}: ${c.description}`).join('\n')}

Based on these choices, classify the player's approach. Consider:
- Do they prefer direct confrontation or careful investigation?
- Are they impulsive or methodical?
- Do they prioritize speed or thoroughness?
- Do they treat anomalies as noise, or as a pattern worth chasing?

Respond with a JSON object containing:
- "dominantStyle": one of "AGGRESSIVE", "METHODICAL", or "BALANCED"
- "narrativeStyle": a sentence describing how Jack (the protagonist) acts based on this play style
- "dialogueTone": how Jack's dialogue should sound (e.g., "direct and confrontational", "measured and analytical", "adaptable")
- "riskTolerance": "high", "moderate", or "low"
- "characterInsight": a brief observation about this player's detective persona (1 sentence)`;

      const response = await llmService.complete(
        [{ role: 'user', content: classificationPrompt }],
        {
          systemPrompt: 'You are an expert at analyzing player behavior in narrative games. Provide concise, insightful classifications.',
          maxTokens: GENERATION_CONFIG.maxTokens.classification,
          responseSchema: {
            type: 'object',
            properties: {
              dominantStyle: { type: 'string', enum: ['AGGRESSIVE', 'METHODICAL', 'BALANCED'] },
              narrativeStyle: { type: 'string' },
              dialogueTone: { type: 'string' },
              riskTolerance: { type: 'string', enum: ['high', 'moderate', 'low'] },
              characterInsight: { type: 'string' },
            },
            required: ['dominantStyle', 'narrativeStyle', 'dialogueTone', 'riskTolerance'],
          },
          traceId: `personality-${Date.now()}`,
          thinkingLevel: 'low', // Quick classification, don't need deep reasoning
        }
      );

      // Track token usage
      this._trackTokenUsage(response?.usage, 'Personality classification');

      // Parse response
      let classification;
      try {
        classification = typeof response.content === 'string'
          ? JSON.parse(response.content)
          : response.content;
      } catch (parseErr) {
        console.warn(`[StoryGen] ⚠️ Failed to parse personality classification, using fallback`);
        const fallback = this._analyzePathPersonality(choiceHistory);
        return { ...fallback, source: 'keyword-fallback' };
      }

      // Build personality object
      const personality = {
        narrativeStyle: classification.narrativeStyle || PATH_PERSONALITY_TRAITS.BALANCED.narrativeStyle,
        dialogueTone: classification.dialogueTone || PATH_PERSONALITY_TRAITS.BALANCED.dialogueTone || 'adapts to the situation',
        riskTolerance: classification.riskTolerance || 'moderate',
        dominantStyle: classification.dominantStyle || 'BALANCED',
        characterInsight: classification.characterInsight || null,
        source: 'llm-dynamic',
      };

      // Cache the result
      this.dynamicPersonalityCache = {
        choiceHistoryHash: currentHash,
        personality,
        timestamp: Date.now(),
      };

      log.debug('StoryGen', `🧠 Personality: ${personality.dominantStyle} - "${personality.narrativeStyle}"${personality.characterInsight ? ` (${personality.characterInsight})` : ''}`);

      return personality;

    } catch (error) {
      console.warn(`[StoryGen] ⚠️ Dynamic personality classification failed:`, error.message);
      console.warn(`[StoryGen] Falling back to keyword-based analysis`);

      // Fall back to keyword-based analysis
      const fallback = this._analyzePathPersonality(choiceHistory);
      return { ...fallback, source: 'keyword-fallback' };
    }
  }

  // ==========================================================================
  // ==========================================================================
  // STORY ARC PLANNING - Generates high-level outline for 100% consistency
  // ==========================================================================

  /**
   * Generate or retrieve the story arc - called once at the start of dynamic generation
   * This ensures ALL 12 chapters follow a coherent narrative thread regardless of player choices
   *
   * PERSONALITY DRIFT HANDLING:
   * If the player's personality has shifted significantly since the arc was created,
   * we adapt the remaining (unplayed) chapters rather than fully regenerating.
   * This preserves narrative continuity while allowing the story to evolve with the player.
   */
  async ensureStoryArc(choiceHistory = []) {
    const currentPersonality = this._analyzePathPersonality(choiceHistory);
    const superPathKey = this._getSuperPathKey(choiceHistory);
    const arcKey = `arc_${superPathKey}`;

    // If we have an existing arc, check for personality drift
    if (this.storyArc) {
      const drift = this._detectPersonalityDrift(this.storyArc, currentPersonality, choiceHistory);

      if (drift.shouldAdapt) {
        log.debug('StoryGenerationService', `Personality drift: ${drift.from} -> ${drift.to} (magnitude: ${drift.magnitude.toFixed(1)})`);

        // Adapt the arc for the new personality (only future chapters)
        const currentChapter = Math.max(2, choiceHistory.length + 2); // Estimate current chapter
        const adaptedArc = await this._adaptStoryArcForDrift(this.storyArc, currentPersonality, currentChapter, choiceHistory);
        this.storyArc = adaptedArc;
        await this._saveStoryArc(adaptedArc.key, adaptedArc);
        return adaptedArc;
      }

      // No significant drift, return existing arc
      if (this.storyArc.key === arcKey) {
        return this.storyArc;
      }
    }

    // Check persistent storage
    const savedArc = await this._loadStoryArc(arcKey);
    if (savedArc) {
      // Check for drift against saved arc too
      const drift = this._detectPersonalityDrift(savedArc, currentPersonality, choiceHistory);
      if (drift.shouldAdapt) {
        log.debug('StoryGenerationService', `Personality drift from saved arc: ${drift.from} -> ${drift.to}`);
        const currentChapter = Math.max(2, choiceHistory.length + 2);
        const adaptedArc = await this._adaptStoryArcForDrift(savedArc, currentPersonality, currentChapter, choiceHistory);
        this.storyArc = adaptedArc;
        await this._saveStoryArc(adaptedArc.key, adaptedArc);
        return adaptedArc;
      }

      this.storyArc = savedArc;
      return savedArc;
    }

    // Build story arc from STORY_STRUCTURE data (no LLM call needed)
    log.debug('StoryGenerationService', `Building story arc for super-path: ${superPathKey}`);
    const storyArc = this._createStoryArc(superPathKey, choiceHistory);
    storyArc.personalitySnapshot = {
      riskTolerance: currentPersonality.riskTolerance,
      scores: currentPersonality.scores || { aggressive: 0, methodical: 0 },
      choiceCount: choiceHistory.length,
    };
    this.storyArc = storyArc;
    await this._saveStoryArc(arcKey, storyArc);
    return storyArc;
  }

  /**
   * Detect if player personality has drifted significantly from when the arc was created.
   *
   * Drift is significant when:
   * 1. Risk tolerance category has changed (low->high, high->low, or to/from moderate)
   * 2. Score magnitude has shifted by more than 20 points
   * 3. At least 2 new decisions have been made since arc creation
   */
  _detectPersonalityDrift(arc, currentPersonality, choiceHistory) {
    const snapshot = arc.personalitySnapshot;

    // No snapshot means old arc format - can't detect drift
    if (!snapshot) {
      return { shouldAdapt: false, magnitude: 0 };
    }

    const currentScores = currentPersonality.scores || { aggressive: 0, methodical: 0 };
    const snapshotScores = snapshot.scores || { aggressive: 0, methodical: 0 };

    // Calculate score drift magnitude
    const aggressiveDrift = currentScores.aggressive - snapshotScores.aggressive;
    const methodicalDrift = currentScores.methodical - snapshotScores.methodical;
    const magnitude = Math.abs(aggressiveDrift - methodicalDrift);

    // Check if risk tolerance category changed
    const categoryChanged = snapshot.riskTolerance !== currentPersonality.riskTolerance;

    // Require at least 2 new decisions to consider adaptation
    const newDecisions = choiceHistory.length - (snapshot.choiceCount || 0);
    const hasEnoughNewDecisions = newDecisions >= 2;

    // Determine if we should adapt
    // Threshold: category change OR significant score drift (>25 points)
    const significantDrift = magnitude > 25;
    const shouldAdapt = hasEnoughNewDecisions && (categoryChanged || significantDrift);

    return {
      shouldAdapt,
      magnitude,
      from: snapshot.riskTolerance,
      to: currentPersonality.riskTolerance,
      categoryChanged,
      newDecisions,
      aggressiveDrift,
      methodicalDrift,
    };
  }

  /**
   * Adapt the story arc for a personality shift without regenerating played chapters.
   *
   * This preserves:
   * - Chapter arcs that have already been played
   * - Core consistency anchors
   * - Character arc foundations
   *
   * This adapts:
   * - Future chapter focuses and tension levels
   * - Decision themes for upcoming choices
   * - Overall theme evolution
   */
  async _adaptStoryArcForDrift(originalArc, newPersonality, currentChapter, choiceHistory) {
    const newSuperPathKey = this._getSuperPathKey(choiceHistory);

    // Start with the original arc
    const adaptedArc = {
      ...originalArc,
      key: `arc_${newSuperPathKey}`,
      superPathKey: newSuperPathKey,
      previousSuperPathKey: originalArc.superPathKey,
      adaptedAt: new Date().toISOString(),
      adaptedFromChapter: currentChapter,
      personalitySnapshot: {
        riskTolerance: newPersonality.riskTolerance,
        scores: newPersonality.scores || { aggressive: 0, methodical: 0 },
        choiceCount: choiceHistory.length,
      },
    };

    // Adapt the overall theme to reflect personality evolution
    adaptedArc.overallTheme = this._adaptThemeForPersonality(
      originalArc.overallTheme,
      originalArc.superPathKey,
      newSuperPathKey
    );

    // Adapt future chapter arcs (preserve played chapters)
    if (adaptedArc.chapterArcs && Array.isArray(adaptedArc.chapterArcs)) {
      adaptedArc.chapterArcs = adaptedArc.chapterArcs.map(chapterArc => {
        // Don't modify chapters already played
        if (chapterArc.chapter < currentChapter) {
          return chapterArc;
        }

        // Adapt future chapters for new personality
        return this._adaptChapterArcForPersonality(chapterArc, newPersonality, originalArc.superPathKey);
      });
    }

    // Update character arcs to reflect evolution
    if (adaptedArc.characterArcs) {
      adaptedArc.characterArcs = {
        ...adaptedArc.characterArcs,
        jack: this._adaptJackArcForPersonality(
          adaptedArc.characterArcs.jack,
          newPersonality,
          currentChapter
        ),
      };
    }

    log.debug('StoryGenerationService', `Arc adapted: ${originalArc.superPathKey} -> ${newSuperPathKey}`);

    return adaptedArc;
  }

  /**
   * Adapt the overall theme when personality shifts
   */
  _adaptThemeForPersonality(originalTheme, oldPath, newPath) {
    // If shifting to aggressive, emphasize action and confrontation
    if (newPath === 'AGGRESSIVE' && oldPath !== 'AGGRESSIVE') {
      if (originalTheme.includes('patient') || originalTheme.includes('investigation')) {
        return originalTheme.replace(
          /patient investigation|careful investigation|truth-seeking/gi,
          'decisive action and hard truths'
        );
      }
      return `${originalTheme}, now driven by urgency and confrontation`;
    }

    // If shifting to methodical, emphasize evidence and patience
    if (newPath === 'METHODICAL' && oldPath !== 'METHODICAL') {
      if (originalTheme.includes('action') || originalTheme.includes('confrontation')) {
        return originalTheme.replace(
          /decisive action|confrontation|urgency/gi,
          'methodical truth-seeking'
        );
      }
      return `${originalTheme}, tempered by careful investigation`;
    }

    // Shifting to balanced
    if (newPath === 'BALANCED') {
      return `${originalTheme}, adapting approach as circumstances demand`;
    }

    return originalTheme;
  }

  /**
   * Adapt a single chapter arc for the new personality
   */
  _adaptChapterArcForPersonality(chapterArc, newPersonality, oldPath) {
    const adapted = { ...chapterArc };

    // Adjust tension levels based on personality
    if (newPersonality.riskTolerance === 'high') {
      // Aggressive players: higher tension, more confrontational focuses
      adapted.tensionLevel = Math.min(10, (chapterArc.tensionLevel || 5) + 1);
      if (adapted.decisionTheme) {
        adapted.decisionTheme = adapted.decisionTheme.replace(
          /wait|gather|investigate carefully/gi,
          'act decisively'
        );
      }
    } else if (newPersonality.riskTolerance === 'low') {
      // Methodical players: slightly lower tension, more investigation focus
      adapted.tensionLevel = Math.max(1, (chapterArc.tensionLevel || 5) - 1);
      if (adapted.decisionTheme) {
        adapted.decisionTheme = adapted.decisionTheme.replace(
          /confront|attack|force/gi,
          'investigate thoroughly'
        );
      }
    }

    // Add personality adaptation note
    adapted.personalityAdapted = true;
    adapted.adaptedForPath = newPersonality.riskTolerance;

    return adapted;
  }

  /**
   * Adapt Jack's character arc description for personality evolution
   */
  _adaptJackArcForPersonality(originalJackArc, newPersonality, currentChapter) {
    const phaseDescriptor = currentChapter <= 4 ? 'early' :
                            currentChapter <= 7 ? 'mid-story' :
                            currentChapter <= 10 ? 'late' : 'final';

    if (newPersonality.riskTolerance === 'high') {
      return `${originalJackArc}. In the ${phaseDescriptor} chapters, Jack's patience wears thin and he pushes harder for answers.`;
    } else if (newPersonality.riskTolerance === 'low') {
      return `${originalJackArc}. In the ${phaseDescriptor} chapters, Jack becomes more deliberate, building his case methodically.`;
    }

    return `${originalJackArc}. In the ${phaseDescriptor} chapters, Jack adapts his approach to the situation at hand.`;
  }

  /**
   * Create story arc structure for consistent chapter generation.
   * Uses STORY_STRUCTURE from storyBible.js for phases and beat types.
   */
  _createStoryArc(superPathKey, choiceHistory) {
    const personality = this._analyzePathPersonality(choiceHistory);
    const { protagonist, antagonist } = ABSOLUTE_FACTS;
    const { pacing, chapterBeatTypes } = STORY_STRUCTURE;

    // Customize theme based on player personality
    const theme = personality.riskTolerance === 'high'
      ? 'Redemption through decisive action and confrontation'
      : personality.riskTolerance === 'low'
        ? 'Redemption through patient investigation and truth-seeking'
        : 'Redemption through confronting past mistakes';

    // Helper to get phase from STORY_STRUCTURE.pacing
    const getPhase = (chapter) => {
      if (chapter <= 4) return pacing.chapters2to4.phase;
      if (chapter <= 7) return pacing.chapters5to7.phase;
      if (chapter <= 10) return pacing.chapters8to10.phase;
      return pacing.chapters11to12.phase;
    };

    // Helper to get beat type from STORY_STRUCTURE.chapterBeatTypes
    const getBeatType = (chapter) => chapterBeatTypes[chapter]?.type || 'INVESTIGATION';
    const revealLabel = REVEAL_TIMING?.underMap?.firstUndeniable?.label || `1${formatSubchapterLabel(DECISION_SUBCHAPTER)}`;

    return {
      key: `arc_${superPathKey}`,
      superPathKey,
      playerPersonality: personality.riskTolerance || 'balanced',
      overallTheme: theme,
      chapterArcs: [
        { chapter: 2, phase: getPhase(2), beatType: getBeatType(2), primaryFocus: 'First threshold and first anchor thread', tensionLevel: 4, endingHook: 'A glyph behaves like a rule', personalStakes: `${protagonist.fullName}'s grip on "normal" reality`, emotionalAnchor: 'The moment an ordinary place stops behaving like a place' },
        { chapter: 3, phase: getPhase(3), beatType: getBeatType(3), primaryFocus: `Second anchor thread; ${antagonist.trueName}'s rules sharpen`, tensionLevel: 5, endingHook: 'A warning arrives too soon', personalStakes: `${protagonist.fullName}'s trust in his own senses`, emotionalAnchor: 'Realizing someone is guiding his route' },
        { chapter: 4, phase: getPhase(4), beatType: getBeatType(4), primaryFocus: 'Containment pressure appears', tensionLevel: 6, endingHook: 'A site is sealed', personalStakes: `${protagonist.fullName}'s ability to keep working openly`, emotionalAnchor: 'Watching denial happen in real time' },
        { chapter: 5, phase: getPhase(5), beatType: getBeatType(5), primaryFocus: 'Pattern across anchors becomes undeniable', tensionLevel: 7, endingHook: 'A map that should not exist', personalStakes: `${protagonist.fullName}'s relationship with allies and with the city itself`, emotionalAnchor: 'A friend dodges the wrong question' },
        { chapter: 6, phase: getPhase(6), beatType: getBeatType(6), primaryFocus: 'Under-Map navigation and consequences', tensionLevel: 7, endingHook: 'A shortcut takes a price', personalStakes: `${protagonist.fullName}'s safety`, emotionalAnchor: 'Crossing a line that cannot be uncrossed' },
        { chapter: 7, phase: getPhase(7), beatType: getBeatType(7), primaryFocus: 'Containment forces tighten', tensionLevel: 8, endingHook: 'A witness vanishes', personalStakes: `${protagonist.fullName}'s moral line: protect a person vs chase a clue`, emotionalAnchor: 'Choosing what to save' },
        { chapter: 8, phase: getPhase(8), beatType: getBeatType(8), primaryFocus: `${antagonist.trueName}'s agenda surfaces`, tensionLevel: 8, endingHook: 'A demand, not a hint', personalStakes: `${protagonist.fullName}'s autonomy`, emotionalAnchor: 'Realizing the "help" is also a trap' },
        { chapter: 9, phase: getPhase(9), beatType: getBeatType(9), primaryFocus: 'Anchor nexus; symbols collide', tensionLevel: 9, endingHook: 'A threshold fails', personalStakes: `${protagonist.fullName}'s life and someone else's`, emotionalAnchor: 'A rescue attempt goes wrong' },
        { chapter: 10, phase: getPhase(10), beatType: getBeatType(10), primaryFocus: 'The mechanism behind the anchors', tensionLevel: 9, endingHook: 'The pattern names a culprit', personalStakes: `What ${protagonist.fullName} is willing to break`, emotionalAnchor: 'Accepting that rules can be weaponized' },
        { chapter: 11, phase: getPhase(11), beatType: getBeatType(11), primaryFocus: 'Final confrontation with containment', tensionLevel: 10, endingHook: 'Choose the city\'s shape', personalStakes: `${protagonist.fullName}'s identity: observer or participant`, emotionalAnchor: 'Owning the choice that changes everything' },
        { chapter: 12, phase: getPhase(12), beatType: getBeatType(12), primaryFocus: 'Consequences manifest', tensionLevel: 9, endingHook: 'A new map begins', personalStakes: `${protagonist.fullName}'s legacy and what he leaves open`, emotionalAnchor: 'A quiet cost paid in full' },
      ],
      characterArcs: {
        protagonist: `From skeptical pattern-hunter to Under-Map-literate investigator`,
        antagonist: `Guide who tests ${protagonist.fullName}'s capacity to read rules without becoming a weapon`,
      },
      consistencyAnchors: [
        `${protagonist.fullName} is ${protagonist.age} years old and does NOT start with Under-Map knowledge`,
        `${antagonist.trueName} guides ${protagonist.fullName} via dead letters, silver ink, and rules`,
        `The Under-Map is real; the first undeniable reveal happens at the end of ${revealLabel}`,
        'Glyphs behave like a language with constraints; do not "magic-system" explain - show',
        'Anchor disappearances form a deliberate pattern',
        `Only ${protagonist.fullName} and ${antagonist.trueName} are defined characters; LLM creates supporting characters as needed`,
      ],
      generatedAt: new Date().toISOString(),
    };
  }

  /**
   * Collapse fine-grained branch history into a stable "super-path" label.
   * This is used to key story-arc planning so we don't regenerate arcs every chapter.
   */
  _getSuperPathKey(choiceHistory = []) {
    const personality = this._analyzePathPersonality(choiceHistory);
    if (personality?.riskTolerance === 'high') return 'AGGRESSIVE';
    if (personality?.riskTolerance === 'low') return 'METHODICAL';
    return 'BALANCED';
  }

  /**
   * Generate a chapter outline before generating individual subchapters
   * This ensures A, B, C subchapters flow seamlessly as one coherent chapter
   */
  async ensureChapterOutline(chapter, choiceHistory = []) {
    const chapterPathKey = this._getPathKeyForChapter(chapter, choiceHistory);
    const outlineKey = `outline_${chapter}_${chapterPathKey}`;

    // Check if we already have this outline
    if (this.chapterOutlines.has(outlineKey)) {
      return this.chapterOutlines.get(outlineKey);
    }

    // Ensure we have the story arc first
    await this.ensureStoryArc(choiceHistory);

    // Build chapter outline from STORY_STRUCTURE data (no LLM call needed)
    console.log(`[StoryGenerationService] Building chapter outline for Chapter ${chapter}`);
    const chapterOutline = this._createChapterOutline(chapter, chapterPathKey);
    this.chapterOutlines.set(outlineKey, chapterOutline);
    return chapterOutline;
  }


  /**
   * Create chapter outline structure using STORY_STRUCTURE from storyBible.js.
   * Provides consistent structure for story generation.
   */
  _createChapterOutline(chapter, pathKey) {
    const { protagonist, setting } = ABSOLUTE_FACTS;
    const { pacing, chapterBeatTypes } = STORY_STRUCTURE;

    // Get phase and beat type from STORY_STRUCTURE
    let pacingData;
    if (chapter <= 4) pacingData = pacing.chapters2to4;
    else if (chapter <= 7) pacingData = pacing.chapters5to7;
    else if (chapter <= 10) pacingData = pacing.chapters8to10;
    else pacingData = pacing.chapters11to12;

    const beatType = chapterBeatTypes[chapter] || { type: 'INVESTIGATION', description: 'Methodical evidence gathering' };
    const tensionLevel = Math.min(10, 4 + Math.floor(chapter / 2));

    return {
      chapter,
      pathKey,
      summary: `Chapter ${chapter}: ${protagonist.fullName} continues the investigation into the symbols and the hidden layer beneath ${setting.city}.`,
      openingMood: 'Mystery-thriller atmosphere with building unease',
      openingCausality: 'The chapter opens by showing the immediate consequence of the player\'s last decision (location, character reaction, and next action).',
      mustReference: [`${setting.city} damp/reflections`, `The jukebox below ${protagonist.fullName}'s office`, 'A dead letter with silver ink', 'One named character from the current investigation'],
      subchapterA: {
        focus: `Opening: ${beatType.description}`,
        keyBeats: [
          `${protagonist.fullName} reflects on recent discoveries`,
          'New information comes to light',
          'The investigation takes a turn',
        ],
        endingTransition: 'A lead demands immediate attention',
      },
      subchapterB: {
        focus: `Development: The mystery deepens`,
        keyBeats: [
          `${protagonist.fullName} pursues the new lead`,
          'Unexpected obstacles arise',
          'A piece of the puzzle falls into place',
        ],
        endingTransition: `${protagonist.fullName} faces a difficult choice`,
      },
      subchapterC: {
        focus: `Climax: Decision point`,
        keyBeats: [
          'Tensions reach a breaking point',
          'The truth demands a response',
          `${protagonist.fullName} must choose the path forward`,
        ],
        decisionSetup: 'A choice between two difficult paths',
      },
      tensionLevel,
      phase: pacingData.phase,
      beatType: beatType.type,
      consistencyAnchors: [
        `${protagonist.fullName} seeks the truth`,
        'The conspiracy runs deep',
        'Every choice has consequences',
      ],
      generatedAt: new Date().toISOString(),
    };
  }

  async _loadStoryArc(arcKey) {
    try {
      const data = await AsyncStorage.getItem(`story_arc_${arcKey}`);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      console.warn('[StoryGenerationService] Failed to load story arc:', error.message);
      return null;
    }
  }

  async _saveStoryArc(arcKey, arc) {
    try {
      await AsyncStorage.setItem(`story_arc_${arcKey}`, JSON.stringify(arc));
    } catch (error) {
      console.warn('[StoryGenerationService] Failed to save story arc:', error);
    }
  }

  // ==========================================================================
  // DYNAMIC CONSEQUENCE GENERATION - Auto-generates consequences for all decisions
  // ==========================================================================

  /**
   * Ensure we have consequences generated for all player decisions
   * This fills in gaps in the static DECISION_CONSEQUENCES registry
   */
  async _ensureDecisionConsequences(choiceHistory) {
    for (const choice of choiceHistory) {
      const consequenceKey = `${choice.caseNumber}_${choice.optionKey}`;

      // Skip if we already have this consequence (static or generated)
      if (DECISION_CONSEQUENCES[choice.caseNumber]?.[choice.optionKey]) {
        continue;
      }
      if (this.generatedConsequences.has(consequenceKey)) {
        continue;
      }

      // Generate consequences for this decision
      const consequence = await this._generateDecisionConsequence(choice, choiceHistory);
      this.generatedConsequences.set(consequenceKey, consequence);

      // Also store in the registry for future use
      if (!DECISION_CONSEQUENCES[choice.caseNumber]) {
        DECISION_CONSEQUENCES[choice.caseNumber] = {};
      }
      DECISION_CONSEQUENCES[choice.caseNumber][choice.optionKey] = consequence;
    }
  }

  /**
   * Fast, non-LLM consequence hydration.
   *
   * Goal: preserve choice causality in prompts without adding latency.
   * - Uses DECISION_CONSEQUENCES if present
   * - Falls back to storyContext.decisionConsequencesByKey if persisted
   * - Otherwise derives a lightweight consequence from the decision entry metadata
   */
  _ensureDecisionConsequencesFast(choiceHistory) {
    const history = Array.isArray(choiceHistory) ? choiceHistory : [];
    if (history.length === 0) return;

    const ctx = this.storyContext || {};
    if (!ctx.decisionConsequencesByKey) ctx.decisionConsequencesByKey = {};

    const deriveFromDecisionEntry = (choice) => {
      const chapter = this._extractChapterFromCase(choice.caseNumber);
      const decisionPathKey = this._getPathKeyForChapter(chapter, history);
      const decisionEntry = this.getGeneratedEntry(choice.caseNumber, decisionPathKey) || getStoryEntry(choice.caseNumber, 'ROOT');
      // Handle both legacy (decision) and new (pathDecisions) formats
      // Use player's actual branching path for path-specific decision lookup
      const decisionData = this._getPathDecisionData(decisionEntry, choice.caseNumber, this.currentBranchingChoices || []);
      const chosen = decisionData?.options?.find((o) => o.key === choice.optionKey)
        || (choice.optionKey === 'A' ? decisionData?.optionA : decisionData?.optionB)
        || null;

      const title = chosen?.title || `Option ${choice.optionKey}`;
      const focus = chosen?.focus || '';
      const stats = chosen?.stats || '';

      const ongoing = [];
      if (typeof stats === 'string') {
        if (stats.toLowerCase().includes('investig')) ongoing.push('Jack gains better leads through evidence');
        if (stats.toLowerCase().includes('aggress')) ongoing.push("Jack's approach grows more confrontational");
      }
      if (typeof focus === 'string' && focus.length > 0) {
        ongoing.unshift(`Tone shift: ${focus}`);
      }

      // Character impact based on approach - not tied to specific non-canonical characters
      const characterImpact = {
        aggression: focus.toLowerCase().includes('confront') ? 10 : focus.toLowerCase().includes('cautious') ? -5 : 0,
        thoroughness: focus.toLowerCase().includes('evidence') ? 10 : 0,
      };

      // Make the "immediate" consequence feel concrete even without an LLM call.
      // Titles are imperative; convert to an infinitive-ish phrase ("Confront Wade" -> "confront Wade").
      const toAction = String(title || '')
        .trim()
        .replace(/^[A-Z]/, (m) => m.toLowerCase());
      const focusSnippet = String(focus || '')
        .split('.')
        .map((s) => s.trim())
        .filter(Boolean)
        .slice(0, 2)
        .join('. ');
      const immediate = toAction
        ? `Jack chose to ${toAction}${focusSnippet ? `. ${focusSnippet}.` : '.'}`
        : `Jack chose: ${title}`;

      return {
        immediate,
        ongoing: ongoing.length > 0 ? ongoing.slice(0, 4) : ['This choice will shape what Jack can prove, and who will trust him.'],
        characterImpact,
      };
    };

    for (const choice of history) {
      const caseNumber = choice?.caseNumber;
      const optionKey = choice?.optionKey;
      if (!caseNumber || (optionKey !== 'A' && optionKey !== 'B')) continue;

      const consequenceKey = `${caseNumber}_${optionKey}`;

      // Already known?
      if (DECISION_CONSEQUENCES[caseNumber]?.[optionKey]) {
        ctx.decisionConsequencesByKey[consequenceKey] = DECISION_CONSEQUENCES[caseNumber][optionKey];
        continue;
      }

      // Persisted?
      const persisted = ctx.decisionConsequencesByKey[consequenceKey];
      if (persisted) {
        if (!DECISION_CONSEQUENCES[caseNumber]) DECISION_CONSEQUENCES[caseNumber] = {};
        DECISION_CONSEQUENCES[caseNumber][optionKey] = persisted;
        continue;
      }

      // Derive cheaply from decision metadata.
      const derived = deriveFromDecisionEntry(choice);
      if (!DECISION_CONSEQUENCES[caseNumber]) DECISION_CONSEQUENCES[caseNumber] = {};
      DECISION_CONSEQUENCES[caseNumber][optionKey] = derived;
      ctx.decisionConsequencesByKey[consequenceKey] = derived;
    }

    // Fire-and-forget persistence (small payload).
    this.storyContext = ctx;
    saveStoryContext(ctx).catch((e) => {
      console.warn('[StoryGenerationService] Failed to persist decision consequences (fast):', e?.message);
    });
  }

  /**
   * Generate consequences for a single decision
   * Enhanced with full narrative context for more meaningful consequences
   */
  async _generateDecisionConsequence(choice, fullChoiceHistory = []) {
    const { protagonist, antagonist, setting } = ABSOLUTE_FACTS;
    const chapter = this._extractChapterFromCase(choice.caseNumber);

    // Try to get context from the decision itself if available
    const decisionPathKey = this._getPathKeyForChapter(chapter, fullChoiceHistory);
    const decisionEntry = this.getGeneratedEntry(choice.caseNumber, decisionPathKey);
    // Handle both legacy (decision) and new (pathDecisions) formats
    // Use player's actual branching path for path-specific decision lookup
    const decisionData = this._getPathDecisionData(decisionEntry, choice.caseNumber, this.currentBranchingChoices || []);
    const decisionContext = decisionData?.options?.find(o => o.key === choice.optionKey)
      || (choice.optionKey === 'A' ? decisionData?.optionA : decisionData?.optionB);
    const otherOption = decisionData?.options?.find(o => o.key !== choice.optionKey)
      || (choice.optionKey === 'A' ? decisionData?.optionB : decisionData?.optionA);

    // Extract narrative context for richer consequence generation
    const narrativeContext = decisionEntry?.narrative ? decisionEntry.narrative.slice(-2000) : '';
    const decisionIntro = decisionData?.intro?.[0] || '';
    const activeThreads = (
      decisionEntry?.consistencyFacts ||
      this._getRelevantPersistedConsistencyFacts(decisionPathKey) ||
      []
    ).slice(0, 5);
    const charactersInvolved = decisionData?.options?.flatMap(o => o.characters || []) || [];

    const consequencePrompt = `Generate narrative consequences for a player decision in an interactive mystery thriller with a hidden fantasy layer (the Under-Map).

## STORY CONTEXT
This is "Dead Letters" - ${protagonist.fullName}, a ${protagonist.age}-year-old ${protagonist.formerTitle.toLowerCase()}, is pulled into a hidden reality threaded through ${setting.city}'s streets. ${antagonist.trueName} sends dead letters with glyph strings and tokens that steer him toward thresholds and missing people.

## CHAPTER ${chapter} NARRATIVE LEADING TO DECISION
${narrativeContext ? `The following is the end of the narrative leading to this choice:
"""
${narrativeContext.slice(-1200)}
"""` : 'Narrative context not available.'}

## THE DECISION POINT
${decisionIntro ? `Decision setup: "${decisionIntro}"` : ''}

## PLAYER'S CHOICE: Option ${choice.optionKey}
${decisionContext ? `- Title: "${decisionContext.title}"
- Focus: "${decisionContext.focus}"` : '- Details not available'}

## THE PATH NOT TAKEN: Option ${otherOption?.key || 'N/A'}
${otherOption ? `- Title: "${otherOption.title}"
- Focus: "${otherOption.focus}"` : '- Details not available'}

## ACTIVE STORY ELEMENTS
${activeThreads.length > 0 ? activeThreads.map(t => `- ${t}`).join('\n') : '- No specific threads tracked'}
${charactersInvolved.length > 0 ? `\nCharacters involved: ${[...new Set(charactersInvolved)].join(', ')}` : ''}

## REQUIRED OUTPUT
Generate realistic, specific consequences based on the actual narrative content. Consider:
1. What doors does this choice open? What does it close?
2. How will characters involved react to Jack's decision?
3. What investigation leads are gained or lost?
4. How does this affect Jack's relationships and reputation?
5. What thematic weight does this choice carry (guilt, redemption, truth vs. comfort)?`;

    const consequenceSchema = {
      type: 'object',
      properties: {
        immediate: {
          type: 'string',
          description: 'One sentence describing what Jack did',
        },
        ongoing: {
          type: 'array',
          items: { type: 'string' },
          description: '2-4 ongoing effects that will ripple through future chapters',
        },
        characterImpact: {
          type: 'object',
          properties: {
            trust: { type: 'number', description: 'Change to trust relationships (-20 to +20)' },
            aggression: { type: 'number', description: 'Change to aggression level (-20 to +20)' },
            thoroughness: { type: 'number', description: 'Change to investigation thoroughness (-20 to +20)' },
          },
        },
      },
      required: ['immediate', 'ongoing', 'characterImpact'],
    };

    try {
      const response = await llmService.complete(
        [{ role: 'user', content: consequencePrompt }],
        {
          systemPrompt: 'You are generating narrative consequences for player choices in a mystery thriller with a hidden fantasy layer.',
          maxTokens: GENERATION_CONFIG.maxTokens.consequences,
          responseSchema: consequenceSchema,
        }
      );

      const consequence = typeof response.content === 'string'
        ? JSON.parse(response.content)
        : response.content;

      return consequence;
    } catch (error) {
      console.warn('[StoryGenerationService] Failed to generate consequence:', error);
      // Return default consequence
      return {
        immediate: `Jack chose path ${choice.optionKey}`,
        ongoing: ['This choice will affect future events'],
        // Default mapping: Option A tends to be evidence-first/methodical; Option B tends to be direct/aggressive.
        characterImpact: { trust: 0, aggression: choice.optionKey === 'B' ? 5 : -5, thoroughness: choice.optionKey === 'A' ? 5 : -5 },
      };
    }
  }

  // ==========================================================================
  // SMART FACT INDEXING - Indexes facts by relevance for efficient context building
  // ==========================================================================

  /**
   * Build indexed facts from generated content for efficient retrieval
   */
  _buildIndexedFacts(chapters) {
    const index = {
      byCharacter: new Map(),      // Facts mentioning specific characters
      byChapter: new Map(),        // Facts from specific chapters
      byType: new Map(),           // Facts by type (timeline, setting, relationship, etc.)
      critical: [],                // Always-include critical facts
      recent: [],                  // Most recent facts (high priority)
    };

    // Add base consistency rules as critical
    index.critical.push(...CONSISTENCY_RULES.slice(0, 15));

    // Index facts from chapters
    chapters.forEach(ch => {
      if (!ch.consistencyFacts) return;

      ch.consistencyFacts.forEach(fact => {
        // Index by chapter
        if (!index.byChapter.has(ch.chapter)) {
          index.byChapter.set(ch.chapter, []);
        }
        index.byChapter.get(ch.chapter).push(fact);

        // Index by character mentioned - only canonical characters have static entries
        // Other character names are dynamically discovered from generated content
        const canonicalCharacters = ['Jack', 'Victoria', 'Blackwell'];
        canonicalCharacters.forEach(char => {
          if (fact.toLowerCase().includes(char.toLowerCase())) {
            if (!index.byCharacter.has(char)) {
              index.byCharacter.set(char, []);
            }
            index.byCharacter.get(char).push(fact);
          }
        });

        // Index by type
        if (/\d+\s*(year|month|day|hour)/i.test(fact)) {
          if (!index.byType.has('timeline')) index.byType.set('timeline', []);
          index.byType.get('timeline').push(fact);
        }
        if (/meet|promise|agree|plan/i.test(fact)) {
          if (!index.byType.has('appointment')) index.byType.set('appointment', []);
          index.byType.get('appointment').push(fact);
        }
        if (/reveal|discover|learn|find out/i.test(fact)) {
          if (!index.byType.has('revelation')) index.byType.set('revelation', []);
          index.byType.get('revelation').push(fact);
        }
      });
    });

    // Track recent facts (last 2 chapters)
    const sortedChapters = [...chapters].sort((a, b) => {
      if (a.chapter !== b.chapter) return b.chapter - a.chapter;
      return b.subchapter - a.subchapter;
    });
    sortedChapters.slice(0, 6).forEach(ch => {
      if (ch.consistencyFacts) {
        index.recent.push(...ch.consistencyFacts);
      }
    });

    return index;
  }

  /**
   * Get relevant facts for a specific chapter/subchapter
   * Uses smart selection instead of dumping all facts
   */
  _getRelevantFacts(targetChapter, targetSubchapter, indexedFacts, context) {
    const relevantFacts = new Set();

    // Always include critical facts
    indexedFacts.critical.forEach(f => relevantFacts.add(f));

    // Include recent facts (high priority)
    indexedFacts.recent.slice(0, 10).forEach(f => relevantFacts.add(f));

    // Include facts from previous chapter (continuity)
    const prevChapterFacts = indexedFacts.byChapter.get(targetChapter - 1) || [];
    prevChapterFacts.forEach(f => relevantFacts.add(f));

    // Include facts from current chapter's previous subchapters
    if (targetSubchapter > 1) {
      const currChapterFacts = indexedFacts.byChapter.get(targetChapter) || [];
      currChapterFacts.forEach(f => relevantFacts.add(f));
    }

    // Include character-specific facts based on story arc
    const chapterArc = context.storyArc?.chapterArcs?.find(c => c.chapter === targetChapter);
    if (chapterArc?.innocentFeatured) {
      const characterFacts = indexedFacts.byCharacter.get(chapterArc.innocentFeatured) || [];
      characterFacts.forEach(f => relevantFacts.add(f));
    }

    // Include appointment/promise facts (must be tracked)
    const appointmentFacts = indexedFacts.byType.get('appointment') || [];
    appointmentFacts.slice(-5).forEach(f => relevantFacts.add(f));

    return [...relevantFacts].slice(0, 25); // Cap at 25 facts to manage token usage
  }

  // ==========================================================================
  // CONSISTENCY CHECKPOINTS - Periodic validation of accumulated state
  // ==========================================================================

  /**
   * Create a consistency checkpoint after generation
   */
  async _createConsistencyCheckpoint(chapter, pathKey, storyEntry, choiceHistory = []) {
    const checkpointKey = `checkpoint_${chapter}_${pathKey}`;

    const checkpoint = {
      chapter,
      pathKey,
      timestamp: new Date().toISOString(),
      accumulatedFacts: [],
      characterStates: {},
      narrativeThreads: [],
      decisionHistory: [],
    };

    // Gather all facts from this and previous chapters
    for (let ch = 2; ch <= chapter; ch++) {
      for (let sub = 1; sub <= 3; sub++) {
        const caseNum = formatCaseNumber(ch, sub);
        // Use cumulative branch keys for each chapter so we read the correct historical branch.
        const chPathKey = this._getPathKeyForChapter(ch, choiceHistory);
        const entry = this.getGeneratedEntry(caseNum, chPathKey);
        if (entry?.consistencyFacts) {
          checkpoint.accumulatedFacts.push(...entry.consistencyFacts);
        }
      }
    }

    // Deduplicate facts
    checkpoint.accumulatedFacts = [...new Set(checkpoint.accumulatedFacts)];

    // Track character relationship states based on path personality
    if (this.pathPersonality) {
      checkpoint.characterStates = {
        jackPersonality: this.pathPersonality.narrativeStyle,
        riskTolerance: this.pathPersonality.riskTolerance,
        scores: this.pathPersonality.scores,
      };
    }

    this.consistencyCheckpoints.set(checkpointKey, checkpoint);

    // Validate checkpoint for anomalies every 3 chapters
    if (chapter % 3 === 0) {
      await this._validateCheckpoint(checkpoint);
    }

    return checkpoint;
  }

  /**
   * Validate a consistency checkpoint for anomalies
   */
  async _validateCheckpoint(checkpoint) {
    const issues = [];

    // Check for contradictory facts
    const factText = checkpoint.accumulatedFacts.join(' ').toLowerCase();

    // Avoid hardcoding noir-era timeline assertions here. Canon is enforced via
    // ABSOLUTE_FACTS + CONSISTENCY_RULES in the prompt and by downstream validators.

    // Character state contradictions
    if (checkpoint.characterStates.jackPersonality) {
      const isMethodical = checkpoint.characterStates.riskTolerance === 'low';
      const hasRecklessAction = /jack\s+(charged|rushed|stormed)/i.test(factText);
      if (isMethodical && hasRecklessAction) {
        issues.push('Character behavior contradiction: Methodical Jack acting recklessly');
      }
    }

    if (issues.length > 0) {
      console.warn('[StoryGenerationService] Checkpoint validation issues:', issues);
      // Store issues for potential auto-correction in future generations
      checkpoint.validationIssues = issues;
    }

    return issues;
  }

  // ==========================================================================
  // PATH PERSONALITY ANALYSIS - Ensures narrative coherence across player choices
  // ==========================================================================

  /**
   * Analyze player's choice history to determine their "path personality"
   * This ensures Jack's behavior remains consistent with player's decision patterns
   */
  _analyzePathPersonality(choiceHistory) {
    if (!choiceHistory || choiceHistory.length === 0) {
      return PATH_PERSONALITY_TRAITS.BALANCED;
    }

    let aggressiveScore = 0;
    let methodicalScore = 0;

    // Analyze each choice and weight recent choices more heavily
    choiceHistory.forEach((choice, index) => {
      const weight = 1 + (index / choiceHistory.length); // Recent choices weighted more
      const consequence = DECISION_CONSEQUENCES[choice.caseNumber]?.[choice.optionKey];

      if (consequence?.characterImpact) {
        aggressiveScore += (consequence.characterImpact.aggression || 0) * weight;
        methodicalScore += (consequence.characterImpact.thoroughness || 0) * weight;
      } else {
        // Prefer the decision's explicit personalityAlignment when available.
        // This avoids baking in A=methodical/B=aggressive when the narrative frames choices differently.
        let alignment = null;
        try {
          const decisionChapter = this._extractChapterFromCase(choice.caseNumber);
          const decisionPathKey = this._getPathKeyForChapter(decisionChapter, choiceHistory);
          const decisionEntry =
            this.getGeneratedEntry(choice.caseNumber, decisionPathKey) ||
            getStoryEntry(choice.caseNumber, 'ROOT');

          // Handle both legacy (decision) and new (pathDecisions) formats
          // Use player's actual branching path for path-specific decision lookup
          const decisionData = this._getPathDecisionData(decisionEntry, choice.caseNumber, this.currentBranchingChoices || []);
          const opt =
            decisionData?.options?.find((o) => o?.key === choice.optionKey) ||
            (choice.optionKey === 'A' ? decisionData?.optionA : decisionData?.optionB) ||
            null;

          alignment = opt?.personalityAlignment || null;
        } catch (error) {
          console.warn('[StoryGenerationService] Failed to get personality alignment:', error.message);
          alignment = null;
        }

        if (alignment === 'methodical') {
          methodicalScore += 6 * weight;
        } else if (alignment === 'aggressive') {
          aggressiveScore += 6 * weight;
        } else {
          // Fallback scoring: A tends to be "methodical/evidence-first", B tends to be "aggressive/instinct-first".
          if (choice.optionKey === 'A') {
            methodicalScore += 5 * weight;
          } else if (choice.optionKey === 'B') {
            aggressiveScore += 5 * weight;
          }
        }
      }
    });

    // Determine dominant personality
    const diff = aggressiveScore - methodicalScore;
    if (diff > 15) {
      return { ...PATH_PERSONALITY_TRAITS.AGGRESSIVE, scores: { aggressive: aggressiveScore, methodical: methodicalScore } };
    } else if (diff < -15) {
      return { ...PATH_PERSONALITY_TRAITS.METHODICAL, scores: { aggressive: aggressiveScore, methodical: methodicalScore } };
    }
    return { ...PATH_PERSONALITY_TRAITS.BALANCED, scores: { aggressive: aggressiveScore, methodical: methodicalScore } };
  }

  /**
   * Build cumulative decision consequences for context
   */
  _buildDecisionConsequences(choiceHistory) {
    const consequences = {
      immediate: [],
      ongoing: [],
      characterImpacts: { trust: 0, aggression: 0, thoroughness: 0 },
    };

    if (!choiceHistory) return consequences;

    choiceHistory.forEach(choice => {
      const conseq = DECISION_CONSEQUENCES[choice.caseNumber]?.[choice.optionKey];
      if (conseq) {
        consequences.immediate.push(`Chapter ${this._extractChapterFromCase(choice.caseNumber)}: ${conseq.immediate}`);
        consequences.ongoing.push(...conseq.ongoing);
        if (conseq.characterImpact) {
          Object.keys(conseq.characterImpact).forEach(key => {
            consequences.characterImpacts[key] += conseq.characterImpact[key];
          });
        }
      }
    });

    return consequences;
  }

  /**
   * Extract and track narrative threads that must be maintained
   * Uses LLM-generated threads when available, with regex fallback for legacy content
   */
  _extractNarrativeThreads(chapters) {
    const threads = [];
    const seenDescriptions = new Set(); // Prevent duplicate active threads in legacy mode

    // For structured threads, track latest status per normalized key so resolved threads
    // cannot "reappear" from earlier chapters (zombie thread bug).
    const latestByKey = new Map(); // key -> { thread, chapter, subchapter }

    // Track normalized IDs of threads that have been resolved/failed.
    // This prevents regex fallback from resurrecting them as "zombie threads".
    const resolvedThreadIds = new Set();

    // First priority: Use LLM-generated structured threads
    chapters.forEach(ch => {
      if (ch.narrativeThreads && Array.isArray(ch.narrativeThreads)) {
        ch.narrativeThreads.forEach(thread => {
          const type = thread?.type;
          const desc = thread?.description;
          const status = thread?.status;
          if (!type || !desc) return;

          const key = `${type}:${desc}`.toLowerCase();

          // Track resolved/failed threads to prevent regex resurrection
          if (status === 'resolved' || status === 'failed') {
            const normalizedId = this._normalizeThreadId(thread);
            if (normalizedId) {
              resolvedThreadIds.add(normalizedId);
            }
          }

          const candidate = {
            type,
            chapter: ch.chapter,
            subchapter: ch.subchapter,
            description: desc,
            characters: thread.characters || [],
            status: status || 'active',
            urgency: thread.urgency,
            deadline: thread.deadline,
            dueChapter: thread.dueChapter,
            resolvedChapter: thread.resolvedChapter,
            source: 'llm',
          };

          const existing = latestByKey.get(key);
          const isNewer = !existing ||
            (candidate.chapter > existing.chapter) ||
            (candidate.chapter === existing.chapter && candidate.subchapter > existing.subchapter);
          if (isNewer) {
            latestByKey.set(key, { ...candidate, chapter: candidate.chapter, subchapter: candidate.subchapter });
          }
        });
      }
    });

    // Materialize only active structured threads (latest status wins).
    // If a thread was resolved/failed later, it won't show up here.
    for (const [, t] of latestByKey.entries()) {
      if (t.status === 'active') {
        threads.push(t);
      }
    }

    // Fallback: Regex extraction for chapters without LLM threads (legacy content)
    const threadPatterns = [
      { pattern: /agreed to meet|promised to|will (meet|call|contact)/i, type: 'appointment' },
      { pattern: /discovered|revealed|learned that/i, type: 'revelation' },
      { pattern: /suspects?|investigating|following/i, type: 'investigation' },
      { pattern: /trust|betray|alliance|enemy/i, type: 'relationship' },
      { pattern: /wounded|injured|hurt|sick/i, type: 'physical_state' },
      { pattern: /swore|vowed|will make.*pay|threatened/i, type: 'threat' },
      { pattern: /promised|gave.*word|committed to/i, type: 'promise' },
    ];

    chapters.forEach(ch => {
      // Skip if we already have LLM threads for this chapter
      if (ch.narrativeThreads && ch.narrativeThreads.length > 0) return;
      if (!ch.narrative) return;

      threadPatterns.forEach(({ pattern, type }) => {
        const regex = new RegExp(`.{0,50}${pattern.source}.{0,50}`, 'gi');
        const matchIterator = ch.narrative.matchAll(regex);

        for (const match of matchIterator) {
          let excerpt = match[0].trim();
          const startIdx = match.index;

          // Fix: Trim to word boundaries to avoid "oria Blackwell" instead of "Victoria Blackwell"
          // Check if we started mid-word (character before match is alphanumeric)
          if (startIdx > 0 && /\w/.test(ch.narrative[startIdx - 1])) {
            const firstSpace = excerpt.indexOf(' ');
            if (firstSpace > 0 && firstSpace < 20) {
              excerpt = excerpt.slice(firstSpace + 1).trim();
            }
          }

          // Check if we ended mid-word (character after match is alphanumeric)
          const endIdx = startIdx + match[0].length;
          if (endIdx < ch.narrative.length && /\w/.test(ch.narrative[endIdx])) {
            const lastSpace = excerpt.lastIndexOf(' ');
            if (lastSpace > excerpt.length - 20 && lastSpace > 0) {
              excerpt = excerpt.slice(0, lastSpace).trim();
            }
          }

          const key = `${type}:${excerpt}`.toLowerCase();

          // Build candidate to check its normalized ID against resolved threads
          const candidate = { type, description: excerpt };
          const normalizedId = this._normalizeThreadId(candidate);

          // Only add if not a duplicate AND not previously resolved (zombie prevention)
          const isResolved = normalizedId && resolvedThreadIds.has(normalizedId);
          if (!seenDescriptions.has(key) && !isResolved) {
            seenDescriptions.add(key);
            threads.push({
              type,
              chapter: ch.chapter,
              subchapter: ch.subchapter,
              description: excerpt,
              excerpt, // Keep for backwards compatibility
              status: 'active',
              urgency: 'background',
              source: 'regex', // Track that this came from regex fallback
            });
          }
        }
      });
    });

    // Sort by chapter/subchapter and keep most recent threads (last 20)
    threads.sort((a, b) => {
      if (a.chapter !== b.chapter) return a.chapter - b.chapter;
      return a.subchapter - b.subchapter;
    });

    return threads.slice(-20);
  }

  /**
   * Get a formatted summary of active narrative threads for the LLM context
   */
  _formatNarrativeThreadsForContext(threads) {
    if (!threads || threads.length === 0) {
      return 'No active narrative threads to maintain.';
    }

    const groupedByType = {};
    threads.forEach(thread => {
      if (!groupedByType[thread.type]) {
        groupedByType[thread.type] = [];
      }
      groupedByType[thread.type].push(thread);
    });

    const lines = ['## ACTIVE NARRATIVE THREADS (must be addressed or acknowledged)'];

    const typeLabels = {
      appointment: 'SCHEDULED MEETINGS/APPOINTMENTS',
      revelation: 'RECENT DISCOVERIES',
      investigation: 'ONGOING INVESTIGATIONS',
      relationship: 'RELATIONSHIP CHANGES',
      physical_state: 'PHYSICAL CONDITIONS',
      promise: 'PROMISES MADE',
      threat: 'THREATS/WARNINGS',
    };

    for (const [type, typeThreads] of Object.entries(groupedByType)) {
      lines.push(`\n### ${typeLabels[type] || type.toUpperCase()}`);
      typeThreads.forEach(t => {
        const chapterInfo = `(Ch ${t.chapter}.${t.subchapter})`;
        const chars = t.characters?.length > 0 ? ` [${t.characters.join(', ')}]` : '';
        lines.push(`- ${t.description}${chars} ${chapterInfo}`);
      });
    }

    return lines.join('\n');
  }

  /**
   * Initialize the service and load any previously generated content
   * Also resets in-memory state that shouldn't persist across sessions
   */
  async init() {
    this.generatedStory = await loadGeneratedStory();
    this.storyContext = await getStoryContext();

    // Hydrate any persisted dynamic decision consequences back into memory so
    // choice-driven context remains stable across app restarts.
    if (this.storyContext?.decisionConsequencesByKey && typeof this.storyContext.decisionConsequencesByKey === 'object') {
      try {
        for (const [k, consequence] of Object.entries(this.storyContext.decisionConsequencesByKey)) {
          const [caseNumber, optionKey] = String(k).split('_');
          if (!caseNumber || !optionKey) continue;
          if (!DECISION_CONSEQUENCES[caseNumber]) DECISION_CONSEQUENCES[caseNumber] = {};
          if (!DECISION_CONSEQUENCES[caseNumber][optionKey]) {
            DECISION_CONSEQUENCES[caseNumber][optionKey] = consequence;
          }
          this.generatedConsequences.set(`${caseNumber}_${optionKey}`, consequence);
        }
      } catch (e) {
        console.warn('[StoryGenerationService] Failed to hydrate decision consequences from storyContext:', e?.message);
      }
    }

    // Reset thread acknowledgment counts on init to prevent stale data from affecting
    // validation when starting a new session or reloading the app
    this.threadAcknowledgmentCounts.clear();

    // Also clear generation attempts to give fresh retries
    this.generationAttempts.clear();

    return this;
  }

  /**
   * Prune stale in-memory Map entries to prevent memory leaks in long sessions
   * Called periodically during generation to clean up abandoned paths
   *
   * @param {string} currentPathKey - The player's current path (entries matching this are preserved)
   * @param {number} currentChapter - The player's current chapter
   */
  pruneInMemoryMaps(currentPathKey, currentChapter) {
    let prunedCount = 0;

    // Prune generationAttempts: remove entries for chapters far behind current chapter
    for (const [key] of this.generationAttempts) {
      // Keys are like "002A_ABABAB" - extract chapter from first 3 chars
      const chapterNum = parseInt(key.slice(0, 3)) || 0;
      // Remove attempts for chapters more than 2 behind (they won't be retried)
      if (chapterNum < currentChapter - 2) {
        this.generationAttempts.delete(key);
        prunedCount++;
      }
    }

    // Prune threadAcknowledgmentCounts: keep only reasonably recent entries
    // Threads older than 20 entries are likely from abandoned paths
    if (this.threadAcknowledgmentCounts.size > 50) {
      // Take the 30 most recent by keeping entries, delete the rest
      const entries = Array.from(this.threadAcknowledgmentCounts.entries());
      const toRemove = entries.slice(0, entries.length - 30);
      for (const [key] of toRemove) {
        this.threadAcknowledgmentCounts.delete(key);
        prunedCount++;
      }
    }

    // Prune consistencyCheckpoints: keep only checkpoints for recent chapters
    for (const [key] of this.consistencyCheckpoints) {
      // Keys are like "chapter_3_ABABAB"
      const match = key.match(/chapter_(\d+)/);
      if (match) {
        const chapterNum = parseInt(match[1]) || 0;
        // Keep only checkpoints within 3 chapters of current
        if (chapterNum < currentChapter - 3) {
          this.consistencyCheckpoints.delete(key);
          prunedCount++;
        }
      }
    }

    // Prune chapterOutlines: keep only recent outlines
    for (const [key] of this.chapterOutlines) {
      // Keys are like "outline_3_ABABAB"
      const match = key.match(/outline_(\d+)/);
      if (match) {
        const chapterNum = parseInt(match[1]) || 0;
        // Keep only outlines within 2 chapters of current
        if (chapterNum < currentChapter - 2) {
          this.chapterOutlines.delete(key);
          prunedCount++;
        }
      }
    }

    // Prune decisionConsequences: remove entries for old chapters
    for (const [key] of this.decisionConsequences) {
      // Keys are like "decision_2_A" or contain chapter references
      const match = key.match(/(\d+)/);
      if (match) {
        const chapterNum = parseInt(match[1]) || 0;
        if (chapterNum < currentChapter - 3) {
          this.decisionConsequences.delete(key);
          prunedCount++;
        }
      }
    }

    // Prune characterStates: limit to reasonable size (50 entries max)
    if (this.characterStates.size > 50) {
      const entries = Array.from(this.characterStates.entries());
      const toRemove = entries.slice(0, entries.length - 30);
      for (const [key] of toRemove) {
        this.characterStates.delete(key);
        prunedCount++;
      }
    }

    // Prune generatedConsequences: remove old chapter consequences
    for (const [key] of this.generatedConsequences) {
      const match = key.match(/(\d+)/);
      if (match) {
        const chapterNum = parseInt(match[1]) || 0;
        if (chapterNum < currentChapter - 3) {
          this.generatedConsequences.delete(key);
          prunedCount++;
        }
      }
    }

    // Prune stale pendingGenerations: remove any that are older than 5 minutes
    // (they likely failed silently or were abandoned)
    const now = Date.now();
    for (const [key, promise] of this.pendingGenerations) {
      // Check if promise has been resolved/rejected by adding a flag
      if (promise._createdAt && now - promise._createdAt > 5 * 60 * 1000) {
        this.pendingGenerations.delete(key);
        prunedCount++;
        console.log(`[StoryGenerationService] Pruned stale pending generation: ${key}`);
      }
    }

    if (prunedCount > 0) {
      console.log(`[StoryGenerationService] Pruned ${prunedCount} stale in-memory entries`);
    }

    return prunedCount;
  }

  /**
   * Destroy the service and clean up all resources
   * Call this when unmounting or resetting the application
   */
  destroy() {
    console.log('[StoryGenerationService] Destroying service and cleaning up resources...');

    // Clear all Maps
    this.pendingGenerations.clear();
    this.decisionConsequences.clear();
    this.characterStates.clear();
    this.threadAcknowledgmentCounts.clear();
    this.chapterOutlines.clear();
    this.consistencyCheckpoints.clear();
    this.generatedConsequences.clear();
    this.generationAttempts.clear();

    // Clear other state
    this.generatedStory = null;
    this.storyContext = null;
    this.storyArc = null;
    this.indexedFacts = null;
    this.consistencyLog = [];
    this.narrativeThreads = [];
    this.pathPersonality = null;
    this.dynamicPersonalityCache = { choiceHistoryHash: null, personality: null, timestamp: null };
    this.tokenUsage = { totalPromptTokens: 0, totalCachedTokens: 0, totalCompletionTokens: 0, totalTokens: 0, callCount: 0, sessionStart: Date.now() };
    this.isGenerating = false;

    // Clear dynamic clusters
    this._currentDynamicClusters = null;

    // Clear generation concurrency state
    // Reject any waiting generations to prevent hanging promises
    this.generationWaitQueue.forEach(({ reject, key }) => {
      reject(new Error(`Generation ${key} cancelled: service destroyed`));
    });
    this.generationWaitQueue = [];
    this.activeGenerationCount = 0;

    // Clear thread archive
    this.archivedThreads = [];

    console.log('[StoryGenerationService] Cleanup complete');
  }

  /**
   * Check if a specific chapter/subchapter needs generation
   */
  needsGeneration(chapter, subchapter, pathKey) {
    if (chapter <= 1) return false;
    const caseNumber = formatCaseNumber(chapter, subchapter);
    const key = `${caseNumber}_${pathKey}`;
    return !this.generatedStory?.chapters?.[key];
  }

  /**
   * Get generated story entry (or null if not generated)
   * First checks in-memory cache, then falls back to storage
   */
  getGeneratedEntry(caseNumber, pathKey) {
    if (!this.generatedStory?.chapters) return null;
    const key = `${caseNumber}_${pathKey}`;
    return this.generatedStory.chapters[key] || null;
  }

  /**
   * Get generated story entry with async storage fallback
   * Ensures entries are found even if not in memory cache
   */
  async getGeneratedEntryAsync(caseNumber, pathKey) {
    // First try in-memory cache
    const memoryEntry = this.getGeneratedEntry(caseNumber, pathKey);
    if (memoryEntry) return memoryEntry;

    // Fall back to storage
    const { getGeneratedEntry: getFromStorage } = await import('../storage/generatedStoryStorage');
    const storageEntry = await getFromStorage(caseNumber, pathKey);

    // If found in storage, add to memory cache
    if (storageEntry && this.generatedStory?.chapters) {
      const key = `${caseNumber}_${pathKey}`;
      this.generatedStory.chapters[key] = storageEntry;
    }

    return storageEntry;
  }

  // ==========================================================================
  // CONTEXT BUILDING - Full story context for 1M token window
  // ==========================================================================

  /**
   * Build comprehensive story context with FULL story history
   * With 1M token context window, we include ALL previous content without truncation
   * Ensures proper continuation from exactly where the previous subchapter ended
   *
   * @param {number} targetChapter - Chapter to generate
   * @param {number} targetSubchapter - Subchapter to generate
   * @param {string} pathKey - Path key for branching
   * @param {Array} choiceHistory - Chapter-level decision history
   * @param {Array} branchingChoices - Intra-subchapter branching choices for true infinite branching
   */
  async buildStoryContext(targetChapter, targetSubchapter, pathKey, choiceHistory = [], branchingChoices = []) {
    // Ensure service is initialized and has loaded story from storage
    if (!this.generatedStory) {
      console.log('[StoryGenerationService] Service not initialized, loading story from storage...');
      await this.init();
    }

    // Analyze player's path personality for narrative consistency
    // Use dynamic LLM-based classification for richer personality insights
    // Falls back to keyword-based analysis if LLM fails
    let pathPersonality;
    try {
      pathPersonality = await this._classifyPersonalityDynamic(choiceHistory);
    } catch (error) {
      console.warn('[StoryGenerationService] Dynamic personality classification failed, using keyword fallback');
      pathPersonality = this._analyzePathPersonality(choiceHistory);
    }
    this.pathPersonality = pathPersonality;

    // Build cumulative decision consequences
    const decisionConsequences = this._buildDecisionConsequences(choiceHistory);

    const context = {
      foundation: this._buildFoundationContext(),
      previousChapters: [],
      playerChoices: [],
      currentPosition: {
        chapter: targetChapter,
        subchapter: targetSubchapter,
        pathKey,
      },
      establishedFacts: [], // Track facts that must remain consistent
      pathPersonality, // Player's cumulative decision pattern
      decisionConsequences, // Ongoing effects of choices
      narrativeThreads: [], // Active story threads to maintain
    };

    // Branching narrative path formatting helper.
    // Our stored `secondChoice` is expected to be the full key (e.g., "1B-2C").
    // Logging it as `${firstChoice}-${secondChoice}` can produce confusing doubles like "1B-1B-2C".
    const formatBranchingPath = (firstChoice, secondChoice) => {
      const first = String(firstChoice || '').trim();
      const second = String(secondChoice || '').trim();
      if (!first && !second) return null;
      if (first && second && second.startsWith(`${first}-`)) return second;
      return first && second ? `${first}-${second}` : (second || first);
    };

    // Add Chapter 1A content (static) - FULL TEXT
    // Note: Only 1A is static; 1B and 1C are dynamically generated
    const chapter1AEntry = getStoryEntry('001A', 'ROOT');
    if (chapter1AEntry) {
      // Check if we have branching choices for 001A - use REALIZED narrative
      const branchingChoice1A = branchingChoices.find(bc => bc.caseNumber === '001A');
      let narrativeText1A = chapter1AEntry.narrative; // Default to canonical

      if (branchingChoice1A && chapter1AEntry.branchingNarrative) {
        // Build the ACTUAL narrative the player experienced
        narrativeText1A = buildRealizedNarrative(
          chapter1AEntry.branchingNarrative,
          branchingChoice1A.firstChoice,
          branchingChoice1A.secondChoice
        );
        console.log(`[StoryGenerationService] Using realized narrative for 001A: path ${formatBranchingPath(branchingChoice1A.firstChoice, branchingChoice1A.secondChoice)}`);
      }

      context.previousChapters.push({
        chapter: 1,
        subchapter: 1,
        pathKey: 'ROOT',
        title: chapter1AEntry.title || 'Chapter 1.1',
        narrative: narrativeText1A,
        decision: chapter1AEntry.decision || null,
        pathDecisions: chapter1AEntry.pathDecisions || null, // Store path-specific decisions for proper lookup
        chapterSummary: chapter1AEntry.chapterSummary || null,
        branchingPath: branchingChoice1A ? formatBranchingPath(branchingChoice1A.firstChoice, branchingChoice1A.secondChoice) : null,
        isRecent: true, // Mark as recent to include full text
      });
    }

    // Add Chapter 1B and 1C (dynamically generated) - FULL TEXT
    // These are loaded from generated storage just like chapters 2+
    // IMPORTANT: Only include them when generating chapters AFTER Chapter 1.
    // For Chapter 1 generation, current-chapter logic below handles prior subchapters.
    if (targetChapter > 1) {
      for (let sub = 2; sub <= SUBCHAPTERS_PER_CHAPTER; sub++) {
        const caseNum = formatCaseNumber(1, sub);
        const entry = await this.getGeneratedEntryAsync(caseNum, 'ROOT');
        if (entry) {
          // Check if we have branching choices for this case - use REALIZED narrative
          const branchingChoice = branchingChoices.find(bc => bc.caseNumber === caseNum);
          let narrativeText = entry.narrative; // Default to canonical

          if (branchingChoice && entry.branchingNarrative) {
            // Build the ACTUAL narrative the player experienced
            narrativeText = buildRealizedNarrative(
              entry.branchingNarrative,
              branchingChoice.firstChoice,
              branchingChoice.secondChoice
            );
            log.debug('StoryGenerationService', `Using realized narrative for ${caseNum}: path ${formatBranchingPath(branchingChoice.firstChoice, branchingChoice.secondChoice)}`);
          }

          if (narrativeText) {
            context.previousChapters.push({
              chapter: 1,
              subchapter: sub,
              pathKey: 'ROOT',
              title: entry.title || `Chapter 1.${sub}`,
              narrative: narrativeText,
              decision: entry.decision || null,
              pathDecisions: entry.pathDecisions || null, // Store path-specific decisions for proper lookup
              chapterSummary: entry.chapterSummary || null,
              branchingPath: branchingChoice ? formatBranchingPath(branchingChoice.firstChoice, branchingChoice.secondChoice) : null,
              isRecent: true, // Mark as recent to include full text
            });
          }
        } else {
          console.warn(`[StoryGenerationService] Missing chapter 1.${sub} (${caseNum}) - may need to be generated`);
        }
      }
    }

    // Add ALL generated chapters 2 onwards - FULL TEXT, NO TRUNCATION
    // Use async method to ensure we load from storage if not in memory
    // IMPORTANT: Use realized narrative (player's actual path) when branching choices exist
    for (let ch = 2; ch < targetChapter; ch++) {
      const chapterPathKey = this._getPathKeyForChapter(ch, choiceHistory);
      for (let sub = 1; sub <= SUBCHAPTERS_PER_CHAPTER; sub++) {
        const caseNum = formatCaseNumber(ch, sub);
        // Use async method to ensure entries are loaded from storage
        const entry = await this.getGeneratedEntryAsync(caseNum, chapterPathKey);
        if (entry) {
          // Check if we have branching choices for this case - use REALIZED narrative
          const branchingChoice = branchingChoices.find(bc => bc.caseNumber === caseNum);
          let narrativeText = entry.narrative; // Default to canonical

          if (branchingChoice && entry.branchingNarrative) {
            // Build the ACTUAL narrative the player experienced
            narrativeText = buildRealizedNarrative(
              entry.branchingNarrative,
              branchingChoice.firstChoice,
              branchingChoice.secondChoice
            );
            log.debug('StoryGenerationService', `Using realized narrative for ${caseNum}: path ${formatBranchingPath(branchingChoice.firstChoice, branchingChoice.secondChoice)}`);
          }

          if (narrativeText) {
            context.previousChapters.push({
              chapter: ch,
              subchapter: sub,
              pathKey: chapterPathKey,
              title: entry.title || `Chapter ${ch}.${sub}`,
              narrative: narrativeText, // REALIZED narrative from player's actual path
              chapterSummary: entry.chapterSummary || null,
              decision: entry.decision || null,
              pathDecisions: entry.pathDecisions || null, // Store path-specific decisions for proper lookup
              branchingPath: branchingChoice ? formatBranchingPath(branchingChoice.firstChoice, branchingChoice.secondChoice) : null,
              isRecent: true, // Mark all as recent to include full text
            });
          }
        } else {
          console.warn(`[StoryGenerationService] Missing chapter ${ch}.${sub} (${caseNum}) for path ${chapterPathKey}`);
        }
      }
    }

    // Add current chapter's previous subchapters - FULL TEXT
    // IMPORTANT: Use realized narrative for player's actual experience
    // Note: For Chapter 1, 1A is static (use getStoryEntry), 1B onwards are generated
    if (targetSubchapter > 1) {
      for (let sub = 1; sub < targetSubchapter; sub++) {
        const caseNum = formatCaseNumber(targetChapter, sub);

        // For Chapter 1A, use static content (already included above).
        if (targetChapter === 1 && sub === 1) {
          continue;
        }
        const entry = await this.getGeneratedEntryAsync(caseNum, pathKey);

        if (entry) {
          // Check if we have branching choices for this case - use REALIZED narrative
          const branchingChoice = branchingChoices.find(bc => bc.caseNumber === caseNum);
          let narrativeText = entry.narrative; // Default to canonical

          if (branchingChoice && entry.branchingNarrative) {
            // Build the ACTUAL narrative the player experienced
            narrativeText = buildRealizedNarrative(
              entry.branchingNarrative,
              branchingChoice.firstChoice,
              branchingChoice.secondChoice
            );
            log.debug('StoryGenerationService', `Using realized narrative for ${caseNum}: path ${formatBranchingPath(branchingChoice.firstChoice, branchingChoice.secondChoice)}`);
          }

          if (narrativeText) {
            context.previousChapters.push({
              chapter: targetChapter,
              subchapter: sub,
              pathKey,
              title: entry.title || `Chapter ${targetChapter}.${sub}`,
              narrative: narrativeText, // REALIZED narrative from player's actual path
              chapterSummary: entry.chapterSummary || null,
              decision: entry.decision || null,
              pathDecisions: entry.pathDecisions || null, // Store path-specific decisions for proper lookup
              branchingPath: branchingChoice ? formatBranchingPath(branchingChoice.firstChoice, branchingChoice.secondChoice) : null,
              isRecent: true, // Current chapter always recent
            });
          }
        } else {
          console.warn(`[StoryGenerationService] Missing current chapter ${targetChapter}.${sub} (${caseNum})`);
        }
      }
    }

    // Log context size for debugging
    const totalNarrativeChars = context.previousChapters.reduce(
      (sum, ch) => sum + (ch.narrative?.length || 0), 0
    );
    log.debug('StoryGenerationService', `Context built: ${context.previousChapters.length} subchapters, ${totalNarrativeChars} chars`);
    if (context.previousChapters.length === 0) {
      console.warn('[StoryGenerationService] WARNING: No previous chapters found! Story context may be empty.');
    }

    // Add choice history (including title/focus for LLM prompt context)
    context.playerChoices = choiceHistory.map(choice => ({
      chapter: this._extractChapterFromCase(choice.caseNumber),
      optionKey: choice.optionKey,
      optionTitle: choice.optionTitle || null,  // "Go to the wharf and investigate the warehouse"
      optionFocus: choice.optionFocus || null,  // "Prioritizes direct action over caution"
      timestamp: choice.timestamp,
    }));

    // Identify the most recent decision that affects the current chapter (Chapter N decision affects N+1)
    const lastDecision = (() => {
      const last = [...(choiceHistory || [])].reverse().find((c) => {
        const decisionChapter = this._extractChapterFromCase(c?.caseNumber);
        return decisionChapter === targetChapter - 1;
      });
      if (!last) return null;

      const consequence = DECISION_CONSEQUENCES[last.caseNumber]?.[last.optionKey];
      const decisionChapter = this._extractChapterFromCase(last.caseNumber);
      const decisionPathKey = this._getPathKeyForChapter(decisionChapter, choiceHistory);
      const decisionEntry = this.getGeneratedEntry(last.caseNumber, decisionPathKey) || getStoryEntry(last.caseNumber, 'ROOT');
      // Handle both legacy (decision) and new (pathDecisions) formats
      // Use player's actual branching path for path-specific decision lookup
      const decisionData = this._getPathDecisionData(decisionEntry, last.caseNumber, branchingChoices);
      const chosenOption = decisionData?.options?.find((o) => o.key === last.optionKey)
        || (last.optionKey === 'A' ? decisionData?.optionA : decisionData?.optionB)
        || null;
      const otherOption = decisionData?.options?.find((o) => o.key !== last.optionKey)
        || (last.optionKey === 'A' ? decisionData?.optionB : decisionData?.optionA)
        || null;

      // Prefer stored title/focus from choice history (always available after decision),
      // fall back to looking it up from the decision entry
      return {
        caseNumber: last.caseNumber,
        chapter: decisionChapter,
        optionKey: last.optionKey,
        immediate: consequence?.immediate || chosenOption?.focus || last.optionFocus || `Chose option ${last.optionKey}`,
        ongoing: consequence?.ongoing || [],
        chosenTitle: last.optionTitle || chosenOption?.title || null,
        chosenFocus: last.optionFocus || chosenOption?.focus || null,
        chosenStats: chosenOption?.stats || null,
        otherTitle: otherOption?.title || null,
        otherFocus: otherOption?.focus || null,
      };
    })();

    context.lastDecision = lastDecision;

    // Extract established facts from generated content
    context.establishedFacts = this._extractEstablishedFacts(context.previousChapters);

    // IMPORTANT:
    // Persisted storage strips per-entry consistencyFacts to save space.
    // We persist a rolling fact log keyed BY PATH to prevent branch-bleed from background prefetch.
    // Only merge facts whose pathKey is relevant (prefix of current path).
    const persistedFacts = this._getRelevantPersistedConsistencyFacts(pathKey);
    if (persistedFacts.length > 0) {
      context.establishedFacts = [
        ...new Set([...(context.establishedFacts || []), ...persistedFacts]),
      ];
    }

    // Extract active narrative threads that must be maintained
    context.narrativeThreads = this._extractNarrativeThreads(context.previousChapters);

    return context;
  }

  /**
   * Build foundation context from story bible
   */
  _buildFoundationContext() {
    return {
      protagonist: ABSOLUTE_FACTS.protagonist,
      antagonist: ABSOLUTE_FACTS.antagonist,
      setting: ABSOLUTE_FACTS.setting,
    };
  }

  /**
   * Extract key facts from previous chapters for consistency
   */
  _extractEstablishedFacts(chapters) {
    const facts = [];

    // Add base consistency rules
    facts.push(...CONSISTENCY_RULES);

    // Extract facts from generated content
    for (const ch of chapters) {
      if (ch.consistencyFacts) {
        facts.push(...ch.consistencyFacts);
      }
    }

    return [...new Set(facts)]; // Remove duplicates
  }

  /**
   * Extract scene state from the immediately previous subchapter
   * This gives the LLM a precise snapshot of where we are in the story
   */
  _extractSceneState(previousChapters, currentChapter, currentSubchapter) {
    if (!previousChapters || previousChapters.length === 0) {
      return null;
    }

    // Find the immediately previous subchapter
    let prevChapter, prevSubchapter;
    if (currentSubchapter > 1) {
      prevChapter = currentChapter;
      prevSubchapter = currentSubchapter - 1;
    } else {
      prevChapter = currentChapter - 1;
      prevSubchapter = 3;
    }

    const prevEntry = previousChapters.find(
      ch => ch.chapter === prevChapter && ch.subchapter === prevSubchapter
    );

    if (!prevEntry?.narrative) {
      return null;
    }

    const narrative = prevEntry.narrative;

    // Extract the last 2-3 paragraphs for immediate context
    const paragraphs = narrative.split(/\n\n+/).filter(p => p.trim().length > 50);
    const lastParagraphs = paragraphs.slice(-3).join('\n\n');

    // Extract the very last sentence for exact continuation point
    const sentences = narrative.match(/[^.!?]+[.!?]+/g) || [];
    const lastSentence = sentences.slice(-1)[0]?.trim() || '';

    // Try to infer current location from narrative
    // Fix: Collect ALL matches from ALL patterns, then take the one that appears LAST in the narrative
    const locationPatterns = [
      // Primary pattern: preposition/verb phrases before location
      /(?:at|in|inside|outside|near|entered|stepped into|arrived at|back to|returned to|reached|walked into|drove to|pulled up to|stood (?:in|outside|at)|was (?:in|at)|found himself (?:in|at)|doors of|through the doors of)\s+(?:the\s+)?([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*(?:'s)?(?:\s+(?:Bar|Office|Diner|House|Building|Station|Prison|Warehouse|Wharf|Docks|Penthouse|Estate|Alley|Street|Exchange|Cafe|Club|Hotel|Motel|Shop|Store|Market|Tavern|Pub|Restaurant|Garage|Lot|Plaza|Tower|Complex|Facility))?)/g,
      // Fallback: Any capitalized name followed by a location-type word
      /(?:the\s+)?([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*(?:'s)?)\s+(?:Bar|Office|Diner|Warehouse|Wharf|Penthouse|Estate|Cafe|Club|Tavern|Pub|Restaurant)/gi,
      // Known locations
      /Murphy's Bar/gi,
      /Ashport Archive/gi,
      /Sentinel Library/gi,
      /Brineglass Viaduct/gi,
      /Victoria's building/gi,
      /Harmon Exchange/gi,
      /(?:the\s+)?(?:old\s+)?warehouse/gi,
    ];

    let currentLocation = 'Unknown location';
    let latestPosition = -1;

    // Collect matches from ALL patterns and find the one that appears LAST in the narrative
    for (const pattern of locationPatterns) {
      const matches = [...narrative.matchAll(pattern)];
      for (const match of matches) {
        if (match.index > latestPosition) {
          latestPosition = match.index;
          currentLocation = match[1] || match[0];
        }
      }
    }

    // Try to infer time of day
    const timePatterns = {
      morning: /\b(morning|dawn|sunrise|breakfast|early light)\b/i,
      afternoon: /\b(afternoon|midday|noon|lunch)\b/i,
      evening: /\b(evening|dusk|sunset|dinner)\b/i,
      night: /\b(night|midnight|dark|neon|streetlights|late)\b/i,
    };

    let timeOfDay = 'night'; // Default thriller atmosphere
    for (const [time, pattern] of Object.entries(timePatterns)) {
      if (pattern.test(narrative)) {
        timeOfDay = time;
      }
    }

    // Extract characters present in the final scene
    // Only canonical characters are listed - LLM-generated characters detected dynamically
    const canonicalCharacters = ['Jack', 'Victoria', 'Blackwell'];
    const presentCharacters = canonicalCharacters.filter(name =>
      new RegExp(`\\b${name}\\b`, 'i').test(lastParagraphs)
    );

    // Infer Jack's emotional/physical state
    const emotionPatterns = {
      angry: /\b(anger|furious|rage|fist|clenched|seething)\b/i,
      tired: /\b(tired|exhausted|weary|drained|heavy)\b/i,
      tense: /\b(tense|nervous|anxious|tight|coiled)\b/i,
      determined: /\b(determined|resolved|focused|steel)\b/i,
      suspicious: /\b(suspicious|wary|distrustful|watching)\b/i,
      shocked: /\b(shocked|stunned|reeling|disbelief)\b/i,
    };

    const jackState = [];
    for (const [emotion, pattern] of Object.entries(emotionPatterns)) {
      if (pattern.test(lastParagraphs)) {
        jackState.push(emotion);
      }
    }

    return {
      location: currentLocation,
      timeOfDay,
      storyDay: prevChapter, // Story day = chapter number
      presentCharacters,
      jackEmotionalState: jackState.length > 0 ? jackState : ['focused'],
      lastParagraphs,
      lastSentence,
      previousTitle: prevEntry.title,
    };
  }

  /**
   * Track what each character knows - prevents information leaks
   * NOTE: Only Jack and Victoria are canonical - other characters are LLM-generated
   */
  _buildCharacterKnowledgeTracker(previousChapters) {
    const revealChapter = REVEAL_TIMING?.underMap?.firstUndeniable?.chapter || 1;
    const revealSubchapter = REVEAL_TIMING?.underMap?.firstUndeniable?.subchapter || DECISION_SUBCHAPTER;
    const revealLabel = REVEAL_TIMING?.underMap?.firstUndeniable?.label || `${revealChapter}${formatSubchapterLabel(revealSubchapter)}`;
    const knowledge = {
      jack: {
        knows: [],
        suspects: [],
        doesNotKnow: [
          `What the Under-Map truly is (first undeniable reveal at end of ${revealLabel})`,
          'Victoria Blackwell\'s full agenda and constraints',
        ],
      },
      victoria: { knows: ['Far more about the Under-Map than Jack', 'Jack\'s likely routes and choices'], suspects: [] },
    };

    // Scan narratives for revelation patterns
    const revelationPatterns = [
      { pattern: /Jack (?:learned|discovered|realized|found out|understood) (?:that )?(.+?)[.!]/gi, target: 'jack', type: 'knows' },
      { pattern: /Jack (?:suspected|wondered if|began to think|considered) (?:that )?(.+?)[.!]/gi, target: 'jack', type: 'suspects' },
      { pattern: /Victoria (?:revealed|showed|told|exposed) (?:that )?(.+?)[.!]/gi, target: 'jack', type: 'knows' },
      // Generic pattern for any character revealing something to Jack
      { pattern: /(?:told Jack|revealed to Jack|confessed to Jack|admitted to Jack) (?:that )?(.+?)[.!]/gi, target: 'jack', type: 'knows' },
    ];

    for (const ch of previousChapters) {
      if (!ch.narrative) continue;

      for (const { pattern, target, type } of revelationPatterns) {
        const matches = [...ch.narrative.matchAll(pattern)];
        for (const match of matches) {
          if (match[1] && match[1].length < 200) {
            knowledge[target][type].push(`Ch${ch.chapter}.${ch.subchapter}: ${match[1].trim()}`);
          }
        }
      }
    }

    // Deduplicate and limit
    for (const char of Object.keys(knowledge)) {
      knowledge[char].knows = [...new Set(knowledge[char].knows)].slice(-20);
      knowledge[char].suspects = [...new Set(knowledge[char].suspects)].slice(-10);
    }

    return knowledge;
  }

  /**
   * Track evidence and items Jack has collected
   */
  _extractEvidenceInventory(previousChapters) {
    const evidence = [];
    const evidencePatterns = [
      /Jack (?:took|grabbed|pocketed|kept|collected|received|found) (?:the |a )?(.+?(?:dead\s+letter|letter|envelope|photo|document|file|key|card|note|paper|folder|token|map|printout))/gi,
      /(?:handed|gave|passed) Jack (?:the |a )?(.+?(?:dead\s+letter|letter|envelope|photo|document|file|key|card|note|paper|folder|token|map|printout))/gi,
      /dead letter/gi,
      /river-?glass/gi,
      /\bglyph\b/gi,
    ];

    for (const ch of previousChapters) {
      if (!ch.narrative) continue;

      for (const pattern of evidencePatterns) {
        const matches = [...ch.narrative.matchAll(pattern)];
        for (const match of matches) {
          const item = match[1] || match[0];
          if (item && item.length < 100) {
            evidence.push({
              item: item.trim(),
              foundIn: `Chapter ${ch.chapter}.${ch.subchapter}`,
            });
          }
        }
      }
    }

    // Deduplicate by item name
    const seen = new Set();
    return evidence.filter(e => {
      const key = e.item.toLowerCase();
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    }).slice(-15);
  }

  /**
   * Extract character dialogue history for voice consistency across chapters.
   * Per Gemini 3 best practices: track recent dialogue patterns per character
   * to maintain consistent voice across the 12-chapter arc.
   * NOTE: Only Victoria Blackwell is tracked - she's the only canonical character besides Jack.
   * Other characters are LLM-generated and don't need consistent voice tracking.
   * @param {Array} previousChapters - Previous chapter entries
   * @returns {Object} - Dialogue history per character
   */
  _extractCharacterDialogueHistory(previousChapters) {
    const characterDialogue = {
      'Victoria Blackwell': { lines: [], patterns: [], count: 0 },
    };

    // Patterns to identify Victoria speaking
    const speakerPatterns = [
      { name: 'Victoria Blackwell', patterns: [/(?:Victoria|Blackwell)\s+said/gi, /"[^"]+"\s+Victoria/gi, /"[^"]+"\s+Blackwell/gi] },
    ];

    // Extract dialogue from each chapter
    for (const ch of previousChapters) {
      if (!ch.narrative) continue;

      // Extract all dialogue (text in quotes)
      const dialogueMatches = ch.narrative.matchAll(/"([^"]+)"/g);

      for (const match of dialogueMatches) {
        const line = match[0];
        const lineContent = match[1];
        const lineIndex = match.index;

        // Determine speaker by looking at context around the quote
        const contextStart = Math.max(0, lineIndex - 100);
        const contextEnd = Math.min(ch.narrative.length, lineIndex + line.length + 100);
        const context = ch.narrative.slice(contextStart, contextEnd);

        for (const { name, patterns } of speakerPatterns) {
          const isThisSpeaker = patterns.some(p => p.test(context));
          if (isThisSpeaker && lineContent.length > 10 && lineContent.length < 200) {
            characterDialogue[name].lines.push({
              line: lineContent,
              chapter: ch.chapter,
              subchapter: ch.subchapter,
            });
            characterDialogue[name].count++;
            break;
          }
        }
      }
    }

    // Extract speech patterns for Victoria
    const victoriaData = characterDialogue['Victoria Blackwell'];
    if (victoriaData.lines.length >= 3) {
      const allLines = victoriaData.lines.map(l => l.line).join(' ');

      // Victoria patterns: cryptic, rule-bound
      if (/rule|must|cannot|boundary/i.test(allLines)) {
        victoriaData.patterns.push('References rules and boundaries');
      }
      if (/pattern|map|route|path/i.test(allLines)) {
        victoriaData.patterns.push('Uses mapping/pattern metaphors');
      }

      // Keep only last 5 lines (most recent)
      victoriaData.lines = victoriaData.lines.slice(-5);
    }

    return characterDialogue;
  }

  /**
   * Build character dialogue history section for the prompt
   * @param {Object} dialogueHistory - Result from _extractCharacterDialogueHistory
   * @returns {string} - Formatted section for prompt
   */
  _buildDialogueHistorySection(dialogueHistory) {
    if (!dialogueHistory) return '';

    let section = `\n## CHARACTER VOICE HISTORY\n`;
    section += `**Maintain consistent dialogue patterns for each character:**\n\n`;

    for (const [name, data] of Object.entries(dialogueHistory)) {
      if (data.lines.length === 0) continue;

      section += `### ${name}\n`;

      // Speech patterns
      if (data.patterns.length > 0) {
        section += `**Patterns:** ${data.patterns.join('; ')}\n`;
      }

      // Recent lines
      section += `**Recent dialogue:**\n`;
      data.lines.forEach(l => {
        section += `- Ch${l.chapter}: "${l.line.slice(0, 100)}${l.line.length > 100 ? '...' : ''}"\n`;
      });
      section += `\n`;
    }

    section += `>>> Maintain each character's established voice patterns <<<\n`;

    return section;
  }

  /**
   * Build scene state section for the prompt
   */
  _buildSceneStateSection(context, chapter, subchapter) {
    const sceneState = this._extractSceneState(
      context.previousChapters,
      chapter,
      subchapter
    );

    if (!sceneState) {
      return '';
    }

    let section = `## CURRENT SCENE STATE (Your starting point)\n\n`;
    section += `**STORY DAY:** Day ${sceneState.storyDay} of 12\n`;
    section += `**TIME:** ${sceneState.timeOfDay}\n`;
    section += `**LOCATION:** ${sceneState.location}\n`;
    section += `**JACK'S STATE:** ${sceneState.jackEmotionalState.join(', ')}\n`;

    if (sceneState.presentCharacters.length > 0) {
      section += `**CHARACTERS PRESENT:** ${sceneState.presentCharacters.join(', ')}\n`;
    }

    section += `\n### THE SCENE YOU ARE CONTINUING FROM:\n`;
    section += `Previous subchapter: "${sceneState.previousTitle}"\n\n`;
    section += `**LAST PARAGRAPHS:**\n${sceneState.lastParagraphs}\n\n`;
    section += `**EXACT LAST SENTENCE:**\n"${sceneState.lastSentence}"\n\n`;
    section += `>>> YOUR NARRATIVE MUST PICK UP IMMEDIATELY AFTER THIS SENTENCE <<<\n`;
    section += `>>> DO NOT REPEAT OR REPHRASE THIS ENDING - CONTINUE FROM IT <<<\n`;

    return section;
  }

  /**
   * Get the thought signature from the previous subchapter for reasoning continuity.
   * Per Gemini 3 docs: thought signatures maintain reasoning chain across multi-turn conversations.
   * @param {number} chapter - Current chapter
   * @param {number} subchapter - Current subchapter
   * @param {string} pathKey - Current path key
   * @returns {string|null} - The previous thought signature, or null if not available
   */
  _getPreviousThoughtSignature(chapter, subchapter, pathKey) {
    if (!this.generatedStory?.chapters) return null;

    // Determine the previous subchapter key
    let prevChapter = chapter;
    let prevSubchapter = subchapter - 1;

    if (prevSubchapter < 1) {
      // Go to previous chapter's last subchapter (typically 3)
      prevChapter = chapter - 1;
      prevSubchapter = 3;
    }

    if (prevChapter < 1) return null; // No previous for first subchapter

    // Find the matching entry from generated story
    const entries = Object.values(this.generatedStory.chapters);

    // For same chapter, use same pathKey; for previous chapter, derive from pathKey
    const targetKey = prevChapter === chapter
      ? pathKey
      : pathKey.split('-').slice(0, -1).join('-') || 'ROOT'; // Go up one branch level

    // Find entry matching chapter, subchapter, and closest path
    const matchingEntry = entries.find(e =>
      e.chapter === prevChapter &&
      e.subchapter === prevSubchapter &&
      (e.pathKey === targetKey || e.pathKey === 'ROOT' || targetKey === 'ROOT')
    );

    if (matchingEntry?.thoughtSignature) {
      log.debug('StoryGenerationService', `🧠 Found thought signature from ${prevChapter}.${prevSubchapter}`);
      return matchingEntry.thoughtSignature;
    }

    return null;
  }

  /**
   * Build character knowledge section
   */
  _buildKnowledgeSection(context) {
    const knowledge = this._buildCharacterKnowledgeTracker(context.previousChapters);
    const evidence = this._extractEvidenceInventory(context.previousChapters);

    let section = `## CHARACTER KNOWLEDGE STATE\n\n`;

    section += `### WHAT JACK KNOWS:\n`;
    if (knowledge.jack.knows.length > 0) {
      knowledge.jack.knows.slice(-15).forEach(k => {
        section += `- ${k}\n`;
      });
    } else {
      section += `- Just beginning investigation\n`;
    }

    section += `\n### WHAT JACK SUSPECTS (but hasn't confirmed):\n`;
    if (knowledge.jack.suspects.length > 0) {
      knowledge.jack.suspects.slice(-10).forEach(k => {
        section += `- ${k}\n`;
      });
    } else {
      section += `- None yet\n`;
    }

    section += `\n### WHAT JACK DOES NOT YET KNOW (do not reveal prematurely):\n`;
    knowledge.jack.doesNotKnow.forEach(k => {
      section += `- ${k}\n`;
    });

    if (evidence.length > 0) {
      section += `\n### EVIDENCE IN JACK'S POSSESSION:\n`;
      evidence.forEach(e => {
        section += `- ${e.item} (found in ${e.foundIn})\n`;
      });
    }

    return section;
  }

  // ==========================================================================
  // PROMPT BUILDING - Structured prompts with grounding
  // ==========================================================================

  /**
   * Build extended style examples for cache (wrapper for buildExtendedStyleExamples)
   */
  _buildExtendedStyleExamplesForCache() {
    try {
      const examples = buildExtendedStyleExamples();
      // Verify content was actually built
      if (!examples || examples.length < 1000) {
        console.error('[StoryGenerationService] ⚠️ Extended style examples suspiciously short or empty!', {
          length: examples?.length || 0,
          expected: '5000+ chars',
        });
      } else {
        console.log(`[StoryGenerationService] ✅ Extended examples built: ${examples.length} chars`);
      }
      return examples;
    } catch (e) {
      console.error('[StoryGenerationService] ❌ FAILED to build extended style examples:', e.message);
      console.error('[StoryGenerationService] Stack:', e.stack);
      return '';
    }
  }

  /**
   * Build static content for caching (Story Bible, Characters, Craft Techniques, etc.)
   * This content doesn't change across requests and is perfect for caching.
   */
  _buildStaticCacheContent() {
    const parts = [];

    // Part 1: Story Bible Grounding (STATIC)
    // Avoid duplicating writing-style rules in cache: style lives in <style_examples>.
    const groundingSection = this._buildGroundingSection(null, { includeStyle: false });
    parts.push('<story_bible>');
    parts.push(groundingSection);
    parts.push('</story_bible>');
    console.log(`[Cache] Grounding section: ${groundingSection.length} chars`);

    // Part 2: Character Reference (STATIC)
    const characterSection = this._buildCharacterSection();
    parts.push('<character_reference>');
    parts.push(characterSection);
    parts.push('</character_reference>');
    console.log(`[Cache] Character section: ${characterSection.length} chars`);

    // Part 3: Craft Techniques (STATIC)
    const craftSection = this._buildCraftTechniquesSection();
    parts.push('<craft_techniques>');
    parts.push(craftSection);
    parts.push('</craft_techniques>');
    console.log(`[Cache] Craft techniques: ${craftSection.length} chars`);

    // Part 4: Writing Style Examples (STATIC)
    const extendedExamples = this._buildExtendedStyleExamplesForCache();
    console.log(`[Cache] Extended examples: ${extendedExamples.length} chars`);

    const styleSection = `## WRITING STYLE - Voice DNA Examples

Voice: ${WRITING_STYLE.voice.perspective}, ${WRITING_STYLE.voice.tense}
Tone: ${WRITING_STYLE.voice.tone}

Influences:
${WRITING_STYLE.influences.map(i => `- ${i}`).join('\n')}

### Forbidden Patterns (NEVER use):
${WRITING_STYLE.absolutelyForbidden.map(f => `- ${f}`).join('\n')}

### Required Elements:
${WRITING_STYLE.mustInclude.map(r => `- ${r}`).join('\n')}

${STYLE_EXAMPLES}

${extendedExamples}
`;
    parts.push('<style_examples>');
    parts.push(styleSection);
    parts.push('</style_examples>');
    console.log(`[Cache] Style section total: ${styleSection.length} chars`);

    // NOTE: Consistency rules NOT included in static cache - they are in _buildDynamicPrompt
    // so that thread data can be updated dynamically per request

    const fullContent = parts.join('\n\n');
    console.log(`[Cache] TOTAL static content: ${fullContent.length} chars (~${Math.round(fullContent.length / 4)} tokens est.)`);

    return fullContent;
  }

  /**
   * Get or create cache for static content
   */
  async _ensureStaticCache() {
    const cacheKey = `story_static_v${this.staticCacheVersion}`;

    // Check if cache exists
    const existing = await llmService.getCache(cacheKey);
    if (existing) {
      this.staticCacheKey = cacheKey;
      console.log(`[StoryGenerationService] ♻️ Using existing static cache: ${cacheKey}`);
      return cacheKey;
    }

    // Create new cache
    console.log(`[StoryGenerationService] 🔧 Creating static content cache...`);

    const staticContent = this._buildStaticCacheContent();

    await llmService.createCache({
      key: cacheKey,
      model: 'gemini-3-flash-preview',
      systemInstruction: buildMasterSystemPrompt(),
      content: staticContent,
      ttl: '7200s', // 2 hours (story sessions typically < 2 hours)
      metadata: {
        version: this.staticCacheVersion,
        created: new Date().toISOString(),
        type: 'story_generation_static',
      },
    });

    this.staticCacheKey = cacheKey;
    console.log(`[StoryGenerationService] ✅ Static cache created: ${cacheKey}`);

    return cacheKey;
  }

  /**
   * Get or create a chapter-start cache.
   * Includes the full static cache content PLUS the story-so-far up to the end of the previous chapter.
   *
   * This reduces per-subchapter prompt size by moving the large shared prefix into an explicit cache.
   */
  async _ensureChapterStartCache(chapter, effectivePathKey, choiceHistory, context) {
    // Hash only choices that occurred BEFORE this chapter; the chapter-start prefix should not depend
    // on decisions made inside the current chapter.
    const priorChoices = Array.isArray(choiceHistory)
      ? choiceHistory.filter((c) => {
          const ch = this._extractChapterFromCase(c?.caseNumber);
          return Number.isFinite(ch) ? ch < chapter : true;
        })
      : [];
    const priorChoicesHash = this._hashChoiceHistoryForCache(priorChoices);

    // Use a logical key to avoid collisions; store the actual cache key separately.
    const logicalKey = `chStart:${chapter}:path:${effectivePathKey}:choices:${priorChoicesHash}:sv${this.staticCacheVersion}:v${this.chapterStartCacheVersion}`;
    const existingKey = this.chapterStartCacheKeys.get(logicalKey);
    if (existingKey) {
      const existing = await llmService.getCache(existingKey);
      if (existing) return existingKey;
      this.chapterStartCacheKeys.delete(logicalKey);
    }

    const safePath = String(effectivePathKey || 'ZZ').replace(/[^A-Za-z0-9_-]/g, '').slice(0, 24) || 'ZZ';
    const cacheKey = `story_chStart_c${chapter}_${safePath}_sv${this.staticCacheVersion}_cv${this.chapterStartCacheVersion}_${priorChoicesHash}`;

    const existing = await llmService.getCache(cacheKey);
    if (existing) {
      this.chapterStartCacheKeys.set(logicalKey, cacheKey);
      console.log(`[StoryGenerationService] ♻️ Chapter-start cache HIT for Chapter ${chapter} (path: ${effectivePathKey})`);
      return cacheKey;
    }

    console.log(`[StoryGenerationService] 🔧 Creating chapter-start cache for Chapter ${chapter}...`);

    // Build static content (same payload as the normal static cache)
    const staticContent = this._buildStaticCacheContent();

    // Build story history up to end of previous chapter.
    const storyUpToPrevChapter = this._buildStorySummarySection(context, { maxChapter: chapter - 1 });

    // Chapter arc + outline are stable across A/B/C and help reduce repeated tokens.
    const chapterArc = context?.storyArc?.chapterArcs?.find((c) => c.chapter === chapter) || null;
    const chapterOutline = context?.chapterOutline || null;
    const arcAndOutline = `## CHAPTER GUIDANCE (Cached for this chapter)
${chapterArc ? `### Story Arc (Chapter ${chapter})
- Phase: ${chapterArc.phase || 'UNKNOWN'}
- Focus: ${chapterArc.primaryFocus || 'Unknown'}
${chapterArc.keyRevelation ? `- Key revelation: ${chapterArc.keyRevelation}` : ''}
${chapterArc.endingHook ? `- Ending hook: ${chapterArc.endingHook}` : ''}` : '### Story Arc\n- (Not available)'}

${chapterOutline ? `### Chapter Outline
Opening mood: ${chapterOutline.openingMood || 'Unknown'}
${Array.isArray(chapterOutline.mustReference) && chapterOutline.mustReference.length ? `Must reference:\n${chapterOutline.mustReference.slice(0, 8).map((x) => `- ${x}`).join('\n')}` : ''}` : '### Chapter Outline\n- (Not available)'}
`;

    const chapterCacheContent = [
      staticContent,
      '<chapter_start_story_context>',
      storyUpToPrevChapter,
      '</chapter_start_story_context>',
      '<chapter_guidance>',
      arcAndOutline,
      '</chapter_guidance>',
    ].join('\n\n');

    await llmService.createCache({
      key: cacheKey,
      model: 'gemini-3-flash-preview',
      systemInstruction: buildMasterSystemPrompt(),
      content: chapterCacheContent,
      ttl: '7200s',
      metadata: {
        version: this.chapterStartCacheVersion,
        staticVersion: this.staticCacheVersion,
        chapter,
        pathKey: effectivePathKey,
        priorChoicesHash,
        created: new Date().toISOString(),
        type: 'story_generation_chapter_start',
      },
    });

    // Store cache content locally for prompt logging
    this.chapterStartCacheContent.set(cacheKey, {
      systemInstruction: buildMasterSystemPrompt(),
      content: chapterCacheContent,
    });

    this.chapterStartCacheKeys.set(logicalKey, cacheKey);
    console.log(`[StoryGenerationService] ✅ Chapter-start cache created: ${cacheKey}`);
    return cacheKey;
  }

  /**
   * Build dynamic prompt content (changes per request)
   * This is sent alongside the cached static content
   */
  _buildDynamicPrompt(context, chapter, subchapter, isDecisionPoint, { cachedHistoryMaxChapter = null } = {}) {
    const parts = [];

    // Per Gemini 3 docs: Use XML tags for structure clarity
    // "place your specific instructions or questions at the end of the prompt, after the data context"

    // Dynamic Part 1: Story context
    // If we're using a chapter-start cache, the story up to previous chapter is already cached.
    parts.push('<story_context>');
    if (Number.isFinite(cachedHistoryMaxChapter)) {
      const minChapter = Math.max(1, cachedHistoryMaxChapter + 1);
      parts.push(this._buildStorySummarySection(context, { minChapter, maxChapter: chapter }));
    } else {
      parts.push(this._buildStorySummarySection(context));
    }
    parts.push('</story_context>');

    // Dynamic Part 2: Character Knowledge State (who knows what)
    parts.push('<character_knowledge>');
    parts.push(this._buildKnowledgeSection(context));
    parts.push('</character_knowledge>');

    // Dynamic Part 3: Voice DNA + Many-Shot Examples (beat-specific)
    const charactersInScene = this._extractCharactersFromContext(context, chapter);
    const beatType = this._getBeatType(chapter, subchapter);
    const chapterBeatType = STORY_STRUCTURE.chapterBeatTypes?.[chapter];

    // Voice DNA with recent dialogue examples
    const voiceDNA = buildVoiceDNASection(charactersInScene, context, chapter);
    if (voiceDNA) {
      parts.push('<voice_dna>');
      parts.push(voiceDNA);
      parts.push('</voice_dna>');
    }

    // Many-shot examples based on current beat type
    const manyShotExamples = buildManyShotExamples(beatType, chapterBeatType, 15);
    if (manyShotExamples) {
      parts.push(manyShotExamples);
      console.log(`[StoryGen] ✅ Many-shot (cached): ${beatType}, chapter: ${chapterBeatType?.type || 'none'}`);
    }

    // NOTE: Dramatic irony section removed - LLM has creative freedom

    // Dynamic Part 4: Consistency Checklist (established facts + active threads)
    parts.push('<active_threads>');
    parts.push(this._buildConsistencySection(context));
    parts.push('</active_threads>');

    // Dynamic Part 6: Current Scene State (exact continuation point)
    const sceneState = this._buildSceneStateSection(context, chapter, subchapter);
    if (sceneState) {
      parts.push('<scene_state>');
      parts.push(sceneState);
      parts.push('</scene_state>');
    }

    // Dynamic Part 6.5: Character Dialogue History (voice consistency)
    // Only include if we have enough previous content (chapter 3+)
    if (chapter >= 3 && context.previousChapters?.length >= 3) {
      const dialogueHistory = this._extractCharacterDialogueHistory(context.previousChapters);
      const dialogueSection = this._buildDialogueHistorySection(dialogueHistory);
      if (dialogueSection) {
        parts.push('<character_voices>');
        parts.push(dialogueSection);
        parts.push('</character_voices>');
      }
    }

    // Dynamic Part 7: Personal Stakes & Engagement Guidance
    const engagementGuidance = this._buildEngagementGuidanceSection(context, chapter, subchapter);
    if (engagementGuidance) {
      parts.push('<engagement_guidance>');
      parts.push(engagementGuidance);
      parts.push('</engagement_guidance>');
    }

    // Dynamic Part 8: Current Task Specification (LAST per Gemini 3 best practices)
    const taskSpec = this._buildTaskSection(context, chapter, subchapter, isDecisionPoint);
    // Note: beatType already declared earlier for many-shot examples (line 5049)

    // Gemini 3 best practice: Anchor reasoning to context with transition phrase
    parts.push(`
<task>
Based on all the context provided above (story_bible, story_context, active_threads, scene_state, engagement_guidance), write subchapter ${chapter}.${subchapter} (${beatType}).

Before writing, plan:
1. What narrative threads from ACTIVE_THREADS must be addressed?
2. What is the emotional anchor for this subchapter?
3. How does this advance the chapter beat (${beatType})?

${taskSpec}
</task>

<self_critique>
After generating your narrative, review it against these quality gates:

1. **Intent Alignment**: Did I answer the beat requirements, not just write prose?
2. **Thread Continuity**: Did I address at least 2 CRITICAL threads explicitly?
3. **Emotional Authenticity**: Is there a genuine gut-punch moment, not just plot?
4. **Timeline Precision**: Are all durations EXACT per ABSOLUTE_FACTS (never approximate)?
5. **Hook Quality**: Does the final line create unbearable forward momentum?
6. **Forbidden Patterns**: Did I avoid all forbidden phrases and constructions?

If any check fails, revise before returning your response.
</self_critique>`);

    return parts.join('\n\n');
  }

  /**
   * Build the complete generation prompt with all context
   * LEGACY METHOD - kept for backward compatibility, but now uses caching internally
   */
  _buildGenerationPrompt(context, chapter, subchapter, isDecisionPoint) {
    const parts = [];

    // Part 1: Story Bible Grounding (RAG)
    // Note: includeStyle=false because style is in Part 5 (_buildStyleSection)
    parts.push(this._buildGroundingSection(context, { includeStyle: false }));

    // Part 2: Complete Story So Far (FULL TEXT)
    parts.push(this._buildStorySummarySection(context));

    // Part 3: Character Reference
    parts.push(this._buildCharacterSection());

    // Part 4: Character Knowledge State (who knows what)
    parts.push(this._buildKnowledgeSection(context));

    // Part 5: Style Examples (Few-shot) with Voice DNA and Dramatic Irony
    // Determine which characters might be in this scene based on context
    const charactersInScene = this._extractCharactersFromContext(context, chapter);
    const pathKey = context.pathKey || '';
    const choiceHistory = context.playerChoices || [];
    const beatType = this._getBeatType(chapter, subchapter);
    const chapterBeatType = STORY_STRUCTURE.chapterBeatTypes?.[chapter];
    parts.push(this._buildStyleSection(charactersInScene, chapter, pathKey, choiceHistory, beatType, chapterBeatType, context));

    // Part 6: Consistency Checklist
    parts.push(this._buildConsistencySection(context));

    // Part 7: Current Scene State (CRITICAL - exact continuation point)
    const sceneState = this._buildSceneStateSection(context, chapter, subchapter);
    if (sceneState) {
      parts.push(sceneState);
    }

    // Part 8: Personal Stakes & Engagement Guidance (from story arc)
    const engagementGuidance = this._buildEngagementGuidanceSection(context, chapter, subchapter);
    if (engagementGuidance) {
      parts.push(engagementGuidance);
    }

    // Part 9: Craft Techniques (static storyBible reference)
    parts.push(this._buildCraftTechniquesSection());

    // Part 10: Current Task Specification (LAST for recency effect)
    // Gemini 3 best practice: Anchor reasoning to context with transition phrase
    const taskSection = this._buildTaskSection(context, chapter, subchapter, isDecisionPoint);
    parts.push(`Based on all the context provided above, complete the following task:\n\n${taskSection}`);

    return parts.join('\n\n---\n\n');
  }

  /**
   * Build craft techniques section with engagement requirements, micro-tension, rhythm, etc.
   * These are static techniques from storyBible that guide HOW to write compelling prose.
   */
  _buildCraftTechniquesSection() {
    return `## CRAFT TECHNIQUES - How to Write Compelling Prose

### ENGAGEMENT REQUIREMENTS

**Question Economy:** ${ENGAGEMENT_REQUIREMENTS.questionEconomy.description}
- Balance Rule: ${ENGAGEMENT_REQUIREMENTS.questionEconomy.balanceRule}
- Question Types: Mystery (plot), Character (relationships), Threat (tension), Thematic (meaning)

**Final Line Hook:** ${ENGAGEMENT_REQUIREMENTS.finalLineHook.description}
Techniques:
${ENGAGEMENT_REQUIREMENTS.finalLineHook.techniques.map(t => `- ${t}`).join('\n')}

**Personal Stakes Progression:**
- Chapters 1-4: ${ENGAGEMENT_REQUIREMENTS.personalStakes.progression.chapters1to4}
- Chapters 5-9: ${ENGAGEMENT_REQUIREMENTS.personalStakes.progression.chapters5to9}
- Chapters 10-12: ${ENGAGEMENT_REQUIREMENTS.personalStakes.progression.chapters10to12}

**Revelation Gradient:**
- Micro (every subchapter): ${ENGAGEMENT_REQUIREMENTS.revelationGradient.levels.micro}
- Chapter (end of each): ${ENGAGEMENT_REQUIREMENTS.revelationGradient.levels.chapter}
- Arc (chapters 4, 7, 10): ${ENGAGEMENT_REQUIREMENTS.revelationGradient.levels.arc}

**Emotional Anchor:** ${ENGAGEMENT_REQUIREMENTS.emotionalAnchor.description}
Rule: ${ENGAGEMENT_REQUIREMENTS.emotionalAnchor.rule}

### MICRO-TENSION TECHNIQUES
${MICRO_TENSION_TECHNIQUES.description}

Every paragraph MUST contain at least one:
${MICRO_TENSION_TECHNIQUES.elements.map(e => `- ${e}`).join('\n')}

**Warning:** ${MICRO_TENSION_TECHNIQUES.warning}

### SENTENCE RHYTHM (Noir Cadence)
${SENTENCE_RHYTHM.description}

Pattern example:
${SENTENCE_RHYTHM.pattern}

Rules:
${SENTENCE_RHYTHM.rules.map(r => `- ${r}`).join('\n')}

### THE ICEBERG TECHNIQUE
${ICEBERG_TECHNIQUE.description}

Applications:
${ICEBERG_TECHNIQUE.applications.map(a => `- ${a}`).join('\n')}

Principle: ${ICEBERG_TECHNIQUE.principle}

### SUBTEXT IN DIALOGUE
${SUBTEXT_REQUIREMENTS.description}

Layers:
- Surface: ${SUBTEXT_REQUIREMENTS.layers.surface}
- Actual: ${SUBTEXT_REQUIREMENTS.layers.actual}

Examples:
${SUBTEXT_REQUIREMENTS.examples.map(e => `"${e.surface}" → Subtext: "${e.subtext}"`).join('\n')}

**Rule:** ${SUBTEXT_REQUIREMENTS.rule}

### BRANCHING CHOICE DESIGN (For Interactive Narratives)

When generating branching choices (firstChoice options 1A/1B/1C and secondChoices options 2A/2B/2C):

**Options A and B (Standard Choices):**
- Two distinct, logical approaches to the situation
- One typically more aggressive/direct, one more cautious/methodical
- Both should be defensible choices with meaningful consequences

**Option C (WILDCARD - Required for all C options):**
- The WILDCARD option should be unexpected, creative, or unconventional
- It offers a surprising third path that players might not have considered
- Examples of wildcard approaches:
  - Doing something seemingly unrelated that yields unexpected results
  - Taking a risky gamble or bold action outside normal behavior
  - Using humor, misdirection, or an unorthodox tactic
  - Acting on intuition rather than logic
  - Making an unexpected alliance or revealing hidden information
- The wildcard should still be IN CHARACTER for Jack (noir detective, not silly)
- It should feel like a "what if I tried THIS?" moment
- The response should deliver on the promise of the unexpected choice

**Wildcard Quality Check:**
- Does option C feel genuinely different from A and B? (Not just a third variation)
- Would a player be surprised and intrigued by this option?
- Does it add variety and replayability to the narrative?`;
  }

  /**
   * Extract characters likely to appear in a scene based on context
   */
  _extractCharactersFromContext(context, chapter) {
    const characters = [];

    // Always include Jack (protagonist)
    // Check story arc for chapter-specific characters
    if (this.storyArc?.chapterArcs) {
      const chapterArc = this.storyArc.chapterArcs.find(a => a.chapter === chapter);
      if (chapterArc?.innocentFeatured) {
        characters.push(chapterArc.innocentFeatured);
      }
    }

    // Check active threads for characters
    if (context.narrativeThreads) {
      context.narrativeThreads.forEach(thread => {
        if (thread.characters) {
          characters.push(...thread.characters);
        }
      });
    }

    // Check recent narrative for character mentions
    // Only check for Victoria - she's the only canonical character besides Jack who needs voice DNA
    // Other characters are LLM-generated and don't have predefined voice patterns
    if (context.previousChapters?.length > 0) {
      const recentChapter = context.previousChapters[context.previousChapters.length - 1];
      if (recentChapter?.narrative) {
        const narrative = recentChapter.narrative.toLowerCase();
        if (narrative.includes('victoria') || narrative.includes('blackwell')) characters.push('Victoria');
      }
    }

    // Deduplicate and return
    return [...new Set(characters)];
  }

  /**
   * Build engagement guidance section with personal stakes and emotional anchors
   */
  _buildEngagementGuidanceSection(context, chapter, subchapter) {
    let section = `## ENGAGEMENT GUIDANCE FOR THIS CHAPTER\n\n`;

    // Get chapter-specific guidance from story arc
    if (this.storyArc?.chapterArcs) {
      const chapterArc = this.storyArc.chapterArcs.find(a => a.chapter === chapter);
      if (chapterArc) {
        section += `### CHAPTER ${chapter} FOCUS\n`;
        section += `**Phase:** ${chapterArc.phase}\n`;
        section += `**Primary Focus:** ${chapterArc.primaryFocus}\n`;
        section += `**Tension Level:** ${chapterArc.tensionLevel}/10\n`;

        if (chapterArc.personalStakes) {
          section += `\n### PERSONAL STAKES (What Jack loses if he fails HERE)\n`;
          section += `${chapterArc.personalStakes}\n`;
          section += `\n**Make the reader FEEL this is at risk. Show it, don't tell it.**\n`;
        }

        if (chapterArc.emotionalAnchor) {
          section += `\n### EMOTIONAL ANCHOR (The gut-punch moment for this chapter)\n`;
          section += `${chapterArc.emotionalAnchor}\n`;
          section += `\n**This is not plot. This is FEELING. Write it to hit the reader in the chest.**\n`;
        }

        if (chapterArc.keyRevelation) {
          section += `\n### KEY REVELATION\n`;
          section += `${chapterArc.keyRevelation}\n`;
        }

        section += `\n### ENDING HOOK\n`;
        section += `This chapter should end with: "${chapterArc.endingHook}"\n`;
        section += `\n**For subchapter ${['A', 'B', 'C'][subchapter - 1]}: Build toward this ending while creating micro-hooks at the end of your subchapter.**\n`;
      }
    }

    // Add subchapter-specific guidance
    section += `\n### SUBCHAPTER ${['A', 'B', 'C'][subchapter - 1]} ROLE\n`;
    if (subchapter === 1) {
      section += `- This is the OPENING of the chapter\n`;
      section += `- Establish atmosphere and continue from the previous choice\n`;
      section += `- Plant the seeds of this chapter's conflict\n`;
      section += `- Hook: End with a question or complication that demands continuation\n`;
    } else if (subchapter === 2) {
      section += `- This is the MIDDLE of the chapter\n`;
      section += `- Escalate the tension established in A\n`;
      section += `- Deliver at least one micro-revelation\n`;
      section += `- Hook: End with raised stakes or a turning point\n`;
    } else {
      section += `- This is the CLIMAX/DECISION of the chapter\n`;
      section += `- Deliver the emotional anchor moment\n`;
      section += `- Build to an impossible choice\n`;
      section += `- Hook: The decision itself is the ultimate cliffhanger\n`;
    }

    return section;
  }

  /**
   * Build grounding section with absolute facts
   */
  _buildGroundingSection(context, { includeStyle = true } = {}) {
    const safe = (v) => (v === undefined || v === null ? '' : String(v));

    const timelineLines = [];
    // TIMELINE DATA SOURCE NOTE:
    // - `src/data/storyBible.js` currently stores Jack's timeline under `TIMELINE.jackHistory`
    //   (a mix of numeric keys + "childhood") and story start details under `TIMELINE.storyStart`.
    // - Older iterations used `TIMELINE.yearsAgo`.
    // This prompt builder supports BOTH so we don't silently drop canonical history.

    // Always include story-start anchor if available.
    if (TIMELINE?.storyStart) {
      if (TIMELINE.storyStart.anchorDate) timelineLines.push(`- Story starts on: ${safe(TIMELINE.storyStart.anchorDate)}`);
      if (TIMELINE.storyStart.jackAge) timelineLines.push(`- Jack's age at story start: ${safe(TIMELINE.storyStart.jackAge)}`);
      if (TIMELINE.storyStart.jackState) timelineLines.push(`- Jack's state at story start: ${safe(TIMELINE.storyStart.jackState)}`);
    }

    // Prefer explicit yearsAgo if present; otherwise fall back to jackHistory.
    const yearsAgo = TIMELINE?.yearsAgo;
    if (yearsAgo && typeof yearsAgo === 'object') {
      const yearKeys = Object.keys(yearsAgo)
        .map(k => Number(k))
        .filter(n => Number.isFinite(n))
        .sort((a, b) => b - a);
      for (const y of yearKeys) {
        const entry = yearsAgo[y];
        if (Array.isArray(entry)) {
          timelineLines.push(`- ${y} years ago:`);
          entry.forEach(e => timelineLines.push(`  - ${safe(e)}`));
        } else {
          timelineLines.push(`- ${y} years ago: ${safe(entry)}`);
        }
      }
    } else {
      const jackHistory = TIMELINE?.jackHistory;
      if (jackHistory && typeof jackHistory === 'object') {
        if (jackHistory.childhood) timelineLines.push(`- Childhood: ${safe(jackHistory.childhood)}`);

        const numericKeys = Object.keys(jackHistory)
          .filter(k => k !== 'childhood')
          .map(k => Number(k))
          .filter(n => Number.isFinite(n))
          .sort((a, b) => b - a);

        for (const k of numericKeys) {
          const entry = jackHistory[k];
          if (Array.isArray(entry)) {
            timelineLines.push(`- Timeline marker ${k}:`);
            entry.forEach(e => timelineLines.push(`  - ${safe(e)}`));
          } else {
            timelineLines.push(`- Timeline marker ${k}: ${safe(entry)}`);
          }
        }
      }
    }

    let section = `## STORY BIBLE - ABSOLUTE FACTS (Never contradict these)

### PROTAGONIST
- Name: ${safe(ABSOLUTE_FACTS.protagonist.fullName)}
- Age: ${safe(ABSOLUTE_FACTS.protagonist.age)}
- Status: ${safe(ABSOLUTE_FACTS.protagonist.currentStatus)}
- Work background: ${safe(ABSOLUTE_FACTS.protagonist.careerLength)}
- Residence: ${safe(ABSOLUTE_FACTS.protagonist.residence)}
- Vice: ${safe(ABSOLUTE_FACTS.protagonist.vices?.[0])}

### ANTAGONIST / GUIDE FIGURE
- Name: ${safe(ABSOLUTE_FACTS.antagonist.trueName)}
- Alias used: ${safe(ABSOLUTE_FACTS.antagonist.aliasUsed)}
- Public-facing role: ${safe(ABSOLUTE_FACTS.antagonist.occupation)}
- Communication: ${safe(ABSOLUTE_FACTS.antagonist.communication?.method)}; ink: ${safe(ABSOLUTE_FACTS.antagonist.communication?.ink)}
- Motivation: "${safe(ABSOLUTE_FACTS.antagonist.motivation)}"

### SETTING
- City: ${safe(ABSOLUTE_FACTS.setting.city)}
- Atmosphere: ${safe(ABSOLUTE_FACTS.setting.atmosphere)}
- Core mystery: ${safe(ABSOLUTE_FACTS.setting.coreMystery)}

### CREATIVE FREEDOM
- The LLM may generate any supporting characters, locations, and plot elements as the story requires.
- Only Jack Halloway and Victoria Blackwell have canonical definitions.

### TIMELINE (Use exact numbers; never approximate)
${timelineLines.length ? timelineLines.join('\n') : '- (No timeline entries)'}
`;

    // Writing style is large and repeated elsewhere; include only when needed.
    if (includeStyle) {
      section += `
### WRITING STYLE REQUIREMENTS
**Voice:** ${WRITING_STYLE.voice.perspective}, ${WRITING_STYLE.voice.tense}
**Tone:** ${WRITING_STYLE.voice.tone}
**Influences:** ${WRITING_STYLE.influences.join(', ')}

**MUST INCLUDE:**
${WRITING_STYLE.mustInclude.map(item => `- ${item}`).join('\n')}

**ABSOLUTELY FORBIDDEN (Never use these):**
${WRITING_STYLE.absolutelyForbidden.map(item => `- ${item}`).join('\n')}`;
    }

    return section;
  }

  /**
   * Build COMPLETE story history with FULL narratives
   *
   * With 1M token context window, we include the ENTIRE story text.
   * This ensures the LLM has full context for proper continuation.
   */
  _buildStorySummarySection(context, { minChapter = 1, maxChapter = Infinity } = {}) {
    const clampMin = Number.isFinite(minChapter) ? minChapter : 1;
    const clampMax = Number.isFinite(maxChapter) ? maxChapter : Infinity;

    // Guard: If maxChapter < minChapter (e.g., chapter 1 with maxChapter=0), no previous story exists
    if (clampMax < clampMin) {
      return '## STORY CONTEXT\n\n**This is the beginning of the story. No previous chapters exist.**\n';
    }

    const isFiltered = clampMin !== 1 || clampMax !== Infinity;
    const header = isFiltered
      ? `## STORY CONTEXT (FULL TEXT)\n\n**Included chapters:** ${clampMin} to ${clampMax === Infinity ? 'latest' : clampMax}\n\n`
      : '## COMPLETE STORY SO FAR (FULL TEXT)\n\n';

    let summary = header;
    summary += '**CRITICAL: You are continuing an ongoing story. Read ALL of this carefully.**\n';
    summary += '**Your new subchapter MUST continue EXACTLY from where the previous subchapter ended.**\n';
    summary += '**DO NOT summarize, skip, or rehash events. Pick up the narrative mid-scene if needed.**\n\n';

    // Build quick lookup: decision chapter -> choice object (from choice history)
    const choicesByChapter = new Map();
    if (Array.isArray(context.playerChoices)) {
      context.playerChoices.forEach((c) => {
        if (c?.chapter) choicesByChapter.set(c.chapter, c);
      });
    }

    // Sort all chapters chronologically, then filter by requested range.
    const allChapters = [...context.previousChapters].sort((a, b) => {
      if (a.chapter !== b.chapter) return a.chapter - b.chapter;
      return a.subchapter - b.subchapter;
    }).filter((ch) => ch.chapter >= clampMin && ch.chapter <= clampMax);

    // Track the immediately preceding subchapter for emphasis
    const currentChapter = context.currentPosition?.chapter;
    const currentSubchapter = context.currentPosition?.subchapter;

    // Find the immediately previous subchapter (within the filtered window)
    let immediatelyPrevious = null;
    if (currentSubchapter > 1) {
      // Previous subchapter in same chapter
      immediatelyPrevious = allChapters.find(
        ch => ch.chapter === currentChapter && ch.subchapter === currentSubchapter - 1
      );
    } else if (currentChapter > 1) {
      // Last subchapter of previous chapter
      immediatelyPrevious = allChapters.find(
        ch => ch.chapter === currentChapter - 1 && ch.subchapter === 3
      );
    }

    // ========== FULL NARRATIVE INCLUSION ==========
    // With Gemini 3's 1M token context window, the entire 12-chapter story (~42k tokens)
    // uses only ~4% of context capacity. No summarization needed - include everything.
    // Full context maximizes consistency across the 12-chapter arc.

    for (const ch of allChapters) {
      const isImmediatelyPrevious = (
        immediatelyPrevious &&
        ch.chapter === immediatelyPrevious.chapter &&
        ch.subchapter === immediatelyPrevious.subchapter
      );

      // Chapter header with emphasis for immediately previous
      if (isImmediatelyPrevious) {
        summary += `\n${'='.repeat(80)}\n`;
        summary += `### >>> IMMEDIATELY PREVIOUS SUBCHAPTER - CONTINUE FROM HERE <<<\n`;
        summary += `### Chapter ${ch.chapter}, Subchapter ${ch.subchapter} (${['A', 'B', 'C'][ch.subchapter - 1]}): "${ch.title}"\n`;
        summary += `${'='.repeat(80)}\n\n`;
      } else {
        summary += `\n### Chapter ${ch.chapter}, Subchapter ${ch.subchapter} (${['A', 'B', 'C'][ch.subchapter - 1]}): "${ch.title}"\n\n`;
      }

      // Include FULL narrative text for ALL chapters - no summarization needed with 1M context
      if (ch.narrative) {
        summary += ch.narrative;
        summary += '\n';
      }

      // Mark decision points and what the player chose
      if (ch.subchapter === 3) {
        const choice = choicesByChapter.get(ch.chapter);
        if (choice?.optionKey) {
          const title = choice.optionTitle ? ` "${choice.optionTitle}"` : '';
          const focus = choice.optionFocus ? `\n   Focus: ${choice.optionFocus}` : '';
          summary += `\n[>>> PLAYER DECISION at end of Chapter ${ch.chapter}: CHOSE OPTION ${choice.optionKey}${title}${focus}`;

          // If this is the most recent decision affecting current chapter
          if (ch.chapter === currentChapter - 1) {
            summary += `\n   *** THIS CHOICE MUST DRIVE THE OPENING OF YOUR NARRATIVE ***`;
            summary += `\n   *** SHOW THIS SCENE HAPPENING - DO NOT SKIP OR SUMMARIZE IT ***`;
          }
          summary += `]\n`;
        }

        // Also show the decision options that were presented
        // Handle both legacy (decision) and new (pathDecisions) formats
        // Use player's actual branching path for path-specific decision lookup
        let decisionData = ch.decision; // Default to legacy format
        if (ch.pathDecisions) {
          // Try to look up path-specific decision using player's branchingPath
          const playerPath = ch.branchingPath || '1A-2A';
          if (Array.isArray(ch.pathDecisions)) {
            decisionData = ch.pathDecisions.find(d => d.pathKey === playerPath)
              || ch.pathDecisions.find(d => d.pathKey === '1A-2A')
              || ch.pathDecisions[0]
              || ch.decision;
          } else {
            decisionData = ch.pathDecisions[playerPath] || ch.pathDecisions['1A-2A'] || ch.decision;
          }
        }
        // Handle both formats: options array (legacy) or optionA/optionB (new)
        const options = decisionData?.options || (decisionData?.optionA && decisionData?.optionB
          ? [{ key: 'A', ...decisionData.optionA }, { key: 'B', ...decisionData.optionB }]
          : null);
        if (options) {
          summary += `\n[Decision options were:\n`;
          options.forEach(opt => {
            const chosen = choice?.optionKey === opt.key ? ' ← CHOSEN' : '';
            summary += `   ${opt.key}: "${opt.title}" - ${opt.focus}${chosen}\n`;
          });
          summary += `]\n`;
        }
      }

      // Emphasize continuation point
      if (isImmediatelyPrevious) {
        summary += `\n${'='.repeat(80)}\n`;
        summary += `>>> YOUR NARRATIVE MUST CONTINUE FROM THE END OF THIS TEXT <<<\n`;

        // Extract and highlight the last few sentences
        const sentences = ch.narrative?.match(/[^.!?]+[.!?]+/g) || [];
        if (sentences.length > 0) {
          const lastSentences = sentences.slice(-3).join(' ').trim();
          summary += `\nTHE STORY ENDED WITH:\n"${lastSentences}"\n`;
          summary += `\n>>> PICK UP EXACTLY HERE. What happens NEXT? <<<\n`;
        }
        summary += `${'='.repeat(80)}\n`;
      }

      summary += '\n---\n';
    }

    // Add explicit player choice history section
    if (context.playerChoices.length > 0) {
      summary += '\n### PLAYER CHOICE HISTORY (All decisions made)\n';
      context.playerChoices.forEach(choice => {
        const title = choice.optionTitle ? `: "${choice.optionTitle}"` : '';
        const focus = choice.optionFocus ? ` (${choice.optionFocus})` : '';
        summary += `- Chapter ${choice.chapter} Decision: Option ${choice.optionKey}${title}${focus}\n`;
      });
      summary += '\n';
    }

    // NOTE: Continuation requirements are in _buildSceneStateSection and _buildTaskSection
    // to avoid duplication

    return summary;
  }

  /**
   * Build character reference section
   */
  _buildCharacterSection() {
    const { protagonist, antagonist } = CHARACTER_REFERENCE;

    // Helper to format example phrases
    const formatExamples = (phrases) => {
      return phrases.map(phrase => `  - "${phrase}"`).join('\n');
    };

    return `## CHARACTER VOICES (Defined Characters)

### JACK HALLOWAY (Protagonist - Narration is close third-person on Jack)
Role: ${protagonist.role}, ${protagonist.age}
Voice: ${protagonist.voiceAndStyle.narrative}
Internal Monologue: ${protagonist.voiceAndStyle.internalMonologue}
Dialogue: ${protagonist.voiceAndStyle.dialogue}
Example Phrases:
${formatExamples(protagonist.voiceAndStyle.examplePhrases)}

### VICTORIA BLACKWELL
Role: ${antagonist.role}
Aliases: ${antagonist.aliases.join(', ')}
Voice (Speaking): ${antagonist.voiceAndStyle.speaking}
Voice (Written): ${antagonist.voiceAndStyle.written}
Example Phrases:
${formatExamples(antagonist.voiceAndStyle.examplePhrases)}

### OTHER CHARACTERS
The LLM has creative freedom to generate any supporting characters as the story requires.
Create distinctive voices for any new characters that serve the narrative.`;
  }

  /**
   * Build task specification section
   * Now includes Story Arc and Chapter Outline guidance for 100% consistency
   */
  _buildTaskSection(context, chapter, subchapter, isDecisionPoint) {
    const chaptersRemaining = TOTAL_CHAPTERS - chapter;
    const subchapterLabel = ['A', 'B', 'C'][subchapter - 1];
    const pacing = this._getPacingGuidance(chapter);
    const personality = context.pathPersonality || PATH_PERSONALITY_TRAITS.BALANCED;

    // Get story arc guidance for this chapter
    const chapterArc = context.storyArc?.chapterArcs?.find(c => c.chapter === chapter);

    // Get chapter outline for subchapter guidance
    const outline = context.chapterOutline;
    const subchapterOutline = outline ? outline[`subchapter${subchapterLabel}`] : null;

    // Get beat type constraints for tempo variation
    const beatType = STORY_STRUCTURE.chapterBeatTypes?.[chapter];

    let task = `## CURRENT TASK

Write **Chapter ${chapter}, Subchapter ${subchapter} (${subchapterLabel})**

### STORY POSITION
- Chapter ${chapter} of ${TOTAL_CHAPTERS} (${chaptersRemaining} remaining)
- Subchapter ${subchapter} of 3
- Current path: "${context.currentPosition.pathKey}"
- Phase: ${pacing.phase}`;

    // ========== BEAT TYPE CONSTRAINTS (Tempo Variation) ==========
    if (beatType) {
      task += `

### CHAPTER BEAT TYPE: ${beatType.type} (MANDATORY)
**${beatType.description}**

This chapter MUST include:
${beatType.requirements.map(r => `- ${r}`).join('\n')}`;

      // Add beat-type-specific pacing instructions
      if (beatType.type === 'CHASE') {
        task += `

**CHASE PACING MANDATE:**
- Keep paragraphs under 4 sentences
- No internal monologue longer than 2 sentences
- Use ACTION VERBS: ran, ducked, slammed, grabbed, dove
- Short dialogue exchanges (1-2 lines max)
- Breathless sentence fragments are OK: "Corner. Left. Another alley."
- Physical sensations: burning lungs, pounding heart, rain in eyes
- Time pressure in every scene: "Thirty seconds. Maybe less."`;
      } else if (beatType.type === 'BOTTLE_EPISODE') {
        task += `

**BOTTLE EPISODE PACING MANDATE:**
- Extended dialogue exchanges (5+ back-and-forth minimum)
- Stay in ONE primary location the entire chapter
- Deep character exploration through conversation
- Allow pauses, silences, meaningful looks
- Internal monologue between dialogue beats
- No scene cuts to other locations
- Psychological tension over physical action`;
      } else if (beatType.type === 'CONFRONTATION' || beatType.type === 'BETRAYAL') {
        task += `

**CONFRONTATION PACING MANDATE:**
- Build to the confrontation through the first half
- The confrontation itself should be LONG and detailed
- Every word in the dialogue carries weight
- Physical descriptions of tension (clenched jaw, white knuckles)
- Allow for emotional gut-punches with space to breathe after`;
      } else if (beatType.wordCountModifier < 1.0) {
        task += `

**PACING NOTE:** This is a FAST-PACED chapter. Keep scenes short and punchy. Less exposition, more action.`;
      } else if (beatType.wordCountModifier > 1.0) {
        task += `

**PACING NOTE:** This is a DEEP chapter. Take time for dialogue and character exploration. Don't rush.`;
      }
    }

    // ========== NEW: Story Arc Guidance ==========
    if (chapterArc) {
      task += `

### STORY ARC GUIDANCE (Follow this for consistency)
- **Chapter Focus:** ${chapterArc.primaryFocus}
${chapterArc.innocentFeatured ? `- **Featured Innocent:** ${chapterArc.innocentFeatured}` : ''}
${chapterArc.keyRevelation ? `- **Key Revelation:** ${chapterArc.keyRevelation}` : ''}
- **Tension Level:** ${chapterArc.tensionLevel}/10
- **Ending Hook:** ${chapterArc.endingHook}
${chapterArc.decisionTheme ? `- **Decision Theme:** ${chapterArc.decisionTheme}` : ''}`;
    }

    // ========== NEW: Chapter Outline Guidance ==========
    if (subchapterOutline) {
      task += `

### SUBCHAPTER ${subchapterLabel} OUTLINE (Follow this structure)
- **Focus:** ${subchapterOutline.focus}
- **Key Beats:** ${subchapterOutline.keyBeats?.join(', ') || 'Build tension naturally'}
${subchapterOutline.endingTransition ? `- **Transition to next:** ${subchapterOutline.endingTransition}` : ''}`;

      if (isDecisionPoint && subchapterOutline.decisionSetup) {
        task += `
- **Decision Setup:** ${subchapterOutline.decisionSetup}
- **Option A Direction:** ${subchapterOutline.optionADirection || 'More direct approach'}
- **Option B Direction:** ${subchapterOutline.optionBDirection || 'More cautious approach'}`;
      }
    }

    // ========== NEW: Outline Causality + Must-Reference Anchors ==========
    if (outline?.openingCausality && subchapter === 1) {
      task += `

### OPENING CAUSALITY (Mandatory)
${outline.openingCausality}`;
    }
    if (Array.isArray(outline?.mustReference) && outline.mustReference.length > 0) {
      task += `

### MUST-REFERENCE ANCHORS (Mandatory)
${outline.mustReference.slice(0, 6).map((x) => `- ${x}`).join('\n')}`;
    }

    // ========== NEW: Narrative Thread Continuity ==========
    if (outline?.narrativeThreads?.length > 0) {
      task += `

### NARRATIVE THREADS (Weave these through the chapter)
${outline.narrativeThreads.map(t => `- ${t}`).join('\n')}`;
    }

    task += `

### PLAYER PATH PERSONALITY (CRITICAL FOR CONSISTENCY)
Based on player's choices, the protagonist's behavior pattern is: **${personality.narrativeStyle}**
- Dialogue tone should be ${personality.dialogueTone}
- Risk tolerance: ${personality.riskTolerance}
${personality.scores ? `- Cumulative scores: Aggressive=${personality.scores.aggressive.toFixed(0)}, Methodical=${personality.scores.methodical.toFixed(0)}` : ''}

**IMPORTANT:** ${ABSOLUTE_FACTS.protagonist.fullName}'s actions and dialogue MUST reflect this established personality pattern.`;

    // Add personality-specific voice examples
    if (personality.riskTolerance === 'high') {
      task += `

**AGGRESSIVE JACK VOICE EXAMPLES:**
Same scene, written for aggressive Jack:
- Entering a dangerous location: "Jack kicked the door open before better judgment could catch up. The warehouse stank of rust and old violence. Good. He was in the mood for both."
- Confronting a suspect: "'Cut the crap,' Jack said, grabbing his collar. 'I know what you did. The only question is whether you tell me now, or I find out the hard way and come back angry.'"
- Internal monologue: "He'd spent years being the patient one. Look where it got him. This time, he wasn't waiting for permission."
- DO: Push, confront, act first and deal with consequences later
- DON'T: Hesitate, gather excessive evidence, wait patiently`;
    } else if (personality.riskTolerance === 'low') {
      task += `

**METHODICAL JACK VOICE EXAMPLES:**
Same scene, written for methodical Jack:
- Entering a dangerous location: "Jack circled the warehouse twice before going in. Noted the exits. The fire escape with the broken third rung. The way the security light flickered every forty seconds. Only then did he try the door."
- Confronting a suspect: "'I've got some questions,' Jack said, keeping his voice level. 'You can answer them here, or I can come back with enough evidence to make this conversation unnecessary. Your choice.'"
- Internal monologue: "Patterns rewarded patience more than bravado. He could wait. He'd gotten good at waiting."
- DO: Observe, plan, build the case methodically, leverage information
- DON'T: Rush in, confront without evidence, take unnecessary risks`;
    } else {
      task += `

**BALANCED JACK VOICE NOTE:**
Jack adapts his approach to the situation. He can be patient when it serves him, aggressive when pushed. Match the narrative moment: if stakes are high and time is short, he acts; if information is needed, he investigates.`;
    }

    task += `

### DECISION CONSEQUENCES (Must be reflected in narrative)
${context.decisionConsequences?.immediate?.length > 0 ? context.decisionConsequences.immediate.map(c => `- ${c}`).join('\n') : '- No previous decisions yet'}

### ONGOING EFFECTS FROM CHOICES
${context.decisionConsequences?.ongoing?.length > 0 ? [...new Set(context.decisionConsequences.ongoing)].slice(0, 5).map(e => `- ${e}`).join('\n') : '- Starting fresh'}

### MOST RECENT PLAYER DECISION (This MUST drive this subchapter)
${context.lastDecision
  ? `- Decision: Chapter ${context.lastDecision.chapter} (${context.lastDecision.caseNumber}) => Option "${context.lastDecision.optionKey}"
- Chosen action: ${context.lastDecision.chosenTitle || '(title unavailable)'}
- Immediate consequence to OPEN ON: ${context.lastDecision.immediate}
- The road not taken: ${context.lastDecision.otherTitle || '(unknown)'}`
  : '- None (start of story)'}

### PACING REQUIREMENTS
${pacing.requirements.map(r => `- ${r}`).join('\n')}

### WRITING REQUIREMENTS
1. **PLAN FIRST:** Use the 'beatSheet' field to outline 3-5 major beats.
2. **MINIMUM ${MIN_WORDS_PER_SUBCHAPTER} WORDS** - AIM FOR ${TARGET_WORDS}+ WORDS. Write generously. Do NOT stop short.
3. Continue DIRECTLY from where the last subchapter ended
4. Maintain third-person limited voice throughout (no first-person narration)
5. Reference specific events from previous chapters (show continuity)
6. Include: atmospheric description, internal monologue, dialogue
7. Build tension appropriate to ${pacing.phase} phase
8. **ENSURE the protagonist's behavior matches the path personality above**
9. **FOLLOW the story arc and chapter outline guidance above**`;

    // Add emphasis on recent decision if applicable (beginning of new chapter)
    if (subchapter === 1 && context.playerChoices.length > 0) {
      const lastChoice = context.playerChoices[context.playerChoices.length - 1];
      if (lastChoice.chapter === chapter - 1) {
        // Use the stored title/focus if available, otherwise fall back to key
        const choiceTitle = lastChoice.optionTitle || `Option ${lastChoice.optionKey}`;
        const choiceFocus = lastChoice.optionFocus ? `\nFOCUS: ${lastChoice.optionFocus}` : '';

        task += `\n\n### CRITICAL CONTEXT: PREVIOUS DECISION
The player JUST made a crucial decision at the end of the previous chapter.
You MUST SHOW THIS SCENE - do NOT skip it or summarize it as past events.

PLAYER'S CHOICE: "${choiceTitle}"${choiceFocus}

**MANDATORY REQUIREMENTS:**
1. The chapter MUST OPEN with Jack actively pursuing this choice - we see the scene unfold in real-time
2. DO NOT start with "After going to..." or "Having confronted..." - START IN THE MOMENT
3. The FIRST 200+ WORDS should be the actual scene of the chosen action
4. Show sensory details: what Jack sees, hears, feels as he takes this action
5. Include dialogue and character reactions from whoever Jack encounters

Example of WRONG approach: "After Jack confronted Wade at the wharf, he returned to his office..."
Example of CORRECT approach: "The salt wind cut through Jack's coat as he stepped onto the weathered planks of the wharf. Wade's silhouette emerged from the fog..."`;
      }
    }

    if (isDecisionPoint) {
      task += `

### DECISION POINT REQUIREMENTS - PATH-SPECIFIC DECISIONS
This subchapter ends with a binary choice. The player will see different decision options depending on which branching path they took within this subchapter.

**CRITICAL: Generate 9 UNIQUE decisions in the "pathDecisions" object** - one for each ending path:
- 1A-2A, 1A-2B, 1A-2C (paths starting with choice 1A)
- 1B-2A, 1B-2B, 1B-2C (paths starting with choice 1B)
- 1C-2A, 1C-2B, 1C-2C (paths starting with choice 1C)

**WHY THIS MATTERS:**
A player who took the aggressive path (e.g., 1A→1A-2A) should face decisions that reflect THEIR journey.
A player who took the cautious path (e.g., 1C→1C-2C) should face decisions suited to THEIR situation.
The narrative context differs by path, so the strategic options should differ too.

**DECISION DESIGN REQUIREMENTS:**
1. Each of the 9 pathDecisions must present TWO distinct paths (Option A and Option B)
2. Both options must be morally complex - NO obvious "right" answer
3. Each choice should have CLEAR but DIFFERENT consequences
4. The decision must feel EARNED by the specific path the player took
5. Connect to the themes of wrongful conviction, certainty vs truth
6. The intro should reference elements unique to that branching path

**EXAMPLE of path-specific variation:**
- Path 1A-2A (aggressive throughout): "After forcing Claire's hand, Jack now faces a riskier choice..."
- Path 1C-2C (cautious throughout): "Having gathered the evidence methodically, Jack now sees two clear paths..."

**For EACH decision in pathDecisions (all 9):**
- intro: 1-2 sentences framing the choice, reflecting that specific path's context
- optionA.title: Action statement in imperative mood
- optionA.focus: What this path prioritizes and what it risks
- optionB.title: Action statement in imperative mood
- optionB.focus: What this path prioritizes and what it risks`;
    }

    return task;
  }

  /**
   * Build style examples section (few-shot learning)
   */
  _buildStyleSection(charactersInScene = [], chapter = 2, pathKey = '', choiceHistory = [], beatType = '', chapterBeatType = null, context = {}) {
    // Build extended examples section
    let extendedExamples = '';
    try {
      extendedExamples = buildExtendedStyleExamples();
      if (!extendedExamples || extendedExamples.length < 1000) {
        console.error('[StoryGen] ⚠️ Extended examples missing/short in _buildStyleSection!', extendedExamples?.length);
      }
    } catch (e) {
      console.error('[StoryGen] ❌ Extended examples FAILED:', e.message);
      extendedExamples = '';
    }

    // Build many-shot examples section based on beat type
    let manyShotExamples = '';
    try {
      manyShotExamples = buildManyShotExamples(beatType, chapterBeatType, 15);
      if (manyShotExamples) {
        console.log(`[StoryGen] ✅ Many-shot: ${beatType}, chapter: ${chapterBeatType?.type || 'none'}`);
      }
    } catch (e) {
      console.error('[StoryGen] ❌ Many-shot examples FAILED:', e.message);
      manyShotExamples = '';
    }

    // Build voice DNA section for characters in this scene
    let voiceDNA = '';
    try {
      voiceDNA = buildVoiceDNASection(charactersInScene, context, chapter);
      if (!voiceDNA || voiceDNA.length < 100) {
        console.warn('[StoryGen] ⚠️ Voice DNA short/empty. Characters:', charactersInScene);
      }
    } catch (e) {
      console.error('[StoryGen] ❌ Voice DNA FAILED:', e.message);
      voiceDNA = '';
    }

    // NOTE: Dramatic irony section removed - LLM has creative freedom

    return `## STYLE REFERENCE

Study this example passage and match its quality:

${EXAMPLE_PASSAGES.tenseMoment}

**Note the:** punchy sentences, sensory grounding, character voice through action, tension without melodrama.

${STYLE_EXAMPLES}

${extendedExamples}

${manyShotExamples}

${voiceDNA}`;
  }

  /**
   * Build consistency verification section
   */
  _buildConsistencySection(context) {
    const cw = GENERATION_CONFIG?.contextWindowing || {};
    const maxFacts = cw.maxFactsInPrompt || 60;
    const maxThreads = cw.maxThreadsInPrompt || 30;
    const currentChapter = context.currentPosition?.chapter || 1;

    let section = `## CONSISTENCY VERIFICATION

### ESTABLISHED FACTS (Never contradict)
${context.establishedFacts.slice(0, maxFacts).map(f => `- ${f}`).join('\n')}`;

    // ========== ENHANCED THREAD PRIORITY INJECTION ==========
    // Sort threads by priority: urgency × overdue status
    // Critical/overdue threads MUST be addressed in the narrative
    if (context.narrativeThreads && context.narrativeThreads.length > 0) {
      // Calculate priority score for each thread
      const prioritizedThreads = context.narrativeThreads
        .filter(t => t.status === 'active')
        .map(t => {
          // Base priority from urgency
          let priority = t.urgency === 'critical' ? 3 : t.urgency === 'normal' ? 2 : 1;

          // Overdue bonus (threads past their due chapter)
          const isOverdue = t.dueChapter && currentChapter > t.dueChapter;
          if (isOverdue) priority += 5;

          // Type bonus (appointments/promises/threats are more urgent)
          const urgentTypes = ['appointment', 'promise', 'threat'];
          if (urgentTypes.includes(t.type)) priority += 1;

          return { ...t, priority, isOverdue };
        })
        .sort((a, b) => b.priority - a.priority)
        .slice(0, maxThreads);

      // Separate mandatory vs optional threads
      const mandatoryThreads = prioritizedThreads.filter(t => t.priority >= 4 || t.isOverdue);
      const optionalThreads = prioritizedThreads.filter(t => t.priority < 4 && !t.isOverdue);

      // ========== MANDATORY THREAD REQUIREMENTS (Cannot be ignored) ==========
      if (mandatoryThreads.length > 0) {
        section += `\n\n${'='.repeat(60)}`;
        section += `\n### MANDATORY THREAD REQUIREMENTS`;
        section += `\n${'='.repeat(60)}`;
        section += `\n**These threads MUST be addressed in your narrative. Failure to address them is a consistency violation.**\n`;

        mandatoryThreads.forEach((t, idx) => {
          const overdueTag = t.isOverdue ? '⚠️ OVERDUE' : '';
          const priorityTag = t.urgency === 'critical' ? '🔴 CRITICAL' : '🟡 URGENT';
          const desc = t.description || t.excerpt || '';
          const truncatedDesc = desc.length > TRUNCATE_DESCRIPTION ? desc.slice(0, TRUNCATE_DESCRIPTION) + '...' : desc;

          section += `\n${idx + 1}. [${priorityTag}${overdueTag ? ' ' + overdueTag : ''}] ${t.type.toUpperCase()}`;
          section += `\n   "${truncatedDesc}"`;
          if (t.characters && t.characters.length > 0) {
            section += `\n   Characters: ${t.characters.join(', ')}`;
          }
          if (t.dueChapter) {
            section += `\n   Due by: Chapter ${t.dueChapter}${t.isOverdue ? ' (OVERDUE!)' : ''}`;
          }
          section += `\n`;
        });

        section += `\n>>> YOU MUST address ALL threads above through dialogue or action, not just thoughts <<<`;
        section += `\n${'='.repeat(60)}`;
      }

      // ========== ACTIVE THREADS (Should address if possible) ==========
      if (optionalThreads.length > 0) {
        section += `\n\n### ACTIVE THREADS (Address if narratively appropriate)`;

        const threadsByType = {};
        optionalThreads.forEach(t => {
          if (!threadsByType[t.type]) threadsByType[t.type] = [];
          threadsByType[t.type].push(t);
        });

        Object.keys(threadsByType).forEach(type => {
          section += `\n**${type.toUpperCase()}:**`;
          threadsByType[type].forEach(t => {
            const desc = t.description || t.excerpt || '';
            const truncatedDesc = desc.length > TRUNCATE_DESCRIPTION ? desc.slice(0, TRUNCATE_DESCRIPTION) + '...' : desc;
            section += `\n- Ch${t.chapter || '?'}: "${truncatedDesc}"`;
          });
        });
      }
    }

    section += `

### YOUR CONSISTENCY RESPONSIBILITIES
1. MANDATORY threads above must be visibly addressed in dialogue or action
2. NEVER contradict established character names, relationships, or timeline facts
3. Setting tone: modern city with hidden fantasy layer (no Tolkien-style elements)
4. Respect player's path personality and previous decision consequences`;

    return section;
  }

  /**
   * Get pacing guidance based on chapter
   */
  _getBeatType(chapter, subchapter) {
    // Return a simple beat type description for the task prompt
    const subchapterLabel = ['A', 'B', 'C'][subchapter - 1] || 'A';
    if (subchapter === 1) return `Opening/Hook (${subchapterLabel})`;
    if (subchapter === 2) return `Development/Conflict (${subchapterLabel})`;
    if (subchapter === 3) return `Resolution/Decision (${subchapterLabel})`;
    return `Subchapter ${subchapterLabel}`;
  }

  _getPacingGuidance(chapter) {
    const { protagonist, antagonist } = ABSOLUTE_FACTS;
    const { pacing } = STORY_STRUCTURE;

    // Get pacing data from STORY_STRUCTURE
    let pacingData;
    if (chapter <= 4) pacingData = pacing.chapters2to4;
    else if (chapter <= 7) pacingData = pacing.chapters5to7;
    else if (chapter <= 10) pacingData = pacing.chapters8to10;
    else pacingData = pacing.chapters11to12;

    // Build requirements based on phase
    const phaseRequirements = {
      'RISING ACTION': [
        'Continue establishing the mystery',
        'Introduce new suspects or complications',
        `${protagonist.fullName} should be actively investigating`,
        'Build relationships with allies/adversaries',
        'Plant seeds for later revelations',
      ],
      'COMPLICATIONS': [
        'Escalate stakes significantly',
        'Reveal betrayals or hidden connections',
        `${protagonist.fullName} faces increasing danger and doubt`,
        'Moral dilemmas become more complex',
        `${antagonist.trueName}'s guidance and rules become clearer`,
      ],
      'CONFRONTATIONS': [
        'Major revelations about the pattern and the forces shaping it',
        `${protagonist.fullName} must confront what the city is doing - and what to do back`,
        'Allies may be lost or trust shattered',
        'The full shape of the pattern emerges',
        `Personal cost to ${protagonist.fullName} escalates dramatically`,
      ],
      'RESOLUTION': [
        'Final confrontation approaching or occurring',
        'All narrative threads coming together',
        `${protagonist.fullName} must make impossible, defining choices`,
        'The full scope of everything is revealed',
        'Consequences of all player choices manifest',
      ],
    };

    return {
      phase: pacingData.phase,
      requirements: phaseRequirements[pacingData.phase] || phaseRequirements['RISING ACTION'],
    };
  }

  // ==========================================================================
  // TWO-PASS DECISION GENERATION
  // ==========================================================================

  /**
   * Generate decision structure first (Pass 1 of two-pass generation)
   * This ensures decisions are always complete and contextually appropriate,
   * preventing truncation from producing generic placeholder choices
   */
  async _generateDecisionStructure(context, chapter) {
    const { protagonist, setting } = ABSOLUTE_FACTS;
    const decisionPrompt = `You are planning a critical decision point for Chapter ${chapter} of "Dead Letters."

## CURRENT STORY STATE
${context.storySummary || `${protagonist.fullName} is investigating a pattern of symbols and disappearances in ${setting.city}.`}

## RECENT EVENTS
${context.previousChapterSummary || `${protagonist.fullName} received another dead letter with an impossible glyph string.`}

## ACTIVE NARRATIVE THREADS
${context.narrativeThreads?.filter(t => t.status === 'active').slice(0, 5).map(t => `- [${t.urgency}] ${t.description}`).join('\n') || '- No active threads'}

## PATH PERSONALITY
${protagonist.fullName} has been playing ${context.pathPersonality?.narrativeStyle || 'a balanced approach'}.
Risk tolerance: ${context.pathPersonality?.riskTolerance || 'moderate'}

## CHAPTER BEAT TYPE
This chapter's required beat: ${STORY_STRUCTURE.chapterBeatTypes?.[chapter] || 'STANDARD'}

## YOUR TASK
Design a meaningful binary decision that:
1. Emerges naturally from the story situation
2. Has NO obvious "right" answer - both options have real costs
3. Connects to themes of certainty vs doubt, perception vs reality, and the cost of following a pattern
4. Fits the player's established personality while challenging them
5. Creates genuinely different story branches

Generate the decision structure FIRST. This will guide the narrative that leads to it.`;

    console.log(`[StoryGenerationService] Two-pass generation: Generating decision structure for Chapter ${chapter}`);

    const response = await llmService.complete(
      [{ role: 'user', content: decisionPrompt }],
      {
        systemPrompt: 'You are a narrative designer creating morally complex choices for a mystery thriller. Every decision must have real stakes and no clear "correct" answer.',
        maxTokens: GENERATION_CONFIG.maxTokens.outline,
        responseSchema: DECISION_ONLY_SCHEMA,
      }
    );

    try {
      const parsed = typeof response.content === 'string'
        ? JSON.parse(response.content)
        : response.content;

      console.log(`[StoryGenerationService] Decision structure generated: "${parsed.decision?.optionA?.title}" vs "${parsed.decision?.optionB?.title}"`);

      return parsed;
    } catch (error) {
      console.error('[StoryGenerationService] Failed to parse decision structure:', error);
      // Return a valid fallback structure
      return {
        decisionContext: 'Jack faces an impossible choice.',
        decision: {
          intro: 'The evidence points in two directions, and time is running out.',
          optionA: {
            key: 'A',
            title: 'Take direct action now',
            focus: 'Prioritizes immediate resolution and confrontation. Risks escalating the situation before all facts are known.',
            personalityAlignment: 'aggressive',
            narrativeSetup: 'The tension builds to a breaking point where waiting feels impossible.',
          },
          optionB: {
            key: 'B',
            title: 'Gather more evidence first',
            focus: 'Prioritizes thorough investigation and certainty. Risks letting the trail go cold or enemies preparing.',
            personalityAlignment: 'methodical',
            narrativeSetup: 'New information suggests there may be more to uncover.',
          },
        },
        keyMoments: ['Building tension', 'Key revelation', 'Forced choice'],
        emotionalArc: 'Tension building to difficult choice',
      };
    }
  }

  /**
   * Build prompt for narrative generation with pre-determined decision (Pass 2)
   */
  _buildDecisionNarrativePrompt(context, chapter, subchapter, decisionStructure) {
    const basePrompt = this._buildGenerationPrompt(context, chapter, subchapter, true);

    const decisionGuidance = `

## PRE-DETERMINED DECISION (Your narrative MUST lead to this exact choice)
The following decision has already been designed. Your narrative must naturally build toward it.

### DECISION INTRO (Use this exact text or very close variation):
"${decisionStructure.decision.intro}"

### OPTION A: "${decisionStructure.decision.optionA.title}"
- Focus: ${decisionStructure.decision.optionA.focus}
- Personality: ${decisionStructure.decision.optionA.personalityAlignment}
- Narrative setup: ${decisionStructure.decision.optionA.narrativeSetup}

### OPTION B: "${decisionStructure.decision.optionB.title}"
- Focus: ${decisionStructure.decision.optionB.focus}
- Personality: ${decisionStructure.decision.optionB.personalityAlignment}
- Narrative setup: ${decisionStructure.decision.optionB.narrativeSetup}

### KEY MOMENTS TO INCLUDE:
${decisionStructure.keyMoments.map((m, i) => `${i + 1}. ${m}`).join('\n')}

### EMOTIONAL ARC:
${decisionStructure.emotionalArc}

### CRITICAL INSTRUCTION:
Copy the decision object EXACTLY as provided above into your response. Do not modify the decision titles, focus, or intro. Your narrative should make these choices feel earned and natural, but the decision text itself is FIXED.`;

    return basePrompt + decisionGuidance;
  }

  // ==========================================================================
  // THREAD NORMALIZATION - Prevents duplicate threads across paths
  // Uses semantic similarity for fuzzy matching of equivalent threads
  // ==========================================================================

  /**
   * Synonym groups for semantic thread matching
   * Verbs in the same group are treated as equivalent for deduplication
   */
  static VERB_SYNONYM_GROUPS = [
    // Meeting/Encounter synonyms
    ['meet', 'see', 'visit', 'rendezvous', 'encounter', 'come', 'arrive', 'show'],
    // Promise/Agreement synonyms
    ['promise', 'agree', 'commit', 'vow', 'swear', 'pledge', 'guarantee', 'assure'],
    // Investigation synonyms
    ['investigate', 'search', 'look', 'examine', 'check', 'probe', 'dig', 'explore'],
    // Confrontation synonyms
    ['confront', 'face', 'challenge', 'accuse', 'question', 'interrogate', 'press'],
    // Following/Tracking synonyms
    ['follow', 'track', 'tail', 'shadow', 'pursue', 'watch', 'observe', 'surveil'],
    // Communication synonyms
    ['call', 'phone', 'contact', 'reach', 'message', 'notify', 'inform', 'tell'],
    // Discovery synonyms
    ['find', 'discover', 'uncover', 'reveal', 'learn', 'realize', 'determine'],
    // Threat synonyms
    ['threaten', 'warn', 'intimidate', 'menace', 'pressure', 'coerce'],
  ];

  /**
   * Location synonym groups for semantic matching
   */
  static LOCATION_SYNONYM_GROUPS = [
    ['docks', 'pier', 'wharf', 'harbor', 'waterfront', 'marina', 'port'],
    ['warehouse', 'building', 'factory', 'facility', 'plant'],
    ['office', 'room', 'study', 'workspace'],
    ['bar', 'pub', 'tavern', 'murphy', 'saloon'],
    ['prison', 'jail', 'greystone', 'cell', 'penitentiary'],
    ['alley', 'alleyway', 'backstreet', 'passage'],
    ['apartment', 'flat', 'residence', 'home', 'place'],
  ];

  /**
   * Stem common verb endings to base form
   */
  _stemVerb(word) {
    if (!word) return word;
    const w = word.toLowerCase();

    // Handle common verb forms
    if (w.endsWith('ing')) return w.slice(0, -3).replace(/([^aeiou])$/, '$1'); // meeting -> meet
    if (w.endsWith('ed') && w.length > 4) return w.slice(0, -2).replace(/i$/, 'y'); // promised -> promis -> promise handled below
    if (w.endsWith('ied')) return w.slice(0, -3) + 'y'; // tried -> try
    if (w.endsWith('es') && w.length > 4) return w.slice(0, -2); // watches -> watch
    if (w.endsWith('s') && !w.endsWith('ss') && w.length > 3) return w.slice(0, -1); // meets -> meet

    // Fix common stemming artifacts
    const fixes = {
      'promis': 'promise', 'agre': 'agree', 'arriv': 'arrive',
      'observ': 'observe', 'investigat': 'investigate', 'determin': 'determine',
      'realiz': 'realize', 'pressur': 'pressure', 'threaten': 'threaten',
    };
    return fixes[w] || w;
  }

  /**
   * Get the canonical verb for a given verb (using synonym groups)
   */
  _getCanonicalVerb(verb) {
    const stemmed = this._stemVerb(verb);
    for (const group of StoryGenerationService.VERB_SYNONYM_GROUPS) {
      if (group.some(v => v === stemmed || stemmed.includes(v) || v.includes(stemmed))) {
        return group[0]; // Return the canonical (first) verb in group
      }
    }
    return stemmed;
  }

  /**
   * Get the canonical location for a given location (using synonym groups)
   */
  _getCanonicalLocation(location) {
    const loc = location.toLowerCase();
    for (const group of StoryGenerationService.LOCATION_SYNONYM_GROUPS) {
      if (group.some(l => loc.includes(l) || l.includes(loc))) {
        return group[0]; // Return the canonical (first) location in group
      }
    }
    return loc;
  }

  /**
   * Normalize a thread to a canonical ID for deduplication
   * Format: {type}:{sorted_entities}:{canonical_action}:{canonical_location}:{time_bucket}
   *
   * Uses semantic normalization:
   * - Verbs are stemmed and mapped to canonical synonyms
   * - Locations are mapped to canonical synonyms
   * - Time references are bucketed (morning/noon/evening/night)
   */
  _normalizeThreadId(thread) {
    if (!thread || !thread.description) return null;

    const type = thread.type || 'unknown';
    const description = thread.description.toLowerCase();

    // Extract canonical character names mentioned in the thread
    // Only Jack and Victoria are canonical - other character names are LLM-generated
    const canonicalCharacters = ['jack', 'victoria', 'blackwell'];

    const mentionedCharacters = canonicalCharacters
      .filter(name => description.includes(name))
      .sort();

    // Extract and canonicalize action verbs
    const actionPattern = /\b(meet|see|visit|visit|come|arrive|show|promise|agree|commit|vow|swear|pledge|investigate|search|look|examine|check|confront|face|challenge|accuse|question|interrogate|follow|track|tail|shadow|pursue|watch|observe|call|phone|contact|reach|message|find|discover|uncover|reveal|learn|threaten|warn|intimidate|meeting|seeing|visiting|coming|arriving|promising|agreeing|investigating|searching|confronting|following|tracking|calling|finding|discovering|threatening)[a-z]*/gi;
    const foundActions = description.match(actionPattern) || [];
    const canonicalActions = [...new Set(foundActions.map(a => this._getCanonicalVerb(a)))].sort();

    // Extract time references and bucket them
    const timeBuckets = {
      morning: /\b(morning|dawn|sunrise|am|breakfast|early)\b/i,
      noon: /\b(noon|midday|lunch|afternoon)\b/i,
      evening: /\b(evening|sunset|dusk|dinner|pm)\b/i,
      night: /\b(night|midnight|late|tonight)\b/i,
      tomorrow: /\b(tomorrow|next day)\b/i,
    };

    let timeBucket = null;
    for (const [bucket, pattern] of Object.entries(timeBuckets)) {
      if (pattern.test(description)) {
        timeBucket = bucket;
        break;
      }
    }

    // Extract and canonicalize location references
    const locations = [
      'docks', 'pier', 'wharf', 'warehouse', 'office', 'precinct', 'greystone', 'prison',
      'bar', 'murphy', 'apartment', 'morgue', 'courthouse', 'alley', 'waterfront',
      'harbor', 'building', 'factory', 'home', 'place', 'penthouse'
    ];
    const foundLocations = locations.filter(loc => description.includes(loc));
    const canonicalLocation = foundLocations.length > 0
      ? this._getCanonicalLocation(foundLocations[0])
      : null;

    // Build normalized ID with canonical forms
    const parts = [type];
    if (mentionedCharacters.length > 0) parts.push(mentionedCharacters.join(','));
    if (canonicalActions.length > 0) parts.push(canonicalActions[0]); // Primary canonical action
    if (canonicalLocation) parts.push(canonicalLocation);
    if (timeBucket) parts.push(timeBucket);

    return parts.join(':');
  }

  /**
   * Calculate semantic similarity score between two threads (0-1)
   * Used for fuzzy matching when normalized IDs don't match exactly
   */
  _calculateThreadSimilarity(thread1, thread2) {
    if (!thread1?.description || !thread2?.description) return 0;

    const desc1 = thread1.description.toLowerCase();
    const desc2 = thread2.description.toLowerCase();

    let score = 0;
    let factors = 0;

    // Same type is a strong signal
    if (thread1.type === thread2.type) {
      score += 0.3;
    }
    factors += 0.3;

    // Extract and compare canonical characters
    // Only Jack and Victoria are canonical - other character names are LLM-generated
    const canonicalCharacters = ['jack', 'victoria', 'blackwell'];

    const chars1 = new Set(canonicalCharacters.filter(c => desc1.includes(c)));
    const chars2 = new Set(canonicalCharacters.filter(c => desc2.includes(c)));
    const charIntersection = [...chars1].filter(c => chars2.has(c)).length;
    const charUnion = new Set([...chars1, ...chars2]).size;

    if (charUnion > 0) {
      score += 0.35 * (charIntersection / charUnion); // Jaccard similarity for characters
    }
    factors += 0.35;

    // Compare canonical actions
    const actionPattern = /\b(meet|see|visit|promise|agree|investigate|search|confront|follow|track|call|find|discover|threaten|watch|observe)[a-z]*/gi;
    const actions1 = [...new Set((desc1.match(actionPattern) || []).map(a => this._getCanonicalVerb(a)))];
    const actions2 = [...new Set((desc2.match(actionPattern) || []).map(a => this._getCanonicalVerb(a)))];

    const actionIntersection = actions1.filter(a => actions2.includes(a)).length;
    const actionUnion = new Set([...actions1, ...actions2]).size;

    if (actionUnion > 0) {
      score += 0.25 * (actionIntersection / actionUnion);
    }
    factors += 0.25;

    // Compare locations
    const locations = [
      'docks', 'pier', 'warehouse', 'office', 'precinct', 'greystone', 'prison',
      'bar', 'apartment', 'morgue', 'courthouse', 'alley', 'waterfront'
    ];
    const locs1 = locations.filter(l => desc1.includes(l)).map(l => this._getCanonicalLocation(l));
    const locs2 = locations.filter(l => desc2.includes(l)).map(l => this._getCanonicalLocation(l));

    if (locs1.length > 0 && locs2.length > 0) {
      const locMatch = locs1.some(l1 => locs2.includes(l1));
      if (locMatch) score += 0.1;
    }
    factors += 0.1;

    return score / factors; // Normalize to 0-1
  }

  /**
   * Deduplicate threads using normalized IDs AND semantic similarity
   * Two-pass approach: exact match first, then fuzzy match for remaining
   */
  _deduplicateThreads(threads) {
    if (!threads || threads.length === 0) return [];

    const seen = new Map();
    const deduplicated = [];
    const urgencyRank = { critical: 3, normal: 2, background: 1 };

    // PASS 1: Exact normalized ID matching
    for (const thread of threads) {
      const normalizedId = this._normalizeThreadId(thread);

      if (!normalizedId) {
        deduplicated.push(thread);
        continue;
      }

      if (!seen.has(normalizedId)) {
        seen.set(normalizedId, thread);
        thread._normalizedId = normalizedId;
        deduplicated.push(thread);
      } else {
        // Merge: keep the more urgent version, or the more recent if equal urgency
        const existing = seen.get(normalizedId);

        const urgencyA = (urgencyRank[thread.urgency] || 0);
        const urgencyB = (urgencyRank[existing.urgency] || 0);
        const isNewer = (thread.chapter > existing.chapter) ||
          (thread.chapter === existing.chapter && (thread.subchapter || 0) > (existing.subchapter || 0));

        if (urgencyA > urgencyB || (urgencyA === urgencyB && isNewer)) {
          const idx = deduplicated.indexOf(existing);
          if (idx !== -1) {
            thread._normalizedId = normalizedId;
            deduplicated[idx] = thread;
            seen.set(normalizedId, thread);
          }
        }

        console.log(`[StoryGenerationService] Deduplicated thread (exact): "${thread.description?.slice(0, 50)}..." (normalized: ${normalizedId})`);
      }
    }

    // PASS 2: Semantic similarity matching for remaining duplicates
    // Only run if we have enough threads to warrant the cost
    if (deduplicated.length > 3) {
      const SIMILARITY_THRESHOLD = 0.75; // Threads with >75% similarity are considered duplicates
      const toRemove = new Set();

      for (let i = 0; i < deduplicated.length; i++) {
        if (toRemove.has(i)) continue;

        for (let j = i + 1; j < deduplicated.length; j++) {
          if (toRemove.has(j)) continue;

          // Skip if already matched by normalized ID
          if (deduplicated[i]._normalizedId === deduplicated[j]._normalizedId) continue;

          const similarity = this._calculateThreadSimilarity(deduplicated[i], deduplicated[j]);

          if (similarity >= SIMILARITY_THRESHOLD) {
            // Keep the more urgent one, or the first one if equal urgency
            const urgencyI = urgencyRank[deduplicated[i].urgency] || 0;
            const urgencyJ = urgencyRank[deduplicated[j].urgency] || 0;

            if (urgencyJ > urgencyI) {
              toRemove.add(i);
              console.log(`[StoryGenerationService] Deduplicated thread (semantic ${(similarity * 100).toFixed(0)}%): "${deduplicated[i].description?.slice(0, 40)}..." ~= "${deduplicated[j].description?.slice(0, 40)}..."`);
            } else {
              toRemove.add(j);
              console.log(`[StoryGenerationService] Deduplicated thread (semantic ${(similarity * 100).toFixed(0)}%): "${deduplicated[j].description?.slice(0, 40)}..." ~= "${deduplicated[i].description?.slice(0, 40)}..."`);
            }
          }
        }
      }

      // Remove duplicates found in pass 2
      if (toRemove.size > 0) {
        return deduplicated.filter((_, idx) => !toRemove.has(idx));
      }
    }

    return deduplicated;
  }

  /**
   * Cap active threads to prevent state explosion
   * Keeps critical threads, most recent, and auto-resolves old background threads
   */
  _capActiveThreads(threads, maxThreads = 20) {
    if (!threads || threads.length <= maxThreads) return threads;

    // Separate by urgency
    const critical = threads.filter(t => t.urgency === 'critical' && t.status === 'active');
    const normal = threads.filter(t => t.urgency === 'normal' && t.status === 'active');
    const background = threads.filter(t => t.urgency === 'background' && t.status === 'active');
    const resolved = threads.filter(t => t.status !== 'active');

    // Always keep all critical threads
    const kept = [...critical];

    // Add normal threads up to limit
    const remainingSlots = maxThreads - kept.length;
    const normalToKeep = normal.slice(0, Math.min(normal.length, Math.ceil(remainingSlots * 0.6)));
    kept.push(...normalToKeep);

    // Add background threads with remaining slots
    const backgroundSlots = maxThreads - kept.length;
    const backgroundToKeep = background.slice(0, backgroundSlots);
    kept.push(...backgroundToKeep);

    // Auto-resolve old background threads that didn't make the cut
    const autoResolved = background.slice(backgroundSlots).map(t => ({
      ...t,
      status: 'resolved',
      _autoResolved: true,
      _autoResolveReason: 'Thread cap reached - background thread auto-closed',
    }));

    console.log(`[StoryGenerationService] Thread cap: kept ${kept.length}, auto-resolved ${autoResolved.length} background threads`);

    return [...kept, ...autoResolved, ...resolved];
  }

  // ==========================================================================
  // THREAD ARCHIVAL SYSTEM
  // ==========================================================================

  /**
   * Archive resolved threads to reduce active memory pressure
   * Stores compressed version of thread with minimal fields needed for callbacks
   * @param {Array} threads - Array of threads to process
   * @param {number} currentChapter - Current chapter number for age calculation
   */
  _archiveResolvedThreads(threads, currentChapter) {
    if (!threads || threads.length === 0) return threads;

    const activeThreads = [];
    const toArchive = [];

    for (const thread of threads) {
      // Keep active threads in main list
      if (thread.status === 'active') {
        activeThreads.push(thread);
        continue;
      }

      // Resolved/failed threads get archived
      if (thread.status === 'resolved' || thread.status === 'failed') {
        toArchive.push(thread);
      } else {
        // Unknown status - keep in active list to be safe
        activeThreads.push(thread);
      }
    }

    // Archive resolved threads with compression
    for (const thread of toArchive) {
      const compressedThread = {
        type: thread.type,
        description: thread.description?.slice(0, TRUNCATE_PREVIEW), // Truncate for context
        status: thread.status,
        resolvedChapter: thread.resolvedChapter || currentChapter,
        characters: thread.characters?.slice(0, 3) || [], // Keep max 3 characters
        originalChapter: thread.chapter,
      };

      // Check if similar thread already archived (avoid duplicates)
      const isDuplicate = this.archivedThreads.some(archived =>
        archived.type === compressedThread.type &&
        archived.description === compressedThread.description
      );

      if (!isDuplicate) {
        this.archivedThreads.push(compressedThread);
      }
    }

    if (toArchive.length > 0) {
      console.log(`[StoryGenerationService] Archived ${toArchive.length} resolved threads (archive size: ${this.archivedThreads.length})`);
    }

    // Prune old archived threads based on chapter distance
    this._pruneArchivedThreads(currentChapter);

    return activeThreads;
  }

  /**
   * Prune archived threads that are too old to be relevant for callbacks
   * Keeps threads within archiveChapterRetention chapters of resolution
   */
  _pruneArchivedThreads(currentChapter) {
    const originalCount = this.archivedThreads.length;

    // Remove threads resolved more than N chapters ago
    this.archivedThreads = this.archivedThreads.filter(thread => {
      const chapterDistance = currentChapter - (thread.resolvedChapter || 0);
      return chapterDistance <= this.archiveChapterRetention;
    });

    // Also cap total archive size
    if (this.archivedThreads.length > this.maxArchivedThreads) {
      // Sort by resolution chapter (oldest first) and remove oldest
      this.archivedThreads.sort((a, b) => (a.resolvedChapter || 0) - (b.resolvedChapter || 0));
      this.archivedThreads = this.archivedThreads.slice(-this.maxArchivedThreads);
    }

    const pruned = originalCount - this.archivedThreads.length;
    if (pruned > 0) {
      console.log(`[StoryGenerationService] Pruned ${pruned} old archived threads (remaining: ${this.archivedThreads.length})`);
    }
  }

  // ==========================================================================
  // GENERATION CONCURRENCY CONTROL
  // ==========================================================================

  /**
   * Wait for a generation slot to become available
   * Called when we're at maxConcurrentGenerations capacity
   */
  async _waitForGenerationSlot(generationKey) {
    return new Promise((resolve, reject) => {
      this.generationWaitQueue.push({ resolve, reject, key: generationKey });
      console.log(`[StoryGenerationService] Generation ${generationKey} queued (${this.generationWaitQueue.length} waiting, ${this.activeGenerationCount}/${this.maxConcurrentGenerations} active)`);
    });
  }

  /**
   * Acquire a generation slot, waiting if necessary
   * Returns true when slot is acquired
   * Throws if queue is too long (prevents queue explosion from aggressive prefetching)
   */
  async _acquireGenerationSlot(generationKey) {
    // Prevent queue explosion - reject if queue is already too long
    const MAX_QUEUE_SIZE = 6; // Allow some queuing but prevent explosion
    if (this.generationWaitQueue.length >= MAX_QUEUE_SIZE) {
      console.warn(`[StoryGenerationService] Queue full (${this.generationWaitQueue.length} waiting), rejecting ${generationKey}`);
      throw new Error(`Generation queue full - try again later`);
    }

    if (this.activeGenerationCount < this.maxConcurrentGenerations) {
      this.activeGenerationCount++;
      console.log(`[StoryGenerationService] Acquired slot for ${generationKey} (${this.activeGenerationCount}/${this.maxConcurrentGenerations} active)`);
      return;
    }

    // At capacity - wait for a slot (sequential mode means waiting for current to finish)
    await this._waitForGenerationSlot(generationKey);
    this.activeGenerationCount++;
    console.log(`[StoryGenerationService] Acquired slot after wait for ${generationKey} (${this.activeGenerationCount}/${this.maxConcurrentGenerations} active)`);
  }

  /**
   * Release a generation slot and process next in queue
   */
  _releaseGenerationSlot(generationKey) {
    this.activeGenerationCount = Math.max(0, this.activeGenerationCount - 1);
    console.log(`[StoryGenerationService] Released slot for ${generationKey} (${this.activeGenerationCount}/${this.maxConcurrentGenerations} active, ${this.generationWaitQueue.length} waiting)`);

    // Process next waiting generation if any
    if (this.generationWaitQueue.length > 0) {
      const next = this.generationWaitQueue.shift();
      console.log(`[StoryGenerationService] Unblocking queued generation: ${next.key}`);
      next.resolve();
    }
  }

  // ==========================================================================
  // GENERATION AND VALIDATION
  // ==========================================================================

  /**
   * Generate a single subchapter with validation
   * Now integrates Story Arc Planning and Chapter Outlines for 100% consistency
   * Decision points use two-pass generation to ensure complete, contextual choices
   */
  async generateSubchapter(chapter, subchapter, pathKey, choiceHistory = [], options = {}) {
    if (!llmService.isConfigured()) {
      throw new Error('LLM Service not configured. Please set an API key in settings.');
    }

    // Only Chapter 1A is static; 1B and 1C are dynamically generated like all other B/C subchapters
    if (chapter === 1 && subchapter === 1) {
      throw new Error('Chapter 1A uses static content and should not be generated.');
    }

    const caseNumber = formatCaseNumber(chapter, subchapter);

    // IMPORTANT: Use the cumulative branch key for this chapter, derived from choiceHistory.
    // The incoming pathKey may be a legacy "A"/"B" token; we do not trust it for storage keys.
    const effectivePathKey = this._getPathKeyForChapter(chapter, choiceHistory);
    const generationKey = `${caseNumber}_${effectivePathKey}`;
    const traceId = options?.traceId || createTraceId(`sg_${caseNumber}_${pathKey}`);
    const reason = options?.reason || 'unspecified';

    // CRITICAL: Distinguish between user-facing and background generation
    // User-facing = player is actively waiting (clicked Continue)
    // Background = prefetching for future use
    // If user-facing, we NEVER show fallback - we throw errors and let UI handle retry
    const isUserFacing = options?.isUserFacing || false;

    // TRUE INFINITE BRANCHING: Get player's actual choices within subchapters
    // This tracks which path the player took through branching narratives (e.g., "1B" -> "1B-2C")
    // Used to build the "realized narrative" for context - what the player actually experienced
    const branchingChoices = options?.branchingChoices || [];

    // Store branchingChoices on instance so helper functions can access player's actual path
    // This enables _getPathDecisionData to look up path-specific decisions correctly
    this.currentBranchingChoices = branchingChoices;

    // Deduplication: Return existing promise if generation is already in flight for this exact content
    // But first check if the cached promise is stale (older than 3 minutes) - if so, discard it
    const MAX_PENDING_AGE_MS = 3 * 60 * 1000; // 3 minutes
    if (this.pendingGenerations.has(generationKey)) {
      const cachedPromise = this.pendingGenerations.get(generationKey);
      const promiseAge = Date.now() - (cachedPromise._createdAt || 0);

      if (promiseAge > MAX_PENDING_AGE_MS) {
        // Promise is stale - likely hung or failed silently. Remove it and create a new one.
        console.warn(`[StoryGenerationService] Pending generation for ${generationKey} is stale (${Math.round(promiseAge / 1000)}s old). Discarding and retrying.`);
        llmTrace('StoryGenerationService', traceId, 'generation.dedupe.stale', {
          generationKey,
          caseNumber,
          pathKey,
          ageMs: promiseAge,
          reason
        }, 'warn');
        this.pendingGenerations.delete(generationKey);
        // Fall through to create a new generation
      } else {
        // Promise is still fresh - reuse it
        console.log(`[StoryGenerationService] Reusing pending generation for ${generationKey}`);
        llmTrace('StoryGenerationService', traceId, 'generation.dedupe.hit', { generationKey, caseNumber, pathKey, reason }, 'debug');
        return cachedPromise;
      }
    }

    // Acquire a generation slot (waits if at capacity)
    await this._acquireGenerationSlot(generationKey);

    // After waiting for slot, check if content was generated by another request
    // This prevents duplicate generation when multiple requests queue for the same content
    const existingAfterWait = await this.getGeneratedEntryAsync(caseNumber, effectivePathKey);
    if (existingAfterWait) {
      console.log(`[StoryGenerationService] Content already exists after wait for ${generationKey}, skipping generation`);
      llmTrace('StoryGenerationService', traceId, 'generation.skip.existsAfterWait', {
        generationKey,
        caseNumber,
        pathKey: effectivePathKey,
      }, 'info');
      this._releaseGenerationSlot(generationKey);
      return existingAfterWait;
    }

    const generationPromise = (async () => {
      const isDecisionPoint = subchapter === DECISION_SUBCHAPTER;
      llmTrace('StoryGenerationService', traceId, 'generation.start', {
        generationKey,
        caseNumber,
        chapter,
        subchapter,
        isDecisionPoint,
        pathKey,
        choiceHistoryLength: choiceHistory?.length || 0,
        reason,
      }, 'info');

      // ========== NEW: Story Arc Planning Integration ==========
      // Ensure we have the global story arc for narrative consistency
      await this.ensureStoryArc(choiceHistory);

      // Periodic cleanup of in-memory Maps to prevent leaks in long sessions
      // Run at the start of each chapter (subchapter A) to avoid overhead
      if (subchapter === 1) {
        this.pruneInMemoryMaps(effectivePathKey, chapter);
      }

      // Ensure we have the chapter outline for seamless subchapter flow
      const chapterOutline = await this.ensureChapterOutline(chapter, choiceHistory);

      // ========== NEW: Dynamic Consequence Generation ==========
      // If this follows a decision, ensure we have generated consequences
      if (choiceHistory.length > 0) {
        // Keep gameplay fast: hydrate consequences without extra LLM calls.
        this._ensureDecisionConsequencesFast(choiceHistory);
        if (GENERATION_CONFIG.qualitySettings?.enableLLMDecisionConsequences) {
          // Optional, expensive improvement. Never block core narrative generation.
          this._ensureDecisionConsequences(choiceHistory).catch((e) => {
            console.warn('[StoryGenerationService] Background consequence generation failed:', e?.message);
          });
        }
      }

      // Build comprehensive context (now includes story arc and chapter outline)
      // TRUE INFINITE BRANCHING: Pass branchingChoices to build realized narrative from player's actual path
      const branchingChoicesForContext = branchingChoices || [];
      console.log(`[StoryGenerationService] 📖 Building context for ${caseNumber}:`, {
        pathKey: effectivePathKey,
        branchingChoicesCount: branchingChoicesForContext.length,
        branchingChoices: branchingChoicesForContext.map(bc => `${bc.caseNumber}:${bc.firstChoice}->${bc.secondChoice}`).join(', ') || '(none)',
      });
      const context = await this.buildStoryContext(chapter, subchapter, effectivePathKey, choiceHistory, branchingChoices);

      // Apply thread normalization, capping, and archival to prevent state explosion
      if (context.narrativeThreads) {
        context.narrativeThreads = this._deduplicateThreads(context.narrativeThreads);
        context.narrativeThreads = this._capActiveThreads(context.narrativeThreads, 20);
        // Archive resolved threads to reduce memory while preserving callback potential
        context.narrativeThreads = this._archiveResolvedThreads(context.narrativeThreads, chapter);
      }

      // Add story arc and chapter outline to context
      context.storyArc = this.storyArc;
      context.chapterOutline = chapterOutline;

      this.isGenerating = true;
      try {
        let generatedContent;

        // ========== SINGLE-PASS GENERATION WITH CONTEXT CACHING ==========
        // Decision schema has decision field BEFORE narrative, so decision is generated first
        // This eliminates the need for two-pass generation while ensuring complete decisions

        const schema = isDecisionPoint ? DECISION_CONTENT_SCHEMA : STORY_CONTENT_SCHEMA;
        let response;

        // Try cached generation first (works in both proxy and direct mode)
        try {
          // Prefer a chapter-start cache (static + story up to previous chapter) to reduce prompt size.
          // Falls back to the static-only cache if chapter-start caching fails for any reason.
          let cacheKey;
          try {
            cacheKey = await this._ensureChapterStartCache(chapter, effectivePathKey, choiceHistory, context);
          } catch (e) {
            console.warn('[StoryGenerationService] ⚠️ Chapter-start cache unavailable, falling back to static cache:', e?.message);
            cacheKey = await this._ensureStaticCache();
          }

          // Build only dynamic prompt (delta context + current state + task).
          // If cacheKey is a chapter-start cache, omit story history up to previous chapter.
          const usingChapterStartCache = typeof cacheKey === 'string' && cacheKey.startsWith(`story_chStart_c${chapter}_`);
          const dynamicPrompt = this._buildDynamicPrompt(
            context,
            chapter,
            subchapter,
            isDecisionPoint,
            usingChapterStartCache ? { cachedHistoryMaxChapter: chapter - 1 } : {}
          );

          // ========== THOUGHT SIGNATURE CONTINUITY (Gemini 3) ==========
          // Retrieve previous thought signature for reasoning chain continuity
          const prevThoughtSignature = this._getPreviousThoughtSignature(chapter, subchapter, effectivePathKey);

          // Build prior messages with thought signature if available
          const priorMessages = [];
          if (prevThoughtSignature && context.previousChapters?.length > 0) {
            const lastChapter = context.previousChapters[context.previousChapters.length - 1];
            const prevNarrativeSummary = lastChapter?.narrative
              ? `Previous scene summary: ${lastChapter.narrative.slice(0, TRUNCATE_SUMMARY)}...`
              : 'Continuing the story...';
            priorMessages.push({ role: 'model', content: prevNarrativeSummary, thoughtSignature: prevThoughtSignature });
          }

          console.log(`[StoryGenerationService] ✅ Cached generation for Chapter ${chapter}.${subchapter}${prevThoughtSignature ? ' (with thought signature)' : ''}`);
          llmTrace('StoryGenerationService', traceId, 'prompt.built', {
            caseNumber,
            pathKey,
            chapter,
            subchapter,
            isDecisionPoint,
            cacheKey,
            cachingEnabled: true,
            dynamicPromptLength: dynamicPrompt?.length || 0,
            hasThoughtSignatureFromPrevious: !!prevThoughtSignature,
            schema: isDecisionPoint ? 'DECISION_CONTENT_SCHEMA' : 'STORY_CONTENT_SCHEMA',
            contextSummary: {
              previousChapters: context?.previousChapters?.length || 0,
              establishedFacts: context?.establishedFacts?.length || 0,
              playerChoices: context?.playerChoices?.length || 0,
              narrativeThreads: context?.narrativeThreads?.length || 0,
            },
            reason,
          }, 'debug');

          // Log the complete prompt for debugging
          this._logCompletePrompt({
            caseNumber,
            chapter,
            subchapter,
            cacheKey,
            dynamicPrompt,
            isCached: true,
          });

          response = await llmService.completeWithCache({
            cacheKey,
            dynamicPrompt,
            priorMessages,
            options: {
              maxTokens: GENERATION_CONFIG.maxTokens.subchapter,
              responseSchema: schema,
              thinkingConfig: {
                includeThoughts: process.env.INCLUDE_THOUGHTS === 'true', // Enable in dev to debug mystery logic
                thinkingLevel: 'high' // Maximize reasoning depth for complex narrative generation
              }
            },
          });
        } catch (cacheError) {
          console.warn(`[StoryGenerationService] ⚠️ Caching failed:`, cacheError.message);
          console.warn(`[StoryGenerationService] Falling back to non-cached generation`);
          // Fall through to non-cached generation
          response = null;
        }

        // Fallback: Use regular generation if caching failed
        if (!response) {
          console.log(`[StoryGenerationService] Regular generation for Chapter ${chapter}.${subchapter} (no caching)`);

          const prompt = this._buildGenerationPrompt(context, chapter, subchapter, isDecisionPoint);

          // ========== THOUGHT SIGNATURE CONTINUITY (Gemini 3) ==========
          // Per Gemini 3 docs: thought signatures maintain reasoning chain across multi-turn conversations.
          // Retrieve the thought signature from the previous subchapter and include it in the conversation.
          const prevThoughtSignature = this._getPreviousThoughtSignature(chapter, subchapter, effectivePathKey);

          // Build messages with thought signature if available
          // The thought signature must be attached to a model message with representative previous content
          const messages = [];
          if (prevThoughtSignature && context.previousChapters?.length > 0) {
            // Get a summary of the previous narrative for context
            const lastChapter = context.previousChapters[context.previousChapters.length - 1];
            const prevNarrativeSummary = lastChapter?.narrative
              ? `Previous scene summary: ${lastChapter.narrative.slice(0, TRUNCATE_SUMMARY)}...`
              : 'Continuing the story...';
            messages.push({ role: 'model', content: prevNarrativeSummary, thoughtSignature: prevThoughtSignature });
          }
          messages.push({ role: 'user', content: prompt });

          llmTrace('StoryGenerationService', traceId, 'prompt.built', {
            caseNumber,
            pathKey,
            chapter,
            subchapter,
            isDecisionPoint,
            cachingEnabled: false,
            promptLength: prompt?.length || 0,
            hasThoughtSignatureFromPrevious: !!prevThoughtSignature,
            schema: isDecisionPoint ? 'DECISION_CONTENT_SCHEMA' : 'STORY_CONTENT_SCHEMA',
            contextSummary: {
              previousChapters: context?.previousChapters?.length || 0,
              establishedFacts: context?.establishedFacts?.length || 0,
              playerChoices: context?.playerChoices?.length || 0,
              narrativeThreads: context?.narrativeThreads?.length || 0,
            },
            reason,
          }, 'debug');

          // Log the complete prompt for debugging
          this._logCompletePrompt({
            caseNumber,
            chapter,
            subchapter,
            fullPrompt: prompt,
            isCached: false,
          });

          response = await llmService.complete(
            messages,
            {
              systemPrompt: buildMasterSystemPrompt(),
              maxTokens: GENERATION_CONFIG.maxTokens.subchapter,
              responseSchema: schema,
              traceId,
              requestContext: {
                caseNumber,
                chapter,
                subchapter,
                pathKey,
                isDecisionPoint,
                hasThoughtSignatureFromPrevious: !!prevThoughtSignature,
                reason,
              },
            }
          );
        }

        // Capture thought signature for multi-call reasoning continuity (Gemini 3)
        const firstCallThoughtSignature = response?.thoughtSignature || null;

        // Log model thoughts if includeThoughts is enabled (debug mode)
        if (response?.candidates?.[0]?.content?.parts) {
          response.candidates[0].content.parts.forEach(part => {
            if (part.thought) {
              llmTrace('StoryGenerationService', traceId, 'model.reasoning', {
                thought: part.text,
                chapter,
                subchapter,
                thoughtType: 'narrative_planning'
              }, 'debug');
            }
          });
        }

        llmTrace('StoryGenerationService', traceId, 'llm.response.received', {
          model: response?.model,
          finishReason: response?.finishReason,
          isTruncated: response?.isTruncated,
          contentLength: response?.content?.length || 0,
          usage: response?.usage || null,
          hasThoughtSignature: !!firstCallThoughtSignature,
        }, 'debug');

        // Track token usage for first call
        this._trackTokenUsage(response?.usage, `Chapter ${chapter}.${subchapter} (main content)`);

        generatedContent = this._parseGeneratedContent(response.content, isDecisionPoint);
        llmTrace('StoryGenerationService', traceId, 'llm.response.parsed', {
          hasTitle: !!generatedContent?.title,
          narrativeLength: generatedContent?.narrative?.length || 0,
          hasBranchingNarrative: !!generatedContent?.branchingNarrative?.opening?.text,
          hasPathDecisions: !!generatedContent?.pathDecisions,
          hasSimpleDecision: !!generatedContent?.decision,
          hasBridgeText: !!generatedContent?.bridgeText,
          hasPreviously: !!generatedContent?.previously,
          hasPuzzleCandidates: Array.isArray(generatedContent?.puzzleCandidates),
        }, 'debug');

        // ========== SECOND CALL: Generate path-specific decisions ==========
        // If this is a decision point and we only have a simple decision (not full pathDecisions),
        // make a second API call with minimal schema to generate all 9 path-specific decisions
        if (isDecisionPoint && generatedContent.decision && !generatedContent.pathDecisions) {
          console.log(`[StoryGenerationService] 🔄 Making second API call for pathDecisions...`);
          llmTrace('StoryGenerationService', traceId, 'pathDecisions.secondCall.starting', {
            simpleDecisionIntro: generatedContent.decision?.intro?.slice(0, 100),
            optionATitle: generatedContent.decision?.optionA?.title,
            optionBTitle: generatedContent.decision?.optionB?.title,
          }, 'debug');

          try {
            // Build prompt using LABELS ONLY to avoid RECITATION safety filter
            // IMPORTANT: Do NOT echo back generated narrative content - this triggers RECITATION
            const bn = generatedContent.branchingNarrative || {};
            const firstChoiceOpts = bn.firstChoice?.options || [];
            const secondChoices = bn.secondChoices || [];

            // Helper to infer tone from choice label
            const inferTone = (label) => {
              const lower = (label || '').toLowerCase();
              if (lower.includes('confront') || lower.includes('demand') || lower.includes('force') || lower.includes('direct')) return 'aggressive/direct approach';
              if (lower.includes('investigate') || lower.includes('gather') || lower.includes('wait') || lower.includes('careful')) return 'cautious/methodical approach';
              return 'balanced approach';
            };

            // Build path summaries from the generated branching narrative
            // Uses the new 'summary' field (15-25 words each) instead of full narrative excerpts
            const pathSummaryMap = {};
            const pathSummaries = secondChoices.map((sc, scIdx) => {
              const afterChoice = sc.afterChoice || `1${String.fromCharCode(65 + scIdx)}`;
              const opts = sc.options || [];
              return opts.map((opt, optIdx) => {
                const pathKey = `${afterChoice}-2${String.fromCharCode(65 + optIdx)}`;
                const summary = opt.summary || `Player chose "${opt.label || 'an option'}"`;
                pathSummaryMap[pathKey] = summary;
                return `- ${pathKey}: ${summary}`;
              }).join('\n');
            }).join('\n');

            // Build richer structured notes without echoing full narrative (avoids RECITATION).
            // We include: per-path labels, summaries, evidence card labels, and extracted keywords.
            const extractKeywords = (text, max = 10) => {
              const STOP = new Set([
                'the','a','an','and','or','to','of','in','on','for','with','at','from','into','over','under','before','after',
                'he','she','they','him','her','them','his','their','its','this','that','these','those','as','is','be','been','being',
                'jack','halloway','now','then',
              ]);
              const tokens = String(text || '')
                .toLowerCase()
                .split(/[^a-z0-9]+/g)
                .map((t) => t.trim())
                .filter((t) => t && t.length >= 4 && !STOP.has(t));
              const uniq = [];
              for (const t of tokens) {
                if (!uniq.includes(t)) uniq.push(t);
                if (uniq.length >= max) break;
              }
              return uniq;
            };

            const getEvidenceCards = (details) => {
              const cards = [];
              const arr = Array.isArray(details) ? details : [];
              for (const d of arr) {
                const label = String(d?.evidenceCard || '').trim();
                if (label && !cards.includes(label)) cards.push(label);
              }
              return cards;
            };

            const firstChoiceByKey = {};
            for (const opt of firstChoiceOpts) {
              if (opt?.key) firstChoiceByKey[String(opt.key).toUpperCase()] = opt;
            }

            const pathStructuredNotes = secondChoices.map((sc) => {
              const afterChoice = String(sc.afterChoice || '').toUpperCase();
              const first = firstChoiceByKey[afterChoice] || null;
              const opts = Array.isArray(sc.options) ? sc.options : [];
              return opts.map((endOpt) => {
                const rawKey = String(endOpt?.key || '').toUpperCase();
                // Normalize keys if generator returned "2C" (we still want stable path keys in prompt)
                const normalizedKey = /^2[ABC]$/.test(rawKey) && /^1[ABC]$/.test(afterChoice) ? `${afterChoice}-${rawKey}` : rawKey;
                const evidenceCards = [
                  // NOTE: Use `bn` (generatedContent.branchingNarrative) in this scope.
                  // Referencing an undefined identifier here can break the whole second-call pipeline.
                  ...getEvidenceCards(bn?.opening?.details),
                  ...getEvidenceCards(first?.details),
                  ...getEvidenceCards(endOpt?.details),
                ].slice(0, 6);
                const combinedText = [
                  first?.label,
                  first?.summary,
                  endOpt?.label,
                  endOpt?.summary,
                  evidenceCards.join(' '),
                ].filter(Boolean).join(' | ');
                const keywords = extractKeywords(combinedText, 10);
                return [
                  `- ${normalizedKey}:`,
                  `  - firstChoiceLabel: "${first?.label || '?'}"`,
                  `  - firstChoiceSummary: "${first?.summary || inferTone(first?.label)}"`,
                  `  - endingLabel: "${endOpt?.label || '?'}"`,
                  `  - endingSummary: "${endOpt?.summary || pathSummaryMap[normalizedKey] || ''}"`,
                  `  - evidenceCards: [${evidenceCards.map((c) => `"${c}"`).join(', ')}]`,
                  `  - keywords: [${keywords.map((k) => `"${k}"`).join(', ')}]`,
                ].join('\n');
              }).join('\n');
            }).join('\n');

            const pathDecisionsPrompt = fillTemplate(
              PATHDECISIONS_PROMPT_TEMPLATE,
              {
                caseNumber: caseNumber || `${chapter}.${subchapter}`,
                chapter: String(chapter),
                subchapter: String(subchapter),
                // First choice options with labels and summaries (not full narrative)
                firstChoice1ALabel: firstChoiceOpts[0]?.label || 'Option 1A',
                firstChoice1ASummary: firstChoiceOpts[0]?.summary || inferTone(firstChoiceOpts[0]?.label),
                firstChoice1BLabel: firstChoiceOpts[1]?.label || 'Option 1B',
                firstChoice1BSummary: firstChoiceOpts[1]?.summary || inferTone(firstChoiceOpts[1]?.label),
                firstChoice1CLabel: firstChoiceOpts[2]?.label || 'Option 1C',
                firstChoice1CSummary: firstChoiceOpts[2]?.summary || inferTone(firstChoiceOpts[2]?.label),
                // Path summaries (15-25 words each, not full narrative content)
                pathSummaries: pathSummaries || 'Not available',
                pathStructuredNotes: pathStructuredNotes || 'Not available',
                // Simple decision base
                optionATitle: generatedContent.decision?.optionA?.title || 'Option A',
                optionAFocus: generatedContent.decision?.optionA?.focus || 'Not specified',
                optionBTitle: generatedContent.decision?.optionB?.title || 'Option B',
                optionBFocus: generatedContent.decision?.optionB?.focus || 'Not specified',
              },
              { label: 'PATHDECISIONS_PROMPT_TEMPLATE' }
            );

            // Log what context we're sending
            console.log(`[StoryGenerationService] 📋 pathDecisions second call context:`);
            console.log(`  - First choices: ${firstChoiceOpts.map(o => `"${o?.label || '?'}" (${o?.summary ? 'has summary' : 'no summary'})`).join(', ')}`);
            console.log(`  - Path summaries: ${secondChoices.reduce((sum, sc) => sum + (sc.options?.filter(o => o?.summary)?.length || 0), 0)}/9 have summaries`);
            console.log(`  - Base decision: "${generatedContent.decision?.optionA?.title}" vs "${generatedContent.decision?.optionB?.title}"`);
            console.log(`  - Prompt length: ${pathDecisionsPrompt.length} chars (uses summaries, not full narrative)`);

            // Single user message - start fresh conversation for pathDecisions
            //
            // Why we don't use the thoughtSignature from the first call:
            // Per Gemini docs, thought signatures should be returned with the EXACT content
            // that generated them. Including the full 33k+ char first response just to use
            // the signature would be expensive and hit context limits. Since signatures are
            // optional for non-function-call responses (only recommended, not required),
            // we start a fresh request with a minimal prompt instead.
            //
            // The RECITATION issue was caused by echoing large chunks of LLM-generated
            // narrative content back to the model, which triggered the anti-memorization
            // safety filter. Using short summaries (15-25 words each) instead of full
            // narrative excerpts (~300 words each) provides necessary context without
            // triggering the safety filter.
            const messages = [{ role: 'user', content: pathDecisionsPrompt }];

            const pathDecisionsStartTime = Date.now();

            // Retry logic for RECITATION - this can happen if content still triggers safety filter
            let pathDecisionsResponse = null;
            let retryAttempt = 0;
            const MAX_PATHDECISIONS_RETRIES = 2;

            while (retryAttempt < MAX_PATHDECISIONS_RETRIES) {
              pathDecisionsResponse = await llmService.complete(
                messages,
                {
                  // Use enhanced system prompt with story context, character info, and constraints
                  // This significantly improves path-decision quality by grounding the model in the narrative world
                  systemPrompt: buildPathDecisionsSystemPrompt(),
                  maxTokens: GENERATION_CONFIG.maxTokens.pathDecisions, // 16k tokens for complex branching + thinking
                  responseSchema: PATHDECISIONS_ONLY_SCHEMA,
                  // Use 'high' thinkingLevel for complex multi-path reasoning per Gemini 3 best practices
                  // This task requires understanding 9 different player journeys and deriving unique decisions
                  thinkingLevel: 'high',
                  traceId: traceId + '-pathDecisions' + (retryAttempt > 0 ? `-retry${retryAttempt}` : ''),
                  requestContext: {
                    caseNumber,
                    chapter,
                    subchapter,
                    pathKey,
                    secondCallFor: 'pathDecisions',
                    attempt: retryAttempt + 1,
                  },
                }
              );

              // Check for RECITATION - if so, retry with slightly modified prompt
              if (pathDecisionsResponse?.finishReason === 'RECITATION') {
                retryAttempt++;
                console.warn(`[StoryGenerationService] ⚠️ RECITATION detected on pathDecisions (attempt ${retryAttempt}/${MAX_PATHDECISIONS_RETRIES})`);
                if (retryAttempt < MAX_PATHDECISIONS_RETRIES) {
                  // Add uniqueness hint to prompt for retry
                  messages[0].content = pathDecisionsPrompt + `\n\nIMPORTANT: Generate ORIGINAL decision variants. Each path should have unique framing. Attempt ${retryAttempt + 1}.`;
                  await new Promise(r => setTimeout(r, 1000)); // Brief delay before retry
                }
              } else {
                break; // Success or other failure - exit retry loop
              }
            }

            const pathDecisionsElapsed = Date.now() - pathDecisionsStartTime;
            console.log(`[StoryGenerationService] ⏱️ pathDecisions second call completed in ${(pathDecisionsElapsed / 1000).toFixed(1)}s${retryAttempt > 0 ? ` (${retryAttempt} retries)` : ''}`);

            llmTrace('StoryGenerationService', traceId, 'pathDecisions.secondCall.received', {
              contentLength: pathDecisionsResponse?.content?.length || 0,
              finishReason: pathDecisionsResponse?.finishReason,
              elapsedMs: pathDecisionsElapsed,
              usage: pathDecisionsResponse?.usage || null,
              retryAttempts: retryAttempt,
            }, 'debug');

            // Track token usage for second call (pathDecisions)
            this._trackTokenUsage(pathDecisionsResponse?.usage, `Chapter ${chapter}.${subchapter} (pathDecisions)`);

            // Parse the pathDecisions response
            let pathDecisionsParsed;
            try {
              const rawContent = pathDecisionsResponse?.content;
              pathDecisionsParsed = rawContent ? (typeof rawContent === 'string' ? JSON.parse(rawContent) : rawContent) : null;
            } catch (parseErr) {
              console.warn(`[StoryGenerationService] ⚠️ Failed to parse pathDecisions JSON:`, parseErr.message);
              pathDecisionsParsed = null;
            }

            if (pathDecisionsParsed?.pathDecisions && Array.isArray(pathDecisionsParsed.pathDecisions)) {
              // Convert array format to object format for compatibility
              const pathDecisionsObj = {};
              for (const pd of pathDecisionsParsed.pathDecisions) {
                if (pd.pathKey) {
                  pathDecisionsObj[pd.pathKey] = {
                    intro: pd.intro,
                    optionA: pd.optionA,
                    optionB: pd.optionB,
                  };
                }
              }
              generatedContent.pathDecisions = pathDecisionsObj;

              // Detailed logging of all 9 pathDecisions
              console.log(`[StoryGenerationService] ✅ pathDecisions merged: ${Object.keys(pathDecisionsObj).length} paths`);
              console.log(`[StoryGenerationService] 📊 Path-specific decisions received:`);
              for (const [pathKey, decision] of Object.entries(pathDecisionsObj)) {
                console.log(`  - ${pathKey}: A="${decision.optionA?.title || '?'}" | B="${decision.optionB?.title || '?'}"`);
              }

              // No clamping/fallback here: per-path pathDecisions are authoritative by design.
              // If the model drifts, we allow it. This is still better than collapsing to one decision.

              llmTrace('StoryGenerationService', traceId, 'pathDecisions.secondCall.merged', {
                pathCount: Object.keys(pathDecisionsObj).length,
                paths: Object.keys(pathDecisionsObj),
                decisions: Object.fromEntries(
                  Object.entries(pathDecisionsObj).map(([k, v]) => [k, { optionA: v.optionA?.title, optionB: v.optionB?.title }])
                ),
              }, 'debug');
            } else {
              console.warn(`[StoryGenerationService] ⚠️ Second call didn't return valid pathDecisions, using simple decision fallback`);
            }
          } catch (secondCallError) {
            console.warn(`[StoryGenerationService] ⚠️ Second call for pathDecisions failed:`, secondCallError.message);
            llmTrace('StoryGenerationService', traceId, 'pathDecisions.secondCall.failed', {
              error: secondCallError.message,
            }, 'error');
            // Do not silently fall back for decision-point subchapters.
            // If pathDecisions cannot be generated, force a retry so the player doesn't see a collapsed decision set.
            const err = new Error(`Failed to generate pathDecisions: ${secondCallError.message}`);
            err.retryable = true;
            err.isPathDecisionsFailure = true;
            throw err;
          }
        }

        // Enforce: decision-point subchapters must have pathDecisions so the UI can show the correct
        // two-path decision set for the player's realized branching path.
        if (isDecisionPoint && !generatedContent.pathDecisions) {
          const err = new Error('Decision subchapter missing pathDecisions');
          err.retryable = true;
          err.isPathDecisionsFailure = true;
          throw err;
        }

        // Validate decision structure for decision points (path-specific decisions)
        if (isDecisionPoint && generatedContent.pathDecisions) {
          const pathKeys = Object.keys(generatedContent.pathDecisions);
          const sampleDecision = generatedContent.pathDecisions['1A-2A'] || generatedContent.pathDecisions[pathKeys[0]];
          console.log(`[StoryGenerationService] Path-specific decisions generated: ${pathKeys.length} paths, sample: "${sampleDecision?.optionA?.title}" vs "${sampleDecision?.optionB?.title}"`);
          llmTrace('StoryGenerationService', traceId, 'pathDecisions.generated', {
            pathCount: pathKeys.length,
            paths: pathKeys,
            samplePath: '1A-2A',
            sampleDecision: sampleDecision ? {
              optionA: { key: sampleDecision.optionA?.key, title: sampleDecision.optionA?.title },
              optionB: { key: sampleDecision.optionB?.key, title: sampleDecision.optionB?.title },
            } : null,
          }, 'debug');
        }

        // Build canonical narrative from branchingNarrative for validation/expansion
        // Uses opening + first choice (1A) + first ending (1A-2A) as the canonical path
        if (!generatedContent.narrative && generatedContent.branchingNarrative) {
          const bn = generatedContent.branchingNarrative;
          const parts = [];
          if (bn.opening?.text) parts.push(bn.opening.text);
          const firstOption = bn.firstChoice?.options?.find(o => o.key === '1A');
          if (firstOption?.response) parts.push(firstOption.response);
          const secondGroup = bn.secondChoices?.find(sc => sc.afterChoice === '1A');
          const secondOption = secondGroup?.options?.find(o => o.key === '1A-2A');
          if (secondOption?.response) parts.push(secondOption.response);
          generatedContent.narrative = parts.join('\n\n');
        }

        // Word count check - log but DO NOT expand
        // Expansion was causing text corruption (duplicate content, mid-word cuts like "ike taffy")
        // Shorter stories are preferable to corrupted text
        const wordCount = generatedContent.narrative?.split(/\s+/).length || 0;
        if (wordCount < MIN_WORDS_PER_SUBCHAPTER) {
          console.log(`[StoryGenerationService] Word count ${wordCount} below minimum ${MIN_WORDS_PER_SUBCHAPTER}, proceeding without expansion (expansion disabled)`);
        }

        // Validate consistency (check for obvious violations)
        // FIRST: Fix simple typos locally without LLM call
        generatedContent = this._fixTyposLocally(generatedContent);

        let validationResult = this._validateConsistency(generatedContent, context);
        const qualitySettings = GENERATION_CONFIG?.qualitySettings || {};
        const enableProseQualityValidation = qualitySettings.enableProseQualityValidation !== false;
        const enableSentenceVarietyValidation = qualitySettings.enableSentenceVarietyValidation !== false;
        const enableLLMValidation = qualitySettings.enableLLMValidation !== false;

        // ========== A+ QUALITY VALIDATION (Warnings Only - Don't Block Generation) ==========
        // These validators provide feedback but should NOT cause generation failures.
        // Only critical continuity issues should block generation.

        // Track setups for major revelations
        this._trackSetups(generatedContent.narrative, chapter, subchapter);

        if (enableProseQualityValidation) {
          // Run prose quality validation - WARNINGS ONLY
          const proseQuality = this._validateProseQuality(generatedContent.narrative);
          if (proseQuality.warnings.length > 0) {
            validationResult.warnings = [...(validationResult.warnings || []), ...proseQuality.warnings];
          }
          // Convert issues to warnings - prose quality should not block generation
          if (proseQuality.issues.length > 0) {
            validationResult.warnings = [...(validationResult.warnings || []), ...proseQuality.issues.map(i => `[Style] ${i}`)];
          }
          console.log(`[A+Quality] Prose quality score: ${proseQuality.score}/100`);
        }

        if (enableSentenceVarietyValidation) {
          // Run sentence variety validation - WARNINGS ONLY
          const sentenceVariety = this._validateSentenceVariety(generatedContent.narrative);
          if (sentenceVariety.warnings.length > 0) {
            validationResult.warnings = [...(validationResult.warnings || []), ...sentenceVariety.warnings];
          }
          if (sentenceVariety.issues.length > 0) {
            validationResult.warnings = [...(validationResult.warnings || []), ...sentenceVariety.issues.map(i => `[Variety] ${i}`)];
          }
        }

        // Run character voice validation - WARNINGS ONLY
        const characterVoice = this._validateCharacterVoices(generatedContent.narrative);
        if (characterVoice.warnings.length > 0) {
          validationResult.warnings = [...(validationResult.warnings || []), ...characterVoice.warnings];
        }
        if (characterVoice.issues.length > 0) {
          validationResult.warnings = [...(validationResult.warnings || []), ...characterVoice.issues.map(i => `[Voice] ${i}`)];
        }

        // Validate setup/payoff balance - WARNINGS ONLY
        const setupPayoff = this._validateSetupPayoff(chapter, generatedContent.narrative);
        if (setupPayoff.warnings.length > 0) {
          validationResult.warnings = [...(validationResult.warnings || []), ...setupPayoff.warnings];
        }
        if (setupPayoff.issues.length > 0) {
          validationResult.warnings = [...(validationResult.warnings || []), ...setupPayoff.issues.map(i => `[Setup] ${i}`)];
        }

        // Validate arc closure for final chapters (11-12) - WARNINGS ONLY
        const arcClosure = this._validateArcClosure(chapter, context);
        if (arcClosure.warnings.length > 0) {
          validationResult.warnings = [...(validationResult.warnings || []), ...arcClosure.warnings];
        }
        if (arcClosure.issues.length > 0) {
          validationResult.warnings = [...(validationResult.warnings || []), ...arcClosure.issues.map(i => `[Arc] ${i}`)];
        }

        // ========== LLM-BASED VALIDATION (Semantic Understanding) ==========
        // This catches violations that regex can't detect (wrong years, subtle contradictions)
        // Only run if regex validation passed (to avoid wasting tokens on obviously broken content)
        if (enableLLMValidation && validationResult.issues.length === 0) {
          try {
            const llmValidation = await this._validateWithLLM(generatedContent, context);
            if (llmValidation.validated && llmValidation.issues.length > 0) {
              // LLM found issues that regex missed - these are blocking issues
              validationResult.issues = [...validationResult.issues, ...llmValidation.issues.map(i => `[LLM] ${i}`)];
              console.log(`[StoryGen] LLM validation found ${llmValidation.issues.length} issues that regex missed`);
            }
          } catch (llmValError) {
            console.warn(`[StoryGen] LLM validation skipped due to error:`, llmValError.message);
            // Don't fail generation if LLM validation fails - regex validation already passed
          }
        }

        // Log all warnings for debugging without blocking generation
        if (validationResult.warnings?.length > 0) {
          console.log(`[A+Quality] ${validationResult.warnings.length} style warnings (non-blocking):`,
            validationResult.warnings.slice(0, 5));
        }

        // Check if there are any HARD issues that actually require fixing
        // If all issues are soft (non-critical), skip the retry loop entirely
        const allIssues = Array.isArray(validationResult.issues) ? validationResult.issues : [];
        const hardIssuesBeforeRetry = allIssues.filter((i) => this._isContinuityCriticalIssue(i));

        if (!validationResult.valid && hardIssuesBeforeRetry.length === 0) {
          // All issues are soft - convert to warnings and proceed without retry
          console.log(`[StoryGenerationService] ${allIssues.length} soft issues converted to warnings (no retry needed):`,
            allIssues.slice(0, 3));
          validationResult.warnings = [...(validationResult.warnings || []), ...allIssues.map(i => `[Soft] ${i}`)];
          validationResult.issues = [];
          validationResult.valid = true;
        }

        let retries = 0;

        // Only retry if there are HARD continuity issues that require fixing
        while (!validationResult.valid && retries < MAX_RETRIES) {
          console.warn(`Consistency check failed (Attempt ${retries + 1}/${MAX_RETRIES}). Issues:`, validationResult.issues);

          try {
            generatedContent = await this._fixContent(generatedContent, validationResult.issues, context, isDecisionPoint);

            // Log word count after fix (expansion disabled to prevent text corruption)
            const fixedWordCount = generatedContent.narrative.split(/\s+/).length;
            if (fixedWordCount < MIN_WORDS_PER_SUBCHAPTER) {
              console.log(`[StoryGenerationService] Post-fix word count ${fixedWordCount} below minimum, proceeding without expansion`);
            }

            validationResult = this._validateConsistency(generatedContent, context);
            retries++;
          } catch (error) {
            console.error('Error during content regeneration:', error);
            break; // Stop retrying if generation fails
          }
        }

        if (!validationResult.valid) {
          const allIssues = Array.isArray(validationResult.issues) ? validationResult.issues : [];
          const hardIssues = allIssues.filter((i) => this._isContinuityCriticalIssue(i));

          if (hardIssues.length > 0) {
            // Hard continuity failure: throw error to prompt player retry.
            // No fallback narratives - player should retry generation.
            console.error('[StoryGenerationService] Hard validation failure after retries:', hardIssues);
            llmTrace('StoryGenerationService', traceId, 'validation.hard_fail.error', {
              caseNumber,
              pathKey: effectivePathKey,
              chapter,
              subchapter,
              isDecisionPoint,
              hardIssues: hardIssues.slice(0, 10),
              reason,
            }, 'error');

            const error = new Error(`Story generation failed validation: ${hardIssues.slice(0, 2).join('; ')}`);
            error.isValidationFailure = true;
            error.hardIssues = hardIssues;
            error.chapter = chapter;
            error.subchapter = subchapter;
            error.retryable = true;
            throw error;
          }

          console.warn('Consistency warning (Unresolved):', allIssues);
        }

        // Build the story entry
        // NOTE: Schema was slimmed down - beatSheet, jackActionStyle, jackRiskLevel, jackBehaviorDeclaration,
        // storyDay, chapterSummary, consistencyFacts, previousThreadsAddressed were removed from output.
        // These are now handled via <internal_planning> in system prompt (Gemini 3 thinking handles internally).
        const shouldGenerateBoard = isDecisionPoint;
        const storyEntry = {
          chapter,
          subchapter,
          pathKey: effectivePathKey,
          caseNumber,
          title: generatedContent.title,
          // Store canonical narrative (built from branchingNarrative 1A->1A-2A path) for context fallback
          narrative: generatedContent.narrative || null,
          // BRANCHING NARRATIVE: Interactive story structure with player choices
          branchingNarrative: generatedContent.branchingNarrative || null,
          bridgeText: generatedContent.bridgeText,
          previously: generatedContent.previously || '',
          briefing: generatedContent.briefing || { summary: '', objectives: [] },
          pathDecisions: isDecisionPoint ? generatedContent.pathDecisions : null,
          decision: isDecisionPoint ? generatedContent.decision : null,
          board: shouldGenerateBoard
            ? this._generateBoardData(isDecisionPoint, generatedContent.pathDecisions || generatedContent.decision)
            : null,
          narrativeThreads: Array.isArray(generatedContent.narrativeThreads) ? generatedContent.narrativeThreads : [],
          generatedAt: new Date().toISOString(),
          wordCount: generatedContent.narrative?.split(/\s+/).length || 0,
          // Thought signature for multi-chapter reasoning continuity (Gemini 3)
          // Persisted and passed to next chapter generation to maintain reasoning chain
          thoughtSignature: firstCallThoughtSignature || null,
        };

        // Save the generated content
        await saveGeneratedChapter(caseNumber, effectivePathKey, storyEntry);
        llmTrace('StoryGenerationService', traceId, 'storage.saved', {
          caseNumber,
          pathKey,
          wordCount: storyEntry.wordCount,
          hasBranchingNarrative: !!storyEntry.branchingNarrative?.opening?.text,
          generatedAt: storyEntry.generatedAt,
          hasPathDecisions: !!storyEntry.pathDecisions,
        }, 'debug');

        // Update local cache
        if (!this.generatedStory) {
          this.generatedStory = { chapters: {} };
        }
        this.generatedStory.chapters[`${caseNumber}_${effectivePathKey}`] = storyEntry;

        // Update story context
        await this._updateStoryContext(storyEntry);
        llmTrace('StoryGenerationService', traceId, 'context.updated', {
          caseNumber,
          pathKey,
          chapter,
          subchapter,
        }, 'debug');

        // ========== NEW: Create consistency checkpoint for state validation ==========
        // Checkpoints are created after each subchapter C (end of chapter) for validation
        if (subchapter === 3) {
          await this._createConsistencyCheckpoint(chapter, effectivePathKey, storyEntry, choiceHistory);
          llmTrace('StoryGenerationService', traceId, 'checkpoint.created', { chapter, pathKey: effectivePathKey, caseNumber }, 'debug');
        }

        this.isGenerating = false;
        llmTrace('StoryGenerationService', traceId, 'generation.complete', {
          generationKey,
          caseNumber,
          pathKey: effectivePathKey,
          chapter,
          subchapter,
          isDecisionPoint,
          wordCount: storyEntry.wordCount,
          isFallback: false,
          reason,
        }, 'info');
        return storyEntry;
      } catch (error) {
        this.isGenerating = false;

        // ========== GRACEFUL DEGRADATION: Use fallback content on failure ==========
        console.error(`[StoryGenerationService] Generation failed for ${caseNumber}_${effectivePathKey}:`, error.message);
        llmTrace('StoryGenerationService', traceId, 'generation.error', {
          generationKey,
          caseNumber,
          pathKey: effectivePathKey,
          chapter,
          subchapter,
          isDecisionPoint,
          error: error?.message,
          name: error?.name,
          reason,
        }, 'error');

        // Track attempts
        const attemptKey = `${caseNumber}_${effectivePathKey}`;
        const attempts = (this.generationAttempts.get(attemptKey) || 0) + 1;
        this.generationAttempts.set(attemptKey, attempts);

        // If we've exhausted retries, throw error - no fallback narratives
        if (attempts >= this.maxGenerationAttempts) {
          console.error(`[StoryGenerationService] Generation failed for ${caseNumber} after ${attempts} attempts - no fallback`);
          llmTrace('StoryGenerationService', traceId, 'generation.exhausted.error', {
            caseNumber,
            pathKey: effectivePathKey,
            chapter,
            subchapter,
            attempts,
            originalError: error.message,
            reason,
          }, 'error');

          // Clear attempt count
          this.generationAttempts.delete(attemptKey);

          // Throw retryable error for UI to handle
          const retryError = new Error(`Story generation failed after ${attempts} attempts: ${error.message}`);
          retryError.isGenerationFailure = true;
          retryError.attempts = attempts;
          retryError.chapter = chapter;
          retryError.subchapter = subchapter;
          retryError.retryable = true;
          throw retryError;
        }

        // Re-throw to allow caller to retry if attempts remain
        throw error;
      }
    })();

    // Add timestamp for stale detection during pruning
    generationPromise._createdAt = Date.now();
    this.pendingGenerations.set(generationKey, generationPromise);

    // Create a timeout promise to prevent indefinite hangs
    // IMPORTANT: Must be longer than LLMService timeout (300s) * max retries (2)
    // to allow retries to complete. Adding buffer for network delays.
    // Formula: (300s * 2 attempts) + 60s buffer = 660s ≈ 11 minutes
    const GENERATION_TIMEOUT_MS = 11 * 60 * 1000; // 11 minutes (allows for 2 retries @ 300s each)
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Generation timeout after ${GENERATION_TIMEOUT_MS / 1000}s for ${generationKey}`));
      }, GENERATION_TIMEOUT_MS);
    });

    try {
      // Race between the actual generation and the timeout
      const result = await Promise.race([generationPromise, timeoutPromise]);
      this.pendingGenerations.delete(generationKey);
      return result;
    } catch (e) {
      this.pendingGenerations.delete(generationKey);

      // CRITICAL: If this is user-facing generation, NEVER show fallback
      // Instead, throw the error and let the UI show a proper retry screen
      if (isUserFacing) {
        console.error(`[StoryGenerationService] User-facing generation failed for ${generationKey}: ${e.message}`);
        console.error(`[StoryGenerationService] Throwing error to UI - no fallback for user-facing content`);
        llmTrace('StoryGenerationService', traceId, 'generation.userFacing.failed', {
          generationKey,
          caseNumber,
          pathKey: effectivePathKey,
          error: e.message,
          reason
        }, 'error');
        throw e; // Let UI handle retry
      }

      // For background/prefetch generation, also throw error - no fallback narratives
      // The prefetch will fail, and when player needs content, a new generation will be triggered
      console.error(`[StoryGenerationService] Background generation failure for ${generationKey} - no fallback: ${e.message}`);
      llmTrace('StoryGenerationService', traceId, 'generation.background.failed', {
        generationKey,
        caseNumber,
        pathKey: effectivePathKey,
        error: e.message,
        reason,
      }, 'error');

      // Throw error - caller (prefetch) will catch and log, player retries when needed
      throw e;
    } finally {
      // Always release the generation slot, even on error/fallback
      this._releaseGenerationSlot(generationKey);
    }
  }

  /**
   * Generate an entire chapter (all 3 subchapters)
   */
  async generateChapter(chapter, pathKey, choiceHistory = []) {
    const results = [];

    for (let sub = 1; sub <= SUBCHAPTERS_PER_CHAPTER; sub++) {
      const entry = await this.generateSubchapter(chapter, sub, pathKey, choiceHistory);
      results.push(entry);
    }

    return results;
  }

  // ==========================================================================
  // PARSING AND VALIDATION
  // ==========================================================================

  /**
   * Parse generated content from JSON response
   * With structured output, Gemini guarantees valid JSON matching our schema
   * However, truncated responses may still produce invalid JSON
   */
  _parseGeneratedContent(content, isDecisionPoint) {
    try {
      // Parse JSON response (guaranteed valid by Gemini's structured output)
      const parsed = typeof content === 'string' ? JSON.parse(content) : content;

      // Map JSON fields to internal format
      const result = {
        title: parsed.title || 'Untitled',
        bridgeText: parsed.bridge || '',
        previously: parsed.previously || '', // Recap of previous events
        narrative: this._cleanNarrative(parsed.narrative || ''),
        // BRANCHING NARRATIVE: The interactive story structure with 9 paths
        // Contains: opening, firstChoice, secondChoices (each with options array)
        branchingNarrative: parsed.branchingNarrative || null,
        chapterSummary: parsed.chapterSummary || '', // High-quality summary
        puzzleCandidates: parsed.puzzleCandidates || [], // LLM suggested puzzle words
        briefing: parsed.briefing || { summary: '', objectives: [] },
        consistencyFacts: Array.isArray(parsed.consistencyFacts) ? parsed.consistencyFacts : [],
        // NOTE: storyDay, jackActionStyle, jackRiskLevel, jackBehaviorDeclaration removed from schema
        // These are now handled via <internal_planning> in system prompt (Gemini 3 thinking)
        // Kept for backward compatibility with old saved data
        storyDay: parsed.storyDay,
        jackActionStyle: parsed.jackActionStyle,
        jackRiskLevel: parsed.jackRiskLevel,
        jackBehaviorDeclaration: parsed.jackBehaviorDeclaration,
        narrativeThreads: Array.isArray(parsed.narrativeThreads) ? parsed.narrativeThreads : [],
        previousThreadsAddressed: Array.isArray(parsed.previousThreadsAddressed) ? parsed.previousThreadsAddressed : [],
        pathDecisions: null,
      };

      // Convert decision format if present
      if (isDecisionPoint) {
        if (parsed.pathDecisions) {
          // Support both array format (new) and object format (legacy)
          let pathDecisionsObj;
          if (Array.isArray(parsed.pathDecisions)) {
            // New array format: convert to object keyed by pathKey
            console.log(`[StoryGenerationService] Raw pathDecisions from LLM: ${parsed.pathDecisions.length} paths (array format)`);
            pathDecisionsObj = {};
            for (const decision of parsed.pathDecisions) {
              if (decision.pathKey) {
                pathDecisionsObj[decision.pathKey] = decision;
              }
            }
          } else {
            // Legacy object format
            pathDecisionsObj = parsed.pathDecisions;
            console.log(`[StoryGenerationService] Raw pathDecisions from LLM: ${Object.keys(pathDecisionsObj).length} paths (object format)`);
          }

          // Convert each of the 9 path-specific decisions to internal format
          result.pathDecisions = {};
          for (const pathKey of Object.keys(pathDecisionsObj)) {
            const rawDecision = pathDecisionsObj[pathKey];
            if (rawDecision) {
              result.pathDecisions[pathKey] = this._convertDecisionFormat(rawDecision);
            }
          }

          // Validate that we got all 9 paths
          const expectedPaths = ['1A-2A', '1A-2B', '1A-2C', '1B-2A', '1B-2B', '1B-2C', '1C-2A', '1C-2B', '1C-2C'];
          const missingPaths = expectedPaths.filter(p => !result.pathDecisions[p]);
          if (missingPaths.length > 0) {
            console.warn(`[StoryGenerationService] PATH DECISIONS INCOMPLETE - missing paths: ${missingPaths.join(', ')}`);
          }

          // Validate sample decision has proper structure
          const sampleDecision = result.pathDecisions['1A-2A'];
          if (!sampleDecision?.options?.[0]?.title || !sampleDecision?.options?.[1]?.title) {
            console.error('[StoryGenerationService] PATH DECISION PARSING FAILED - sample (1A-2A) missing titles:', {
              rawSample: pathDecisionsObj['1A-2A'],
              convertedSample: sampleDecision,
            });
          }
        } else if (parsed.decision) {
          // Simple single decision format (TEMPORARY for testing)
          console.log(`[StoryGenerationService] Using simple decision format (single decision)`);
          result.decision = this._convertDecisionFormat(parsed.decision);
        }
      }

      return result;
    } catch (error) {
      // This can happen with truncated responses - try to extract what we can
      console.error('[StoryGenerationService] JSON parse error:', error);
      console.log('[StoryGenerationService] Attempting to extract content from malformed JSON...');

      // Try to extract partial content using regex
      const extracted = this._extractPartialContent(content, isDecisionPoint);
      if (extracted.narrative && extracted.narrative.length > 100) {
        console.log('[StoryGenerationService] Successfully extracted partial content');
        return extracted;
      }

      // Last resort: use the raw content as narrative
      console.warn('[StoryGenerationService] Falling back to raw content as narrative');
      return {
        title: 'Untitled',
        bridgeText: '',
        previously: '',
        narrative: typeof content === 'string' ? this._cleanNarrative(this._extractNarrativeFromRaw(content)) : '',
        chapterSummary: '',
        puzzleCandidates: [],
        briefing: { summary: '', objectives: [] },
        consistencyFacts: [],
        decision: null,
      };
    }
  }

  /**
   * Extract partial content from malformed JSON using regex patterns
   */
  _extractPartialContent(content, isDecisionPoint) {
    const result = {
      title: 'Untitled',
      bridgeText: '',
      previously: '',
      narrative: '',
      branchingNarrative: null, // Include in fallback parsing
      chapterSummary: '',
      puzzleCandidates: [],
      briefing: { summary: '', objectives: [] },
      consistencyFacts: [],
      pathDecisions: null, // Path-specific decisions for C subchapters
    };

    if (typeof content !== 'string') {
      return result;
    }

    // Try to extract title
    const titleMatch = content.match(/"title"\s*:\s*"([^"]+)"/);
    if (titleMatch) {
      result.title = titleMatch[1];
    }

    // Try to extract bridge text
    const bridgeMatch = content.match(/"bridge"\s*:\s*"([^"]+)"/);
    if (bridgeMatch) {
      result.bridgeText = bridgeMatch[1];
    }

    // Try to extract previously
    const previouslyMatch = content.match(/"previously"\s*:\s*"([^"]+)"/);
    if (previouslyMatch) {
      result.previously = previouslyMatch[1];
    }

    // Try to extract narrative (this is the most important and likely longest field)
    const narrativeMatch = content.match(/"narrative"\s*:\s*"([\s\S]*?)(?:"\s*,\s*"|"\s*,\s*"briefing|"\s*,\s*"consistencyFacts|"\s*})/);
    if (narrativeMatch) {
      // Unescape the narrative content
      let narrative = narrativeMatch[1];
      // Handle escaped characters
      narrative = narrative.replace(/\\n/g, '\n')
                          .replace(/\\"/g, '"')
                          .replace(/\\\\/g, '\\');
      result.narrative = this._cleanNarrative(narrative);
    } else {
      // Try a more aggressive pattern for truncated narratives
      const looseNarrativeMatch = content.match(/"narrative"\s*:\s*"([\s\S]{100,})/);
      if (looseNarrativeMatch) {
        let narrative = looseNarrativeMatch[1];
        // Find the last complete sentence
        const lastSentenceEnd = Math.max(
          narrative.lastIndexOf('.'),
          narrative.lastIndexOf('!'),
          narrative.lastIndexOf('?')
        );
        if (lastSentenceEnd > narrative.length * 0.5) {
          narrative = narrative.substring(0, lastSentenceEnd + 1);
        }
        narrative = narrative.replace(/\\n/g, '\n')
                            .replace(/\\"/g, '"')
                            .replace(/\\\\/g, '\\');
        result.narrative = this._cleanNarrative(narrative);
      }
    }

    // Try to extract briefing summary
    const briefingSummaryMatch = content.match(/"summary"\s*:\s*"([^"]+)"/);
    if (briefingSummaryMatch) {
      result.briefing.summary = briefingSummaryMatch[1];
    }

    // Try to extract briefing objectives
    const objectivesMatch = content.match(/"objectives"\s*:\s*\[([\s\S]*?)\]/);
    if (objectivesMatch) {
      const objectivesStr = objectivesMatch[1];
      const objectives = objectivesStr.match(/"([^"]+)"/g);
      if (objectives) {
        result.briefing.objectives = objectives.map(o => o.replace(/"/g, ''));
      }
    }

    // Try to extract decision for decision points
    if (isDecisionPoint) {
      const introMatch = content.match(/"intro"\s*:\s*"([^"]+)"/);
      const optionATitleMatch = content.match(/"optionA"[\s\S]*?"title"\s*:\s*"([^"]+)"/);
      const optionAFocusMatch = content.match(/"optionA"[\s\S]*?"focus"\s*:\s*"([^"]+)"/);
      const optionBTitleMatch = content.match(/"optionB"[\s\S]*?"title"\s*:\s*"([^"]+)"/);
      const optionBFocusMatch = content.match(/"optionB"[\s\S]*?"focus"\s*:\s*"([^"]+)"/);

      if (introMatch && optionATitleMatch) {
        result.decision = {
          intro: [introMatch[1]],
          options: [
            {
              key: 'A',
              title: optionATitleMatch[1],
              focus: optionAFocusMatch ? optionAFocusMatch[1] : '',
              consequence: null,
              stats: null,
              outcome: null,
              nextChapter: null,
              nextPathKey: 'A',
              details: [],
            },
            {
              key: 'B',
              title: optionBTitleMatch ? optionBTitleMatch[1] : 'Option B',
              focus: optionBFocusMatch ? optionBFocusMatch[1] : '',
              consequence: null,
              stats: null,
              outcome: null,
              nextChapter: null,
              nextPathKey: 'B',
              details: [],
            },
          ],
        };
      }
    }

    return result;
  }

  /**
   * Extract narrative content from raw text when JSON parsing completely fails
   */
  _extractNarrativeFromRaw(content) {
    if (typeof content !== 'string') return '';

    // Remove JSON structure artifacts
    let text = content;

    // If it looks like it starts with JSON, try to extract the narrative value
    if (text.includes('"narrative"')) {
      const narrativeStart = text.indexOf('"narrative"');
      const valueStart = text.indexOf('"', narrativeStart + 11) + 1;
      if (valueStart > narrativeStart) {
        text = text.substring(valueStart);
        // Try to find the end of the narrative
        const valueEnd = text.lastIndexOf('"');
        if (valueEnd > 100) {
          text = text.substring(0, valueEnd);
        }
      }
    }

    // Clean up escaped characters
    text = text.replace(/\\n/g, '\n')
               .replace(/\\"/g, '"')
               .replace(/\\\\/g, '\\')
               .replace(/^\{[\s\S]*?"narrative"\s*:\s*"/m, '')
               .replace(/",[\s\S]*$/m, '');

    // Find the last complete sentence to avoid cut-off text
    const lastSentenceEnd = Math.max(
      text.lastIndexOf('.'),
      text.lastIndexOf('!'),
      text.lastIndexOf('?')
    );

    if (lastSentenceEnd > text.length * 0.3) {
      text = text.substring(0, lastSentenceEnd + 1);
    }

    return text.trim();
  }

  /**
   * Convert JSON decision format to internal game format
   */
  _convertDecisionFormat(decision) {
    // Build option objects once
    const optionAObj = {
      key: decision.optionA?.key || 'A',
      title: decision.optionA?.title || 'Option A',
      focus: decision.optionA?.focus || '',
      personalityAlignment: decision.optionA?.personalityAlignment || 'neutral',
      consequence: null,
      stats: null,
      outcome: null,
      nextChapter: null, // Will be set by game logic
      nextPathKey: decision.optionA?.key || 'A',
      details: [],
    };
    const optionBObj = {
      key: decision.optionB?.key || 'B',
      title: decision.optionB?.title || 'Option B',
      focus: decision.optionB?.focus || '',
      personalityAlignment: decision.optionB?.personalityAlignment || 'neutral',
      consequence: null,
      stats: null,
      outcome: null,
      nextChapter: null, // Will be set by game logic
      nextPathKey: decision.optionB?.key || 'B',
      details: [],
    };

    return {
      intro: [decision.intro || ''],
      // Keep both formats for compatibility:
      // - options[] array for iteration
      // - optionA/optionB for direct access
      options: [optionAObj, optionBObj],
      optionA: optionAObj,
      optionB: optionBObj,
    };
  }

  /**
   * Clean narrative text - minimal cleanup since structured output is clean
   */
  _cleanNarrative(text) {
    if (!text) return '';
    return text
      // Fix double spaces
      .replace(/\s{2,}/g, ' ')
      // Remove em dashes (replace with comma)
      .replace(/\s*—\s*/g, ', ')
      .trim();
  }

  /**
   * Return canonical name misspellings based on story bible facts.
   */
  _getCanonicalNameMisspellings() {
    const misspellings = [];
    const protagonistName = ABSOLUTE_FACTS?.protagonist?.fullName || '';
    const antagonistName = ABSOLUTE_FACTS?.antagonist?.trueName || '';
    const protagonistLast = protagonistName.trim().split(/\s+/).slice(-1)[0];
    const antagonistLast = antagonistName.trim().split(/\s+/).slice(-1)[0];

    const add = (correct, wrong) => {
      if (!correct || !Array.isArray(wrong) || wrong.length === 0) return;
      misspellings.push({ correct, wrong });
    };

    // Only include known variants for canonical characters to avoid drift.
    if (protagonistLast && /^halloway$/i.test(protagonistLast)) {
      add(protagonistLast, ['hallaway', 'holloway', 'haloway', 'hallo way']);
    }
    if (antagonistLast && /^blackwell$/i.test(antagonistLast)) {
      add(antagonistLast, ['blackwood', 'blackwel', 'black well']);
    }

    return misspellings;
  }

  /**
   * Fix common typos locally without calling the LLM
   * This prevents expensive API calls for simple string replacements
   */
  _fixTyposLocally(content) {
    if (!content?.narrative) return content;

    let narrative = content.narrative;
    let fixCount = 0;

    const typoFixes = [];
    const nameMisspellings = this._getCanonicalNameMisspellings();
    for (const entry of nameMisspellings) {
      for (const misspelling of entry.wrong) {
        const trimmed = String(misspelling || '').trim();
        if (!trimmed) continue;
        const escaped = trimmed.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const patternStr = escaped.replace(/\s+/g, '\\s+');
        typoFixes.push({
          pattern: new RegExp(`\\b${patternStr}\\b`, 'gi'),
          replacement: entry.correct,
        });
      }
    }

    const cityName = String(ABSOLUTE_FACTS?.setting?.city || '').trim();
    const cityLower = cityName.toLowerCase();
    if (cityLower === 'ashport') {
      const cityPossessive = cityName.endsWith('s') ? `${cityName}'` : `${cityName}'s`;
      typoFixes.push({ pattern: /\bashport's\b/gi, replacement: cityPossessive });
      typoFixes.push({ pattern: /\bash port\b/gi, replacement: cityName });
    }

    for (const { pattern, replacement } of typoFixes) {
      const before = narrative;
      narrative = narrative.replace(pattern, replacement);
      if (before !== narrative) {
        fixCount++;
      }
    }

    if (fixCount > 0) {
      console.log(`[StoryGenerationService] Fixed ${fixCount} typos locally (no LLM call needed)`);
    }

    return {
      ...content,
      narrative,
    };
  }

  /**
   * Validate content against established facts - COMPREHENSIVE VERSION
   * Checks for: name spelling, timeline, setting, character behavior, relationship states,
   * plot continuity, and path personality consistency
   */
  _validateConsistency(content, context) {
    const issues = [];
    const warnings = []; // Non-blocking issues
    const narrative = content.narrative.toLowerCase();
    const narrativeOriginal = content.narrative;

    // =========================================================================
    // CATEGORY 1: NAME AND SPELLING CONSISTENCY
    // These should rarely trigger now since _fixTyposLocally runs first
    // =========================================================================
    const nameChecks = this._getCanonicalNameMisspellings();

    nameChecks.forEach(({ wrong, correct }) => {
      wrong.forEach(misspelling => {
        // Use word boundary regex instead of includes() to prevent false positives
        // e.g., correct spelling "thornhill" should NOT match misspelling "thornhil"
        // e.g., correct spelling "blackwell" should NOT match misspelling "blackwel"
        const trimmedMisspelling = misspelling.trim();
        const escapedMisspelling = trimmedMisspelling.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        // Handle multi-word misspellings like "thorn hill" -> /\bthorn\s+hill\b/
        const patternStr = escapedMisspelling.replace(/\s+/g, '\\s+');
        const pattern = new RegExp(`\\b${patternStr}\\b`, 'i');
        if (pattern.test(narrative)) {
          issues.push(`Name misspelled: found "${trimmedMisspelling}", should be "${correct}"`);
        }
      });
    });

    // =========================================================================
    // CATEGORY 2: STORY DAY CONSISTENCY
    // =========================================================================
    // NOTE: storyDay field was removed from schema - now handled via <internal_planning> in system prompt.
    // The LLM determines storyDay internally (Chapter N = Day N) without outputting it.
    // NOTE: Character-specific timeline validations removed - only Jack and Victoria are canonical.
    // The LLM has creative freedom to generate supporting characters with their own timelines.

    // Check for relative time references that could cause drift
    const relativeTimePatterns = [
      { pattern: /(?:nearly|almost|about|roughly)\s+(?:a\s+)?decade/i, issue: 'Avoid vague time references like "nearly a decade" - use exact durations' },
      { pattern: /(?:many|several|countless)\s+years\s+(?:ago|since)/i, issue: 'Avoid vague "many/several years" - use exact durations from ABSOLUTE_FACTS' },
    ];

    relativeTimePatterns.forEach(({ pattern, issue }) => {
      if (pattern.test(narrativeOriginal)) {
        warnings.push(issue); // Warning, not error, for vague references
      }
    });

    // =========================================================================
    // CATEGORY 2.75: CHOICE CAUSALITY (Respect the most recent player decision)
    // =========================================================================
    // If this is the first subchapter of a new chapter, the narrative must quickly reflect
    // the last decision's immediate consequence. This prevents "generic reset" feeling.
    if (
      context?.currentPosition?.subchapter === 1 &&
      context?.currentPosition?.chapter > 1 &&
      context?.lastDecision &&
      context?.lastDecision?.chapter === context.currentPosition.chapter - 1
    ) {
      const prefix = narrativeOriginal
        .split(/\s+/)
        .slice(0, 200)
        .join(' ')
        .toLowerCase();

      // Stopwords used for choice-causality keyword extraction.
      // Include common noir/setting tokens so we don't get false positives like "truth/rain/case".
      // NOTE: Only includes canonical characters (Jack, Victoria/Blackwell) - others are LLM-generated.
      const stop = new Set([
        'jack', 'halloway', 'ashport', 'victoria', 'blackwell',
        'said', 'the', 'and', 'that', 'with', 'from', 'into', 'then', 'over', 'under',
        'were', 'was', 'had', 'have', 'this', 'there', 'their', 'they', 'them', 'what',
        'when', 'where', 'which', 'while', 'because', 'before', 'after', 'could', 'would',
        'should', 'about', 'again', 'still', 'truth', 'pattern', 'glyph', 'threshold', 'map',
        'investigation', 'city', 'street', 'streets', 'office', 'night', 'days', 'years',
        'choice', 'chose', 'decided', 'decision', 'option', 'path', 'plan',
      ]);
      const seedText = `${context.lastDecision.immediate || ''} ${context.lastDecision.chosenTitle || ''} ${context.lastDecision.chosenFocus || ''}`;
      const keywords = [...new Set(
        seedText
          .toLowerCase()
          .replace(/[^a-z0-9\s]/g, ' ')
          .split(/\s+/)
          .filter(w => w.length >= 4 && !stop.has(w))
      )].slice(0, 10);

      // Use word-based prefix matching to prevent false positives (e.g., "case" matching "showcase")
      const prefixWords = prefix.match(/\b\w+\b/g) || [];
      const hitCount = keywords.reduce((acc, k) => {
        const found = prefixWords.some(pw => {
          if (k.length < 4 || pw.length < 4) return k === pw;
          return k.startsWith(pw) || pw.startsWith(k);
        });
        return acc + (found ? 1 : 0);
      }, 0);
      if (hitCount === 0 && keywords.length > 0) {
        // Log as WARNING only - keyword matching is too simplistic for natural language.
        // The LLM may use synonyms/paraphrases that are semantically correct but don't
        // match our literal keywords. Trust the prompt instructions instead.
        warnings.push(
          `[Keyword check] No literal keyword matches in first 200 words for decision "${context.lastDecision.optionKey}". Keywords checked: [${keywords.slice(0, 5).join(', ')}]. This is usually fine - LLM likely used synonyms.`
        );
      }
    }

    // =========================================================================
    // CATEGORY 3: SETTING CONSISTENCY
    // =========================================================================
    const settingViolations = [
      { pattern: /\b(?:elf|elves|dwarf|dwarves|orc|orcs|goblin|goblins)\b/i, issue: 'Forbidden Tolkien-style fantasy element detected' },
      { pattern: /\b(?:kingdom|castle|feudal|knight|sword\s+and\s+sorcery)\b/i, issue: 'Forbidden medieval-fantasy setting drift detected' },
    ];

    settingViolations.forEach(({ pattern, issue }) => {
      if (pattern.test(narrativeOriginal)) {
        issues.push(issue);
      }
    });

    // =========================================================================
    // CATEGORY 4: CHARACTER BEHAVIOR CONSISTENCY (Based on path personality)
    // NOTE: jackActionStyle, jackRiskLevel, jackBehaviorDeclaration were removed from schema.
    // Behavior consistency is now validated through narrative text analysis only.
    // The LLM handles behavior planning internally via <internal_planning> in system prompt.
    // =========================================================================
    if (context.pathPersonality) {
      const personality = context.pathPersonality;

      // Check for personality-inconsistent behavior in narrative text
      // NOTE: These are now warnings only since we can't detect emotional state exceptions
      // without the schema field. Trust the <internal_planning> system prompt guidance.
      if (personality.riskTolerance === 'low') {
        // Methodical Jack shouldn't suddenly be reckless
        const recklessBehavior = /\b(?:i|jack)\s+(?:rushed|stormed|lunged|burst|barreled)\s+(?:in|into|through|forward)\b/i;
        const chargedAction = /\b(?:i|jack)\s+charged\s+(?:in|into|through|forward|at)\b/i;

        if (recklessBehavior.test(narrativeOriginal) || chargedAction.test(narrativeOriginal)) {
          warnings.push('Methodical Jack is acting recklessly (rushed/charged/stormed). Verify this fits the scene context.');
        }

        // Check for impulsive actions
        const impulsiveActions = /\bwithout\s+(?:thinking|hesitation|a\s+second\s+thought)\b|\b(?:i|jack)\s+(?:grabbed|lunged|dove|leapt)\s+(?:at|for|toward)\b/i;
        if (impulsiveActions.test(narrativeOriginal)) {
          warnings.push('Methodical Jack is acting impulsively. Verify this fits the scene context.');
        }
      } else if (personality.riskTolerance === 'high') {
        // Aggressive Jack shouldn't suddenly become overly cautious
        // Note: For aggressive->cautious, we use warnings (not errors) since this is less narratively jarring
        const overlyPrudent = /\b(?:i|jack)\s+(?:hesitated\s+for\s+(?:a\s+)?long|wavered|second-guessed|held\s+back|waited\s+patiently|decided\s+to\s+wait)\b/i;
        if (overlyPrudent.test(narrativeOriginal)) {
          warnings.push('Aggressive Jack is showing cautious behavior (hesitated/wavered). Consider if this fits the scene context.');
        }

        // Check for excessive deliberation
        const excessiveDeliberation = /\b(?:i|jack)\s+(?:carefully\s+considered|weighed\s+(?:my|the)\s+options|took\s+(?:my|his)\s+time\s+(?:to|before))\b/i;
        if (excessiveDeliberation.test(narrativeOriginal)) {
          warnings.push('Aggressive Jack is deliberating excessively. Consider if this fits the scene context.');
        }
      }
    }

    // =========================================================================
    // CATEGORY 5: PLOT CONTINUITY - Check narrative threads - STRICTLY ENFORCED
    // =========================================================================
    if (context.narrativeThreads && context.narrativeThreads.length > 0) {
      // Get critical threads that MUST be addressed (appointments and promises)
      const criticalThreads = context.narrativeThreads.filter(t =>
        t.status === 'active' &&
        (t.type === 'appointment' || t.type === 'promise' || t.type === 'threat' || t.urgency === 'critical')
      );

      if (criticalThreads.length > 0 && context.currentPosition.chapter > 2) {
        // Check if LLM provided thread acknowledgments
        const addressedThreads = content.previousThreadsAddressed || [];

        // ========== NEW: Verify addressed threads actually match critical threads ==========
        // This prevents the LLM from claiming to address made-up threads
        let validAddressedCount = 0;
        const unmatchedCritical = [...criticalThreads];

        for (const addressed of addressedThreads) {
          const addressedLower = (addressed.originalThread || '').toLowerCase();

          // Try to match this addressed thread to a critical thread
          const matchIndex = unmatchedCritical.findIndex(critical => {
            const criticalLower = (critical.description || '').toLowerCase();
            // Match if there's significant overlap in key terms
            const addressedWords = addressedLower.split(/\s+/).filter(w => w.length > 3);
            const criticalWords = criticalLower.split(/\s+/).filter(w => w.length > 3);
            // Use prefix matching: one word must be a prefix of the other (min 4 chars)
            // This allows "promise" to match "promised" but prevents "case" matching "showcase"
            const wordsMatch = (a, b) => {
              if (a.length < 4 || b.length < 4) return a === b;
              return a.startsWith(b) || b.startsWith(a);
            };
            const matchingWords = addressedWords.filter(w => criticalWords.some(cw => wordsMatch(w, cw)));
            // Require at least 2 matching words or 40% overlap
            return matchingWords.length >= 2 || matchingWords.length / Math.max(addressedWords.length, 1) > 0.4;
          });

          if (matchIndex !== -1) {
            validAddressedCount++;
            unmatchedCritical.splice(matchIndex, 1); // Remove matched thread
          } else {
            // Log potential fabricated thread
            console.warn(`[StoryGenerationService] Thread addressed doesn't match any critical thread: "${addressedLower.slice(0, 60)}..."`);
          }
        }

        // Require ALL critical threads to be VALIDLY acknowledged.
        // The system prompt instructs the model to copy originalThread exactly and the engine treats
        // missing critical threads as a hard continuity failure (we will hard-enforce in generation).
        const criticalCount = criticalThreads.length;
        const requiredAcknowledgments = criticalCount;
        if (validAddressedCount < requiredAcknowledgments) {
          issues.push(
            `THREAD CONTINUITY VIOLATION: Only ${validAddressedCount}/${criticalCount} critical threads validly addressed (${addressedThreads.length} claimed). Must acknowledge ALL ${requiredAcknowledgments}. Unaddressed: ${unmatchedCritical.slice(0, 3).map(t => t.description?.slice(0, 50)).join('; ')}`
          );
        }

        // =========================================================================
        // THREAD ESCALATION SYSTEM - Track and enforce overdue threads
        // =========================================================================
        for (const addressed of addressedThreads) {
          const threadId = addressed.originalThread.slice(0, 50); // Use truncated description as ID

          if (addressed.howAddressed === 'acknowledged' || addressed.howAddressed === 'delayed') {
            // Increment acknowledgment count for threads that weren't progressed
            const currentCount = (this.threadAcknowledgmentCounts.get(threadId) || 0) + 1;
            this.threadAcknowledgmentCounts.set(threadId, currentCount);

            // If acknowledged 2+ times without progress, flag as OVERDUE ERROR
            if (currentCount >= 2) {
              // Use word-based prefix matching to find the corresponding critical thread
              // This handles LLM rewording (e.g., "promised to meet" → "meeting") while
              // distinguishing similar threads (e.g., "meet contact" vs "call contact")
              const threadIdWords = threadId.toLowerCase().match(/\b\w{4,}\b/g) || [];
              const wordsMatchFn = (a, b) => {
                if (a.length < 4 || b.length < 4) return a === b;
                return a.startsWith(b) || b.startsWith(a);
              };
              const matchingCritical = criticalThreads.find(t => {
                if (!t.description) return false;
                const descWords = t.description.toLowerCase().match(/\b\w{4,}\b/g) || [];
                const matchingWords = threadIdWords.filter(tw =>
                  descWords.some(dw => wordsMatchFn(tw, dw))
                );
                // Require at least 2 matching words AND 40% overlap
                return matchingWords.length >= 2 && matchingWords.length / Math.max(threadIdWords.length, 1) > 0.4;
              });
              if (matchingCritical) {
                issues.push(`OVERDUE THREAD ERROR: "${addressed.originalThread.slice(0, 60)}..." has been acknowledged ${currentCount} times without resolution. You MUST either resolve it, progress it meaningfully, or mark it as "failed" with explanation.`);
              }
            }
          } else if (addressed.howAddressed === 'resolved' || addressed.howAddressed === 'progressed' || addressed.howAddressed === 'failed') {
            // Reset counter when thread is actually addressed
            this.threadAcknowledgmentCounts.delete(threadId);
          }

          // Verify acknowledged threads actually appear in narrative
          if (addressed.howAddressed === 'resolved' || addressed.howAddressed === 'progressed') {
            const threadLower = addressed.originalThread.toLowerCase();
            const narrativeLower = narrative.toLowerCase();

            // Extract key nouns/names from the thread description
            // Only canonical character names are matched - other characters are LLM-generated
            const keyWords = threadLower.match(/\b(?:jack|victoria|blackwell|meet|promise|call|contact|investigate|reveal)\b/g) || [];

            // Use prefix matching to allow word variations (meet/meeting, promise/promised)
            // but prevent false positives (case/showcase)
            const narrativeWords = narrativeLower.match(/\b\w+\b/g) || [];
            const mentionedInNarrative = keyWords.some(keyword => {
              return narrativeWords.some(w => {
                if (keyword.length < 4 || w.length < 4) return keyword === w;
                return keyword.startsWith(w) || w.startsWith(keyword);
              });
            });

            if (!mentionedInNarrative && keyWords.length > 0) {
              warnings.push(`Thread claimed as "${addressed.howAddressed}" but may not appear in narrative: "${addressed.originalThread.slice(0, 60)}..."`);
            }
          }
        }
      }

      // Check for dangling appointments more than 2 chapters old - NOW ERROR
      const oldAppointments = context.narrativeThreads.filter(t =>
        t.status === 'active' &&
        t.type === 'appointment' &&
        t.chapter && (context.currentPosition.chapter - t.chapter) >= 2
      );

      if (oldAppointments.length > 0) {
        issues.push(`OVERDUE APPOINTMENTS: ${oldAppointments.length} appointment(s) from 2+ chapters ago still unresolved. These MUST be addressed: ${oldAppointments.slice(0, 2).map(t => t.description).join('; ')}`);
      }

      // Check for old promises - NOW ERROR after 3 chapters
      const oldPromises = context.narrativeThreads.filter(t =>
        t.status === 'active' &&
        t.type === 'promise' &&
        t.chapter && (context.currentPosition.chapter - t.chapter) >= 3
      );

      if (oldPromises.length > 0) {
        issues.push(`OVERDUE PROMISES: ${oldPromises.length} promise(s) from 3+ chapters ago still unresolved. These MUST be resolved or failed: ${oldPromises.slice(0, 2).map(t => t.description).join('; ')}`);
      }
    }

    // =========================================================================
    // CATEGORY 6: DECISION CONSEQUENCE CARRYOVER
    // =========================================================================
    // Check that narrative mentions or reflects consequences of player's choices
    if (context.playerChoices && context.playerChoices.length > 0 && context.currentPosition.subchapter === 1) {
      const lastChoice = context.playerChoices[context.playerChoices.length - 1];
      const lastChoiceChapter = this._extractChapterFromCase(lastChoice.caseNumber);

      // If this is the first subchapter after a decision, narrative should acknowledge it
      if (lastChoiceChapter === context.currentPosition.chapter - 1) {
        // Look for any indication the choice is being addressed
        const hasChoiceReference = /(?:choice|decision|chose|decided|opted|path|went with|took the)/i.test(narrativeOriginal);
        if (!hasChoiceReference) {
          warnings.push('Opening of new chapter should acknowledge/reflect the player\'s previous decision');
        }
      }
    }

    // =========================================================================
    // CATEGORY 7: FORBIDDEN WRITING PATTERNS
    // =========================================================================
    const forbiddenPatterns = [
      { pattern: /—/g, issue: 'Em dashes (—) found - use commas, periods, or semicolons instead', count: true },
      { pattern: /\bis not just\b.*\bit'?s\b/i, issue: 'Forbidden pattern: "X is not just Y, it\'s Z"' },
      { pattern: /\bin a world where\b/i, issue: 'Forbidden phrase: "In a world where..."' },
      { pattern: /\blittle did (?:he|she|they|i|we) know\b/i, issue: 'Forbidden phrase: "Little did [anyone] know..."' },
      { pattern: /\bi couldn'?t help but\b/i, issue: 'Forbidden phrase: "I couldn\'t help but..."' },
      { pattern: /\bi found myself\b/i, issue: 'Forbidden phrase: "I found myself..."' },
      { pattern: /\bseemingly\b|\binterestingly\b|\bnotably\b|\bcertainly\b|\bundoubtedly\b/i, issue: 'Forbidden flowery adverbs detected' },
      { pattern: /\bundeniably\b|\bprofoundly\b|\bunmistakably\b|\binherently\b/i, issue: 'Forbidden AI-ism adverbs detected (undeniably, profoundly, unmistakably, inherently)' },
      { pattern: /\bdelve\b|\bunravel\b|\btapestry\b|\bmyriad\b/i, issue: 'Forbidden words detected (delve, unravel, tapestry, myriad)' },
      { pattern: /\bin the realm of\b|\bintricate\b|\bnuanced\b/i, issue: 'Forbidden AI-ism phrases detected (in the realm of, intricate, nuanced)' },
      { pattern: /\bpivotal\b|\bcrucial\b/i, issue: 'Overused emphasis words detected (pivotal, crucial) - consider stronger alternatives' },
      { pattern: /\ba testament to\b|\bserves as a reminder\b/i, issue: 'Forbidden cliche phrase detected' },
      // Removed: "weight of/gravity of" - these are legitimate phrases in noir fiction
      { pattern: /\bmoreover\b|\bfurthermore\b|\bin essence\b|\bconsequently\b|\badditionally\b/i, issue: 'Forbidden academic connectors detected' },
      { pattern: /\bthis moment\b|\bthis realization\b|\bthis truth\b/i, issue: 'Forbidden meta-commentary detected ("this moment/realization/truth")' },
      { pattern: /\bin that moment\b|\bat that instant\b|\bin the blink of an eye\b/i, issue: 'Forbidden time transition cliche detected' },
      { pattern: /\bit'?s (?:important|worth) (?:to note|noting)\b/i, issue: 'Forbidden meta-phrase detected ("it\'s important/worth noting")' },
    ];

    // Forbidden patterns are now WARNINGS, not errors
    // Stylistic preferences should not trigger expensive LLM retries
    forbiddenPatterns.forEach(({ pattern, issue, count }) => {
      if (count) {
        const matches = narrativeOriginal.match(pattern);
        if (matches && matches.length > 0) {
          warnings.push(`${issue} (found ${matches.length} instances)`);
        }
      } else if (pattern.test(narrativeOriginal)) {
        warnings.push(issue);
      }
    });

    // =========================================================================
    // CATEGORY 8: WORD COUNT VALIDATION (WARNINGS ONLY)
    // Expansion was causing text corruption so short narratives are now accepted
    // =========================================================================
    const wordCount = narrativeOriginal.split(/\s+/).filter(w => w.length > 0).length;
    if (wordCount < MIN_WORDS_PER_SUBCHAPTER) {
      warnings.push(`Narrative shorter than minimum: ${wordCount} words (minimum ${MIN_WORDS_PER_SUBCHAPTER})`);
    } else if (wordCount < TARGET_WORDS * 0.85) {
      warnings.push(`Narrative shorter than target: ${wordCount} words (target ${TARGET_WORDS})`);
    }
    const maxWords = GENERATION_CONFIG?.wordCount?.maximum;
    if (typeof maxWords === 'number' && wordCount > maxWords) {
      warnings.push(`Narrative longer than maximum: ${wordCount} words (max ${maxWords}). Consider tightening for pacing/latency.`);
    }

    // =========================================================================
    // CATEGORY 8.1: BRANCHING NARRATIVE WORD COUNT VALIDATION (WARNINGS ONLY)
    // Each player path should meet the target word count (900-1050 words)
    // Structure: opening (300-350) + firstChoice response (300-350) + secondChoice response (300-350)
    // NOTE: These are warnings, not errors - schema instructs correct lengths, retries are wasteful
    // =========================================================================
    const bn = content.branchingNarrative;
    if (bn && bn.opening && bn.firstChoice && bn.secondChoices) {
      const countWords = (text) => (text || '').split(/\s+/).filter(w => w.length > 0).length;
      const MIN_SEGMENT_WORDS = 300;  // Minimum per segment (300-350 target). 3×300=900 word path minimum.
      const MIN_PATH_WORDS = MIN_WORDS_PER_SUBCHAPTER;  // Each complete path should meet subchapter minimum

      // Validate opening
      const openingWords = countWords(bn.opening.text);
      if (openingWords < MIN_SEGMENT_WORDS) {
        warnings.push(`Branching narrative opening too short: ${openingWords} words (minimum ${MIN_SEGMENT_WORDS})`);
      }

      // Validate first choice options (3 branches)
      const firstChoiceOptions = bn.firstChoice?.options || [];
      firstChoiceOptions.forEach((opt, idx) => {
        const optWords = countWords(opt.response);
        if (optWords < MIN_SEGMENT_WORDS) {
          warnings.push(`First choice "${opt.key || idx}" response too short: ${optWords} words (minimum ${MIN_SEGMENT_WORDS})`);
        }
      });

      // Validate second choice options (9 branches) and complete paths
      const secondChoices = bn.secondChoices || [];
      secondChoices.forEach((sc, scIdx) => {
        const parentOpt = firstChoiceOptions[scIdx];
        const parentWords = countWords(parentOpt?.response);

        (sc.options || []).forEach((opt, optIdx) => {
          const optWords = countWords(opt.response);
          if (optWords < MIN_SEGMENT_WORDS) {
            warnings.push(`Second choice "${opt.key || `${scIdx}-${optIdx}`}" response too short: ${optWords} words (minimum ${MIN_SEGMENT_WORDS})`);
          }

          // Validate complete path word count (opening + first choice + second choice)
          const pathWords = openingWords + parentWords + optWords;
          if (pathWords < MIN_PATH_WORDS) {
            const pathKey = opt.key || `${scIdx + 1}${String.fromCharCode(65 + optIdx)}`;
            warnings.push(`Path "${pathKey}" total too short: ${pathWords} words (minimum ${MIN_PATH_WORDS})`);
          } else if (pathWords < TARGET_WORDS * 0.85) {
            const pathKey = opt.key || `${scIdx + 1}${String.fromCharCode(65 + optIdx)}`;
            warnings.push(`Path "${pathKey}" below target: ${pathWords} words (target ${TARGET_WORDS})`);
          }
        });
      });

      // Summary stats for logging
      const totalBranchingWords = openingWords +
        firstChoiceOptions.reduce((sum, opt) => sum + countWords(opt.response), 0) +
        secondChoices.reduce((sum, sc) => sum + (sc.options || []).reduce((s, opt) => s + countWords(opt.response), 0), 0);

      if (totalBranchingWords < 3500) {
        warnings.push(`Total branching narrative content is thin: ${totalBranchingWords} words (expected ~4000+ for full coverage)`);
      }
    } else if (content.branchingNarrative) {
      // branchingNarrative exists but is malformed
      warnings.push('Branching narrative structure incomplete: missing opening, firstChoice, or secondChoices');
    }

    // =========================================================================
    // CATEGORY 8.5: STRUCTURED FIELDS QUALITY (Bridge/Previously/Summary/Puzzle words)
    // =========================================================================
    // Bridge: hook sentence should be short.
    if (typeof content.bridgeText === 'string') {
      const bridgeWords = content.bridgeText.split(/\s+/).filter(Boolean).length;
      if (bridgeWords > 18) warnings.push(`Bridge text is long (${bridgeWords} words). Aim for <= 15 words for a punchy hook.`);
    }

    // Previously: 1-2 sentences, <= 40 words.
    if (typeof content.previously === 'string') {
      const prevWords = content.previously.split(/\s+/).filter(Boolean).length;
      if (prevWords > 60) {
        warnings.push(`"previously" is too long (${prevWords} words). Must be 1-2 sentences and <= 40 words.`);
      } else if (prevWords > 40) {
        warnings.push(`"previously" exceeds 40-word target (${prevWords}). Consider tightening.`);
      }
    }

    // NOTE: chapterSummary validation removed - field no longer in schema
    // NOTE: puzzleCandidates validation removed - user preference

    // =========================================================================
    // CATEGORY 9: PERSPECTIVE/TENSE CONSISTENCY
    // =========================================================================
    // This game is THIRD-PERSON LIMITED (close on Jack), past tense.
    // Reject first-person narration pronouns to prevent POV drift,
    // but allow first-person INSIDE dialogue.
    const containsPronounOutsideQuotes = (text, pronounRegex) => {
      if (!text) return false;
      let quoteType = null; // null = not in quote, 'single' or 'double'
      let buf = '';
      const flush = () => {
        if (!buf) return false;
        const hit = pronounRegex.test(buf);
        buf = '';
        return hit;
      };

      // Handle all common quote types, tracking single vs double separately
      // to prevent apostrophes from closing double-quoted dialogue
      // - ASCII double quote: "
      // - Left/right curly double quotes: " " (U+201C, U+201D)
      // - ASCII single quote: ' (used for dialogue in this story)
      // - Left curly single quote: ' (U+2018) - used for dialogue
      // - Right curly single quote: ' (U+2019) - used for dialogue AND apostrophes
      // NOTE: We handle ASCII single quotes now by detecting apostrophes vs dialogue context
      const isOpeningDouble = (ch) => ch === '"' || ch === '\u201C';
      const isClosingDouble = (ch) => ch === '"' || ch === '\u201D';
      const isOpeningSingle = (ch) => ch === "'" || ch === '\u2018'; // ASCII or curly quote
      const isClosingSingle = (ch) => ch === "'" || ch === '\u2019'; // ASCII or curly quote

      for (let i = 0; i < text.length; i++) {
        const ch = text[i];

        // Handle double quotes
        if (quoteType === null && isOpeningDouble(ch)) {
          if (flush()) return true;
          quoteType = 'double';
          continue;
        }
        if (quoteType === 'double' && isClosingDouble(ch)) {
          buf = '';
          quoteType = null;
          continue;
        }

        // Handle single quotes (detect apostrophes vs dialogue)
        if (quoteType === null && isOpeningSingle(ch)) {
          // Check if this looks like an apostrophe (letter on both sides) vs dialogue opening
          const nextChar = i + 1 < text.length ? text[i + 1] : '';
          const prevChar = i > 0 ? text[i - 1] : '';
          const isLikelyApostrophe = /[a-z]/i.test(prevChar) && /[a-z]/i.test(nextChar);

          if (!isLikelyApostrophe) {
            if (flush()) return true;
            quoteType = 'single';
            continue;
          }
        }
        if (quoteType === 'single' && isClosingSingle(ch)) {
          // Check if this closes dialogue (preceded by letter/punctuation, followed by space/punctuation)
          const prevChar = i > 0 ? text[i - 1] : '';
          const nextChar = i + 1 < text.length ? text[i + 1] : '';
          const isLikelyApostrophe = /[a-z]/i.test(prevChar) && /[a-z]/i.test(nextChar);

          if (!isLikelyApostrophe) {
            buf = '';
            quoteType = null;
            continue;
          }
        }

        // Only accumulate narration segments (outside quotes)
        if (quoteType === null) {
          buf += ch;
        }
      }
      return flush();
    };

    const firstPersonPronouns = /\b(?:i|me|my|mine|we|us|our|ours)\b/i;
    if (containsPronounOutsideQuotes(narrativeOriginal, firstPersonPronouns)) {
      issues.push('POV VIOLATION: First-person pronouns detected in narration. Narrative must be third-person limited past tense (dialogue may be first-person).');
    }

    // Discourage second-person narration as well (outside dialogue).
    const secondPersonPronouns = /\b(?:you|your|yours|yourself)\b/i;
    if (containsPronounOutsideQuotes(narrativeOriginal, secondPersonPronouns)) {
      warnings.push('Possible second-person phrasing detected in narration ("you/your"). Narrative should remain third-person limited.');
    }

    // =========================================================================
    // CATEGORY 10: NARRATIVE THREAD RESOLUTION ENFORCEMENT
    // =========================================================================
    // Verify that critical threads from previous chapters are addressed
    // Now uses urgency field for prioritization
    if (context.narrativeThreads && context.narrativeThreads.length > 0) {
      // Filter for threads that need resolution: critical urgency OR critical types with active status
      const criticalThreadTypes = ['appointment', 'promise', 'threat'];
      const threadsToCheck = context.narrativeThreads.filter(t => {
        if (t.status !== 'active') return false;
        // Critical urgency threads must always be addressed
        if (t.urgency === 'critical') return true;
        // Critical types should also be addressed
        if (criticalThreadTypes.includes(t.type)) return true;
        return false;
      });

      const addressedThreads = content.previousThreadsAddressed || [];

      for (const thread of threadsToCheck) {
        // Check if this thread was addressed in the generated content
        const threadDescription = (thread.description || thread.excerpt || '').toLowerCase();
        const threadKeywords = threadDescription.split(/\s+/).filter(w => w.length > 4).slice(0, 5);

        // Helper: prefix matching to allow word variations (promise/promised, meet/meeting)
        // but prevent false matches (case/showcase, rain/train)
        const wordMatchesInText = (keyword, text) => {
          // Find all words in text and check if any is a prefix match with keyword
          const words = text.match(/\b\w+\b/g) || [];
          return words.some(w => {
            if (keyword.length < 4 || w.length < 4) return keyword === w;
            return keyword.startsWith(w) || w.startsWith(keyword);
          });
        };

        const wasAddressed = addressedThreads.some(addressed => {
          if (!addressed.originalThread) return false;
          const addressedLower = addressed.originalThread.toLowerCase();
          // Check if at least 2 key words match using prefix matching
          // This allows "promise" to match "promised" but prevents "case" matching "showcase"
          const matchingKeywords = threadKeywords.filter(kw => wordMatchesInText(kw, addressedLower));
          return matchingKeywords.length >= 2;
        });

        // Also check if the thread is mentioned in the narrative itself
        const narrativeLower = narrative.toLowerCase();
        const mentionedInNarrative = threadKeywords.some(kw => wordMatchesInText(kw, narrativeLower));

        if (!wasAddressed && !mentionedInNarrative) {
          const threadChapter = thread.chapter || 0;
          const currentChapter = context.currentPosition?.chapter || 12;
          const chapterDistance = currentChapter - threadChapter;

          // Check if thread has explicit dueChapter and we've passed it
          const isOverdue = thread.dueChapter && currentChapter > thread.dueChapter;

          // Critical urgency threads are always issues if not addressed
          if (thread.urgency === 'critical' || isOverdue) {
            const deadlineInfo = thread.dueChapter
              ? `dueChapter: ${thread.dueChapter}, current: ${currentChapter}`
              : (thread.deadline || 'immediate');
            issues.push(`CRITICAL ${thread.type} thread not addressed: "${threadDescription.slice(0, 60)}..." (${deadlineInfo})`);
          } else if (chapterDistance <= 2) {
            // Recent threads of critical types are also issues
            issues.push(`Critical ${thread.type} thread not addressed: "${threadDescription.slice(0, 60)}..."`);
          } else {
            // Older threads become warnings
            warnings.push(`Older ${thread.type} thread may need resolution: "${threadDescription.slice(0, 40)}..."`);
          }
        }
      }

      // Also check for normal urgency threads that are getting stale (3+ chapters old)
      const staleNormalThreads = context.narrativeThreads.filter(t =>
        t.status === 'active' &&
        t.urgency === 'normal' &&
        (context.currentPosition?.chapter || 12) - (t.chapter || 0) >= 3
      );

      for (const thread of staleNormalThreads) {
        const threadDescription = (thread.description || thread.excerpt || '').toLowerCase();
        warnings.push(`Normal-urgency thread becoming stale (3+ chapters): "${threadDescription.slice(0, 50)}..."`);
      }
    }

    // =========================================================================
    // CATEGORY 11: PATH PERSONALITY BEHAVIOR CONSISTENCY
    // =========================================================================
    // Ensure Jack's actions match the established path personality
    // Note: Category 4 handles detailed checks; this is a broader safety net
    if (context.pathPersonality) {
      const personality = context.pathPersonality;
      // NOTE: jackBehaviorDeclaration removed from schema - now in <internal_planning>
      // Legacy validation kept for old data but won't run on new generations

      // Check for reckless behavior when player has been methodical
      if (personality.riskTolerance === 'low' || personality.narrativeStyle?.includes('cautiously')) {
        // Improved patterns: exclude standalone words that could be false positives
        const recklessPatterns = /\b(?:rushed\s+(?:in|into|forward)|stormed\s+(?:in|into|out)|burst\s+(?:in|into|through)|leapt\s+without|didn't\s+wait|threw\s+caution)\b/i;
        if (recklessPatterns.test(narrativeOriginal)) {
          warnings.push('Narrative shows reckless behavior that may conflict with methodical path personality');
        }
      }

      // Check for overly passive behavior when player has been aggressive
      if (personality.riskTolerance === 'high' || personality.narrativeStyle?.includes('decisively')) {
        const passivePatterns = /\b(?:hesitated\s+for\s+a\s+long|couldn't\s+bring\s+myself|waited\s+patiently|decided\s+to\s+observe|held\s+back\s+from)\b/i;
        if (passivePatterns.test(narrativeOriginal)) {
          warnings.push('Narrative shows passive behavior that may conflict with aggressive path personality');
        }
      }

      // NOTE: jackActionStyle field validation removed - field no longer in schema
    }

    // =========================================================================
    // CATEGORY 12: DRIFT PREVENTION (TIME LANGUAGE)
    // =========================================================================
    // Avoid vague magnitude phrasing that invites canon drift for key relationships.
    const fuzzyTimeline = [
      { pattern: /\bthree\s+decades?\b/i, warning: 'Avoid vague magnitude phrasing ("three decades"). Use exact canonical durations when referring to key relationships.' },
      { pattern: /\bdecades?\b/i, warning: 'Avoid vague magnitude phrasing ("decades"). Use exact canonical durations for key relationships.' },
      { pattern: /\b(?:years?\s+and\s+years?|for\s+years)\b/i, warning: 'Avoid vague time spans ("for years"). Use exact canonical durations when referring to key relationships.' },
    ];
    for (const { pattern, warning } of fuzzyTimeline) {
      if (pattern.test(narrativeOriginal)) warnings.push(warning);
    }

    // =========================================================================
    // CATEGORY 13: REVEAL TIMING (UNDER-MAP)
    // =========================================================================
    const currentChapter = context?.currentPosition?.chapter || 2;
    const currentSubchapter = context?.currentPosition?.subchapter || 1;
    const revealChapter = REVEAL_TIMING?.underMap?.firstUndeniable?.chapter || 1;
    const revealSubchapter = REVEAL_TIMING?.underMap?.firstUndeniable?.subchapter || DECISION_SUBCHAPTER;
    const revealLabel = REVEAL_TIMING?.underMap?.firstUndeniable?.label || `${revealChapter}${formatSubchapterLabel(revealSubchapter)}`;
    const isBeforeReveal = currentChapter < revealChapter ||
      (currentChapter === revealChapter && currentSubchapter < revealSubchapter);
    const isRevealSubchapter = currentChapter === revealChapter && currentSubchapter === revealSubchapter;

    const underMapExplicit = /\b(?:under-?map|threshold\s+(?:opened|gaped|unlatched)|the\s+city\s+rewrote\s+itself|map\s+that\s+wasn['']t\s+a\s+map)\b/i;
    // Before the reveal point, explicit Under-Map references are premature
    if (isBeforeReveal && underMapExplicit.test(narrativeOriginal)) {
      issues.push(`PREMATURE REVEAL: The Under-Map must remain plausibly deniable before the end of Chapter ${revealLabel}.`);
    }
    // In the reveal subchapter itself, only the ending should have the undeniable reveal
    if (isRevealSubchapter && underMapExplicit.test(narrativeOriginal)) {
      warnings.push(`Reveal timing note: Under-Map appears explicit in ${revealLabel}. Ensure this is at the END of the subchapter, not the beginning.`);
    }

    // Log warnings but don't block on them
    if (warnings.length > 0) {
      console.log('[ConsistencyValidator] Warnings:', warnings);
    }

    return {
      valid: issues.length === 0,
      issues,
      warnings,
    };
  }

  /**
   * Determine whether a validation issue is continuity-critical (player-facing story break)
   * and therefore must be enforced as a hard failure (fallback / regeneration), not just warned.
   *
   * PHILOSOPHY: Be VERY conservative here. Only truly story-breaking issues should cause
   * hard failures. The goal is successful generation with good-enough quality, not perfection.
   * Minor inconsistencies are acceptable - players are forgiving of small details.
   *
   * NOTE: Most issues are now treated as warnings to ensure generation succeeds.
   */
  _isContinuityCriticalIssue(issue) {
    const s = String(issue || '');
    if (!s) return false;

    // =======================================================================
    // HARD FAILURES - Story-breaking issues that must be fixed
    //
    // Philosophy: We want a "pretty great" 12-chapter experience while
    // ensuring generation succeeds. Hard failures are reserved for:
    // 1. Things that confuse the player about basic facts
    // 2. Things that break player agency (their choices must matter)
    // 3. Things that create logical impossibilities
    // =======================================================================

    // --- TIER 1: IDENTITY & WORLD FACTS ---
    // Critical name misspellings that would confuse the player
    if (s.startsWith('Name misspelled:')) return true;

    // Avoid hardcoding noir-era “signature” constraints here; story bible enforces voice/tone.

    // --- TIER 2: PLAYER AGENCY (Critical for branching narrative) ---
    // If the player made a choice, the story MUST reflect that choice
    // This is the core promise of a branching narrative game
    //
    // NOTE: CHOICE RESPECT VIOLATION removed from critical issues (2024-12).
    // The keyword-matching validation is too simplistic - it fails when the LLM
    // uses synonyms/paraphrases (e.g., "confront" vs "face", "suspect" vs "man").
    // Gemini 3 is smart enough to respect player choices without literal keyword checks.
    // The prompt already contains strong instructions to reflect decisions.
    // Keeping keyword check as WARNING only (not critical) to avoid expensive retries.
    //
    // if (s.startsWith('CHOICE RESPECT VIOLATION:')) return true;  // DISABLED - false positives
    if (s.includes('contradicts player choice')) return true;
    if (s.includes('ignores chosen path')) return true;

    // --- TIER 3: LOGICAL IMPOSSIBILITIES ---
    // Dead characters cannot appear alive without explanation
    if (s.includes('character is dead') && s.includes('appears alive')) return true;
    if (s.includes('deceased character speaking')) return true;

    // Major revelations cannot be "re-discovered" - breaks mystery pacing
    if (s.includes('already revealed') && s.includes('re-discovers')) return true;

    // NOTE: Character-specific timeline blocking rules removed.
    // Only Jack and Victoria are canonical - LLM has creative freedom for supporting characters.

    // --- TIER 4: STORY DAY CONSISTENCY ---
    // The story spans exactly 12 days, one per chapter. Wrong day = confusion.
    if (s.startsWith('STORY DAY MISMATCH:')) return true;

    // --- TIER 6: PREMATURE REVELATIONS ---
    // The mystery has a carefully designed revelation gradient.
    // Revealing major twists too early ruins the entire experience.
    if (s.startsWith('PREMATURE REVELATION:')) return true;

    // =======================================================================
    // SOFT FAILURES - Convert to warnings, don't block generation
    // These matter for quality but players are forgiving of minor issues
    // =======================================================================

    // Branching narrative word count - validation still runs, but as warning only
    // Schema now instructs LLM to generate correct lengths, so retries are wasteful
    // if (s.includes('response too short:')) return true;  // DISABLED - warning only
    // if (s.includes('opening too short:')) return true;   // DISABLED - warning only
    // if (s.includes('total too short:')) return true;     // DISABLED - warning only

    // Thread continuity - important but not worth failing over
    // if (s.startsWith('THREAD CONTINUITY VIOLATION:')) return true;  // DISABLED
    // if (s.startsWith('OVERDUE THREAD ERROR:')) return true;  // DISABLED

    // Timeline approximations (vague references) - close enough is fine
    // if (s.includes('Timeline approximation')) return true;  // DISABLED

    // Personality enforcement - Jack can have emotional moments
    // if (s.startsWith('PERSONALITY VIOLATION:')) return true;  // DISABLED

    return false;
  }

  // ==========================================================================
  // A+ QUALITY VALIDATORS - Advanced prose and narrative quality checks
  // ==========================================================================

  /**
   * Validate prose quality - checks for metaphor variety, sentence diversity, and atmosphere/voice
   * Returns quality score (0-100) and specific feedback
   */
  _validateProseQuality(narrative) {
    const issues = [];
    const warnings = [];
    let qualityScore = 100;

    // ========== 1. METAPHOR DETECTION ==========
    // Noir prose should have evocative metaphors, not generic descriptions
    const noirMetaphorPatterns = [
      /rain\s+(?:fell|poured|drummed|hammered|beat|washed|slicked|dripped)/i,
      /shadow[s]?\s+(?:stretched|crawled|pooled|swallowed|embraced|clung)/i,
      /neon\s+(?:bled|reflected|flickered|buzzed|hummed|painted|spilled)/i,
      /city\s+(?:breathed|slept|whispered|groaned|stretched|waited)/i,
      /silence\s+(?:hung|pressed|settled|wrapped|stretched|fell)/i,
      /guilt\s+(?:weighed|gnawed|clawed|settled|wrapped|clung)/i,
      /memory\s+(?:surfaced|lurked|haunted|clawed|whispered|echoed)/i,
      /truth\s+(?:cut|burned|stung|waited|lurked|surfaced)/i,
      /(?:voice|words?)\s+(?:cut|sliced|dripped|hung|fell|echoed)/i,
      /eyes\s+(?:burned|bored|searched|narrowed|softened|hardened)/i,
    ];

    const metaphorCount = noirMetaphorPatterns.reduce((count, pattern) => {
      return count + (narrative.match(pattern)?.length || 0);
    }, 0);

    const wordCount = narrative.split(/\s+/).length;
    const expectedMetaphors = Math.max(2, Math.floor(wordCount / 200)); // Expect 1 per 200 words, minimum 2

    if (metaphorCount < expectedMetaphors) {
      warnings.push(`Prose lacks atmospheric texture: only ${metaphorCount} evocative metaphors found (expected ${expectedMetaphors}+). Add sensory/setting grounding.`);
      qualityScore -= 10;
    }

    // ========== 2. SENSORY DETAIL CHECK ==========
    // Strong prose engages multiple senses
    const sensoryPatterns = {
      visual: /\b(?:saw|watched|looked|glanced|neon|shadow|dark|light|glow|flicker|gleam|shine)\b/gi,
      auditory: /\b(?:heard|sound|noise|whisper|echo|creak|hum|buzz|silence|quiet|jukebox|rain\s+(?:drummed|hammered|pattered))\b/gi,
      tactile: /\b(?:felt|cold|warm|wet|damp|rough|smooth|grip|touch|chill|sting|burn)\b/gi,
      olfactory: /\b(?:smell|scent|odor|stink|perfume|smoke|whiskey|rain|musk|sweat)\b/gi,
      taste: /\b(?:taste|bitter|sweet|sour|whiskey|bourbon|coffee|blood)\b/gi,
    };

    const sensoryHits = {};
    let totalSensory = 0;
    for (const [sense, pattern] of Object.entries(sensoryPatterns)) {
      const matches = narrative.match(pattern) || [];
      sensoryHits[sense] = matches.length;
      totalSensory += matches.length;
    }

    const sensesCovered = Object.values(sensoryHits).filter(v => v > 0).length;
    if (sensesCovered < 3) {
      warnings.push(`Limited sensory engagement: only ${sensesCovered}/5 senses used. Add ${['visual', 'auditory', 'tactile', 'olfactory', 'taste'].filter(s => !sensoryHits[s]).join(', ')} details.`);
      qualityScore -= 5;
    }

    // ========== 3. DIALOGUE QUALITY CHECK ==========
    // Extract dialogue and check for quality
    // Support both ASCII quotes (") and curly/smart quotes (" ")
    const dialogueMatches = narrative.match(/[""\u201C][^""\u201C\u201D]+[""\u201D]/g) || [];
    if (dialogueMatches.length > 0) {
      // Check for weak dialogue tags
      const weakTags = /(?:he|she|i)\s+(?:said|asked|replied)\s+(?:quietly|loudly|softly|quickly|slowly)/gi;
      if (weakTags.test(narrative)) {
        warnings.push('Weak dialogue tags with adverbs detected. Show emotion through action beats instead.');
        qualityScore -= 3;
      }

      // Check for talking heads (no action beats between dialogue)
      // Support both ASCII and curly quotes
      const consecutiveDialogue = narrative.match(/[""\u201C][^""\u201C\u201D]+[""\u201D]\s*\n*\s*[""\u201C][^""\u201C\u201D]+[""\u201D]\s*\n*\s*[""\u201C][^""\u201C\u201D]+[""\u201D]\s*\n*\s*[""\u201C][^""\u201C\u201D]+[""\u201D]/g);
      if (consecutiveDialogue && consecutiveDialogue.length > 0) {
        warnings.push('Dialogue passages lack action beats. Break up long exchanges with physical actions or observations.');
        qualityScore -= 5;
      }
    }

    // ========== 4. PARAGRAPH VARIETY CHECK ==========
    const paragraphs = narrative.split(/\n\n+/).filter(p => p.trim().length > 0);
    if (paragraphs.length > 0) {
      const paragraphLengths = paragraphs.map(p => p.split(/\s+/).length);
      const avgLength = paragraphLengths.reduce((a, b) => a + b, 0) / paragraphLengths.length;
      const variance = paragraphLengths.reduce((sum, len) => sum + Math.pow(len - avgLength, 2), 0) / paragraphLengths.length;

      // Low variance means monotonous paragraph structure
      if (variance < 100 && paragraphs.length > 3) {
        warnings.push(`Monotonous paragraph structure: variance ${Math.round(variance)}. Vary paragraph lengths for better pacing.`);
        qualityScore -= 5;
      }
    }

    // ========== 5. OPENING QUALITY CHECK ==========
    const firstParagraph = paragraphs[0] || '';
    const hasAtmosphericOpening = noirMetaphorPatterns.some(p => p.test(firstParagraph)) ||
                                   /\b(?:rain|shadow|night|dark|neon|city|street)\b/i.test(firstParagraph);

    if (!hasAtmosphericOpening && wordCount > 200) {
      warnings.push('Opening lacks atmospheric grounding. Start with sensory scene-setting.');
      qualityScore -= 5;
    }

    // ========== 6. ATMOSPHERE DENSITY CHECK (Positive requirement) ==========
    // Noir prose REQUIRES atmospheric elements - not just absence of forbidden ones
    const atmospherePatterns = {
      weather: /\b(?:rain|drizzle|downpour|storm|mist|fog|damp|wet|puddle|umbrella|overcast|cloud|grey|gray)\b/gi,
      lighting: /\b(?:neon|shadow|dark|dim|glow|flicker|lamp|streetlight|moonlight|fluorescent|bulb)\b/gi,
      urbanTexture: /\b(?:concrete|brick|alley|street|gutter|pavement|curb|sidewalk|corner|building)\b/gi,
      noirMood: /\b(?:smoke|cigarette|whiskey|bourbon|glass|bottle|bar|jukebox|mirror|booth)\b/gi,
      timeOfDay: /\b(?:night|midnight|dawn|dusk|evening|late|early|hour|clock|morning)\b/gi,
    };

    const atmosphereHits = {};
    let totalAtmosphere = 0;
    for (const [category, pattern] of Object.entries(atmospherePatterns)) {
      const matches = narrative.match(pattern) || [];
      atmosphereHits[category] = matches.length;
      totalAtmosphere += matches.length;
    }

    // Require minimum atmosphere density (at least 3 categories represented)
    const categoriesCovered = Object.values(atmosphereHits).filter(v => v > 0).length;
    if (categoriesCovered < 3) {
      warnings.push(`Thin atmosphere: only ${categoriesCovered}/5 atmosphere categories present (weather, lighting, urban texture, mood, time). Add more environmental grounding.`);
      qualityScore -= 5;
    }

    // Check density relative to word count (expect ~1 atmospheric element per 50 words)
    const expectedAtmosphere = Math.floor(wordCount / 50);
    if (totalAtmosphere < expectedAtmosphere * 0.5) {
      warnings.push(`Low atmosphere density: ${totalAtmosphere} elements in ${wordCount} words (expected ${expectedAtmosphere}+). Scene feels sterile - add rain, neon, shadows, smoke.`);
      qualityScore -= 5;
    }

    // ========== 7. GENERIC PHRASE DETECTION ==========
    // Detect phrases that feel AI-generated or generic
    const genericPatterns = [
      { pattern: /\bthe air\s+(?:was|felt)\s+(?:thick|heavy|tense)\b/i, issue: 'Generic atmosphere: "the air was thick/heavy"' },
      { pattern: /\bmy\s+(?:heart|pulse)\s+(?:raced|pounded|quickened)\b/i, issue: 'Generic tension: heart racing/pounding' },
      { pattern: /\ba\s+(?:chill|shiver)\s+(?:ran|went)\s+down\s+(?:my|his|her)\s+spine\b/i, issue: 'Cliché: chill down spine' },
      { pattern: /\btime\s+(?:seemed\s+to\s+)?(?:stood|stopped|froze|slowed)\b/i, issue: 'Cliché: time stopped/froze' },
      { pattern: /\beverything\s+(?:changed|happened)\s+(?:so\s+)?fast\b/i, issue: 'Generic pacing: everything happened fast' },
    ];

    for (const { pattern, issue } of genericPatterns) {
      if (pattern.test(narrative)) {
        warnings.push(`${issue} - rewrite with more specific imagery`);
        qualityScore -= 3;
      }
    }

    return {
      score: Math.max(0, qualityScore),
      issues,
      warnings,
      details: {
        metaphorCount,
        sensoryHits,
        atmosphereHits,
        atmosphereDensity: totalAtmosphere,
        dialogueCount: dialogueMatches.length,
        paragraphCount: paragraphs.length,
        hasAtmosphericOpening,
      },
    };
  }

  /**
   * Validate character voice consistency in dialogue
   * Ensures Victoria sounds distinct and matches her established voice
   * NOTE: Only Jack and Victoria are canonical characters - LLM has freedom for others
   */
  _validateCharacterVoices(narrative) {
    const issues = [];
    const warnings = [];

    // Only Victoria has canonical voice constraints - other characters are LLM-generated
    // Victoria should never sound casual or use slang
    const victoriaDialogue = narrative.match(/(?:victoria|blackwell)\s+(?:said|spoke|replied|whispered)[^""\u201C\u201D]*[""\u201C]([^""\u201C\u201D]+)[""\u201D]/gi) || [];
    for (const match of victoriaDialogue) {
      const text = match.match(/[""\u201C]([^""\u201C\u201D]+)[""\u201D]/)?.[1] || '';
      if (/\b(?:gonna|gotta|ain't|ya|hey|buddy|pal|like,?\s+you\s+know|whatever)\b/i.test(text)) {
        issues.push('Victoria uses overly casual language - should be elegant and formal');
      }
    }

    return { issues, warnings };
  }

  // ==========================================================================
  // PROMPT DIAGNOSTICS - Verify all components are being included
  // ==========================================================================

  // ==========================================================================
  // LLM-BASED VALIDATION - Semantic understanding of rule violations
  // ==========================================================================

  /**
   * Validate content using LLM for semantic understanding
   * This catches violations that regex can't detect (e.g., wrong years, contradictions)
   * Uses a fast, cheap LLM call with minimal thinking
   * @param {Object} content - Generated content to validate
   * @param {Object} context - Story context
   * @returns {Promise<Object>} Validation result with issues and suggestions
   */
  async _validateWithLLM(content, context) {
    const { protagonist, antagonist, setting } = ABSOLUTE_FACTS;
    const narrative = content.narrative || '';
    const revealLabel = REVEAL_TIMING?.underMap?.firstUndeniable?.label || `1${formatSubchapterLabel(DECISION_SUBCHAPTER)}`;

    // Skip for very short content
    if (narrative.length < 200) {
      return { issues: [], suggestions: [], validated: false, reason: 'content too short' };
    }

    console.log(`[StoryGen] 🔍 Running LLM validation on ${narrative.length} chars...`);

    // ========== CRITICAL THREAD CHECKING ==========
    // Extract critical/overdue threads that MUST be addressed
    const currentChapter = context.currentPosition?.chapter || 1;
    const criticalThreads = (context.narrativeThreads || [])
      .filter(t => t.status === 'active')
      .filter(t => {
        const isOverdue = t.dueChapter && currentChapter > t.dueChapter;
        const isCritical = t.urgency === 'critical';
        const isUrgentType = ['appointment', 'promise', 'threat'].includes(t.type);
        return isOverdue || isCritical || isUrgentType;
      })
      .slice(0, 5); // Top 5 most critical threads

    const threadSection = criticalThreads.length > 0 ? `
## CRITICAL THREADS (Must be addressed in narrative):
${criticalThreads.map((t, i) => `${i + 1}. [${t.type}] ${t.description}${t.dueChapter ? ` (Due: Ch${t.dueChapter})` : ''}`).join('\n')}

Check if each critical thread above is addressed through dialogue or action (not just thoughts).
` : '';

    try {
      const validationPrompt = `You are a strict continuity editor for a modern mystery thriller with a hidden fantasy layer (the Under-Map). Check this narrative excerpt for FACTUAL ERRORS and THREAD VIOLATIONS.

## ABSOLUTE FACTS (Cannot be contradicted):
- ${protagonist.fullName}: ${protagonist.age} years old; ${protagonist.formerTitle.toLowerCase()}; ${protagonist.currentStatus.toLowerCase()}; initially does NOT know the Under-Map is real
- ${antagonist.trueName}: sends dead letters with ${antagonist.communication.ink.toLowerCase()}; guides Jack via rules and routes
- Setting: modern ${setting.city}; hidden layer threaded through infrastructure; no Tolkien-style medieval fantasy
- Reveal timing: first undeniable "the world is not what it seems" reveal occurs at the END of ${revealLabel}, not earlier
- Other characters: The LLM has creative freedom to generate supporting characters as needed
${threadSection}
## NARRATIVE TO CHECK:
${narrative.slice(0, TRUNCATE_VALIDATION)}${narrative.length > 3000 ? '\n[truncated]' : ''}

## INSTRUCTIONS:
1. Look for ANY factual contradictions (wrong years, wrong relationships, wrong names)
2. Check timeline references ("X years ago" must match the facts above)
3. Check character relationships (who knows who, how long)
4. Check setting details (city name, locations)
${criticalThreads.length > 0 ? '5. Verify each CRITICAL THREAD is addressed (through dialogue/action, not just thought)' : ''}

Respond with JSON:
{
  "hasIssues": true/false,
  "issues": ["specific issue 1", "specific issue 2"],
  "suggestions": ["how to fix issue 1", "how to fix issue 2"],
  "unaddressedThreads": ["thread description if not addressed"],
  "confidence": "high"/"medium"/"low"
}

If no issues found, return: { "hasIssues": false, "issues": [], "suggestions": [], "unaddressedThreads": [], "confidence": "high" }`;

      const response = await llmService.complete(
        [{ role: 'user', content: validationPrompt }],
        {
          systemPrompt: 'You are a meticulous continuity editor. Find factual errors and unaddressed plot threads. Be specific. No false positives.',
          maxTokens: GENERATION_CONFIG.maxTokens.llmValidation,
          responseSchema: {
            type: 'object',
            properties: {
              hasIssues: { type: 'boolean' },
              issues: { type: 'array', items: { type: 'string' } },
              suggestions: { type: 'array', items: { type: 'string' } },
              unaddressedThreads: { type: 'array', items: { type: 'string' } },
              confidence: { type: 'string', enum: ['high', 'medium', 'low'] },
            },
            required: ['hasIssues', 'issues', 'suggestions', 'unaddressedThreads', 'confidence'],
          },
          traceId: `validation-${Date.now()}`,
          thinkingLevel: 'low', // Fast validation, don't need deep reasoning
        }
      );

      // Track token usage
      this._trackTokenUsage(response?.usage, 'LLM Validation');

      // Check for truncation
      if (response.isTruncated || response.finishReason === 'MAX_TOKENS') {
        console.warn('[StoryGen] ⚠️ LLM validation response truncated (hit maxTokens). Validation skipped.');
        return { issues: [], suggestions: [], validated: false, reason: 'truncated response' };
      }

      // Parse response
      let result;
      try {
        result = typeof response.content === 'string'
          ? JSON.parse(response.content)
          : response.content;
      } catch (parseErr) {
        console.warn('[StoryGen] ⚠️ Failed to parse LLM validation response:', parseErr.message);
        return { issues: [], suggestions: [], validated: false, reason: 'parse error' };
      }

      // Combine regular issues with unaddressed thread issues
      const allIssues = [...(result.issues || [])];
      const unaddressedThreads = result.unaddressedThreads || [];

      // Add unaddressed threads as issues
      if (unaddressedThreads.length > 0) {
        unaddressedThreads.forEach(thread => {
          allIssues.push(`[THREAD] Unaddressed critical thread: ${thread}`);
        });
        console.log(`[StoryGen] ⚠️ ${unaddressedThreads.length} critical threads not addressed in narrative`);
      }

      if (allIssues.length > 0) {
        console.log(`[StoryGen] ❌ LLM validation found ${allIssues.length} issues:`);
        allIssues.forEach((issue, i) => {
          console.log(`  ${i + 1}. ${issue}`);
          // Safe access: check if suggestions array exists and has this index
          if (result.suggestions && result.suggestions[i]) {
            console.log(`     → Fix: ${result.suggestions[i]}`);
          }
        });
      } else {
        console.log(`[StoryGen] ✅ LLM validation passed (confidence: ${result.confidence || 'unknown'})`);
      }

      return {
        issues: allIssues,
        suggestions: result.suggestions || [],
        unaddressedThreads,
        confidence: result.confidence || 'medium',
        validated: true,
      };

    } catch (error) {
      console.warn(`[StoryGen] ⚠️ LLM validation failed:`, error.message);
      return { issues: [], suggestions: [], validated: false, reason: error.message };
    }
  }

  /**
   * Validate sentence variety to prevent monotonous prose
   * Checks for I-stacking, sentence length variety, and opener diversity
   */
  _validateSentenceVariety(narrative) {
    const issues = [];
    const warnings = [];

    const sentences = narrative.match(/[^.!?]+[.!?]+/g) || [];
    if (sentences.length < 5) {
      return { issues, warnings }; // Not enough sentences to validate
    }

    // ========== 1. I-STACKING DETECTION ==========
    // Count sentences starting with "I"
    let consecutiveIStarts = 0;
    let maxConsecutiveI = 0;
    let totalIStarts = 0;

    for (const sentence of sentences) {
      const trimmed = sentence.trim();
      if (/^I\s+(?!didn't|don't|won't|can't|couldn't|wouldn't|shouldn't)/i.test(trimmed)) {
        consecutiveIStarts++;
        totalIStarts++;
        maxConsecutiveI = Math.max(maxConsecutiveI, consecutiveIStarts);
      } else {
        consecutiveIStarts = 0;
      }
    }

    // I-stacking is now a WARNING, not an error - stylistic issue shouldn't trigger retries
    if (maxConsecutiveI >= 4) {
      warnings.push(`I-stacking detected: ${maxConsecutiveI} consecutive sentences start with "I". Vary sentence openers.`);
    } else if (maxConsecutiveI >= 3) {
      warnings.push(`Minor I-stacking: ${maxConsecutiveI} consecutive "I" sentences. Consider varying openers.`);
    }

    const iPercentage = (totalIStarts / sentences.length) * 100;
    if (iPercentage > 50) {
      warnings.push(`${Math.round(iPercentage)}% of sentences start with "I". Aim for under 40%.`);
    }

    // ========== 2. SENTENCE LENGTH VARIETY ==========
    const sentenceLengths = sentences.map(s => s.trim().split(/\s+/).length);
    const avgLength = sentenceLengths.reduce((a, b) => a + b, 0) / sentenceLengths.length;

    // Check for monotonous length (all sentences within 5 words of average)
    const nearAverage = sentenceLengths.filter(len => Math.abs(len - avgLength) < 5).length;
    const monotonyRatio = nearAverage / sentenceLengths.length;

    if (monotonyRatio > 0.8) {
      warnings.push(`Monotonous sentence length: ${Math.round(monotonyRatio * 100)}% near average (${Math.round(avgLength)} words). Mix short punchy sentences with longer ones.`);
    }

    // Check for at least some short sentences (under 8 words) for punch
    const shortSentences = sentenceLengths.filter(len => len < 8).length;
    if (shortSentences < sentences.length * 0.1) {
      warnings.push('Few short sentences for impact. Add punchy 3-7 word sentences for rhythm.');
    }

    // ========== 3. OPENER VARIETY ==========
    // Check first words of sentences for variety
    const openers = sentences.map(s => s.trim().split(/\s+/)[0]?.toLowerCase()).filter(Boolean);
    const openerCounts = {};
    for (const opener of openers) {
      openerCounts[opener] = (openerCounts[opener] || 0) + 1;
    }

    // Any opener used more than 25% of the time is overused
    for (const [opener, count] of Object.entries(openerCounts)) {
      const percentage = (count / openers.length) * 100;
      if (percentage > 25 && count >= 4) {
        warnings.push(`Opener "${opener}" overused: ${Math.round(percentage)}% of sentences. Vary your sentence starts.`);
      }
    }

    // ========== 4. PARAGRAPH OPENER VARIETY ==========
    const paragraphs = narrative.split(/\n\n+/).filter(p => p.trim());
    const paragraphOpeners = paragraphs.map(p => p.trim().split(/\s+/).slice(0, 3).join(' ').toLowerCase());

    // Check for repeated paragraph openers (e.g., "The rain..." "The city...")
    const paraOpenerCounts = {};
    for (const opener of paragraphOpeners) {
      // Check first 2 words
      const key = opener.split(/\s+/).slice(0, 2).join(' ');
      paraOpenerCounts[key] = (paraOpenerCounts[key] || 0) + 1;
    }

    for (const [opener, count] of Object.entries(paraOpenerCounts)) {
      if (count >= 3) {
        warnings.push(`Paragraph opener pattern "${opener}..." used ${count} times. Vary paragraph beginnings.`);
      }
    }

    return { issues, warnings };
  }

  /**
   * Setup/Payoff Registry - Track story setups that require payoffs
   * Critical for maintaining narrative promises across chapters
   */
  _setupPayoffRegistry = new Map();

  /**
   * Initialize setup/payoff tracking for major story revelations
   * Called once at the start of story generation
   */
  _initializeSetupPayoffRegistry() {
    const registry = Array.isArray(SETUP_PAYOFF_REGISTRY) ? SETUP_PAYOFF_REGISTRY : [];
    this._setupPayoffRegistry.clear();

    for (const revelation of registry) {
      if (!revelation?.id) continue;
      this._setupPayoffRegistry.set(revelation.id, {
        ...revelation,
        setupsFound: [],
        payoffDelivered: false,
        payoffChapter: null,
      });
    }
  }

  /**
   * Track setups found in generated content
   */
  _trackSetups(narrative, chapter, subchapter) {
    const narrativeLower = narrative.toLowerCase();

    for (const [id, revelation] of this._setupPayoffRegistry.entries()) {
      if (revelation.payoffDelivered) continue;

      // Check for setups
      for (const setup of revelation.requiredSetups) {
        const setupPatterns = this._generateSetupPatterns(setup);
        for (const pattern of setupPatterns) {
          if (pattern.test(narrativeLower)) {
            if (!revelation.setupsFound.includes(setup)) {
              revelation.setupsFound.push(setup);
              console.log(`[SetupPayoff] Found setup for ${id}: "${setup}" in Chapter ${chapter}.${subchapter}`);
            }
            break;
          }
        }
      }
    }
  }

  /**
   * Generate regex patterns for setup detection
   */
  _generateSetupPatterns(setup) {
    const setupLower = setup.toLowerCase();
    const patterns = [];

    // Direct keyword matching
    const keywords = setupLower.match(/\b\w{4,}\b/g) || [];
    if (keywords.length >= 2) {
      // Pattern: at least 2 keywords within 100 characters
      patterns.push(new RegExp(keywords.slice(0, 2).join('.*').replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/\\\.\\\*/g, '.{0,100}'), 'i'));
    }

    if (/\btom\b/i.test(setupLower)) {
      patterns.push(/tom.*(?:map|atlas|archive|symbols?|glyphs?)/i, /wade.*(?:map|atlas|archive|symbols?|glyphs?)/i);
    }
    if (/\bvictoria\b/i.test(setupLower)) {
      patterns.push(/victoria.*(?:know|knew|knows|watch|watched|map|mapped|cartograph)/i, /blackwell.*(?:secret|rules?|map|cartograph|glyph)/i);
    }
    if (/\bgrange\b/i.test(setupLower)) {
      patterns.push(/grange.*(?:sealed|contained|erased|suppressed|warning)/i, /deputy.*(?:chief|suspicious|sealed|contained)/i);
    }
    if (/\bsilas\b/i.test(setupLower)) {
      patterns.push(/silas.*(?:drink|guilt|hiding|secret)/i, /reed.*(?:nervous|scared)/i);
    }
    if (/\bthornhill\b/i.test(setupLower)) {
      patterns.push(/thornhill.*(?:case|frame|innocent|dead)/i, /marcus.*(?:suicide|lockup)/i);
    }

    return patterns;
  }

  /**
   * Validate setup/payoff balance before major revelations
   */
  _validateSetupPayoff(chapter, narrative) {
    const issues = [];
    const warnings = [];

    for (const [id, revelation] of this._setupPayoffRegistry.entries()) {
      // Check if this narrative contains the payoff
      const payoffPatterns = Array.isArray(revelation.payoffPatterns)
        ? revelation.payoffPatterns
        : this._generatePayoffPatterns(id);
      const hasPayoff = payoffPatterns.some(p => p.test(narrative.toLowerCase()));

      if (hasPayoff) {
        // Validate sufficient setup before payoff
        if (revelation.setupsFound.length < revelation.minSetupCount) {
          issues.push(`PAYOFF WITHOUT SETUP: "${revelation.payoff}" revealed but only ${revelation.setupsFound.length}/${revelation.minSetupCount} required setups found. Previous setups: ${revelation.setupsFound.join(', ') || 'none'}`);
        }

        // Check timing
        if (chapter < revelation.earliestPayoffChapter) {
          warnings.push(`Early payoff: "${revelation.payoff}" in Chapter ${chapter} (recommended: ${revelation.earliestPayoffChapter}+)`);
        }

        revelation.payoffDelivered = true;
        revelation.payoffChapter = chapter;
      }

      // Warn if approaching latest payoff chapter without sufficient setup
      if (!revelation.payoffDelivered && chapter >= revelation.latestPayoffChapter - 1) {
        if (revelation.setupsFound.length < revelation.minSetupCount) {
          warnings.push(`Approaching deadline for "${revelation.payoff}" (Chapter ${revelation.latestPayoffChapter}) with only ${revelation.setupsFound.length}/${revelation.minSetupCount} setups. Add more foreshadowing.`);
        }
      }
    }

    return { issues, warnings };
  }

  /**
   * Generate patterns to detect payoff delivery
   * NOTE: Prefer data-driven patterns from SETUP_PAYOFF_REGISTRY.
   */
  _generatePayoffPatterns(revelationId) {
    const registryEntry = this._setupPayoffRegistry.get(revelationId);
    if (Array.isArray(registryEntry?.payoffPatterns)) {
      return registryEntry.payoffPatterns;
    }
    return [];
  }

  /**
   * Validate arc closure in final chapters (11-12)
   * Ensures all major threads and revelations are resolved before story ends
   */
  _validateArcClosure(chapter, context) {
    const issues = [];
    const warnings = [];

    // Only enforce arc closure in final chapters
    if (chapter < 11) {
      return { issues, warnings };
    }

    // Check for undelivered revelations
    for (const [id, revelation] of this._setupPayoffRegistry.entries()) {
      if (!revelation.payoffDelivered) {
        if (chapter === 12) {
          // Chapter 12: All major revelations MUST be delivered
          issues.push(`ARC CLOSURE REQUIRED: Major revelation "${revelation.payoff}" has not been delivered. This is the final chapter - all major plot points must resolve.`);
        } else if (chapter === 11) {
          // Chapter 11: Warn about undelivered revelations
          warnings.push(`Approaching finale: "${revelation.payoff}" still undelivered. Ensure this is revealed in chapters 11-12.`);
        }
      }
    }

    // Check for unresolved critical threads
    if (context.narrativeThreads && context.narrativeThreads.length > 0) {
      const unresolvedCritical = context.narrativeThreads.filter(t =>
        t.status === 'active' &&
        (t.urgency === 'critical' || t.type === 'appointment' || t.type === 'promise')
      );

      if (chapter === 12 && unresolvedCritical.length > 0) {
        issues.push(`ARC CLOSURE REQUIRED: ${unresolvedCritical.length} critical thread(s) still unresolved in final chapter: ${unresolvedCritical.slice(0, 3).map(t => t.description?.slice(0, 40)).join('; ')}...`);
      } else if (chapter === 11 && unresolvedCritical.length > 3) {
        warnings.push(`Too many unresolved threads (${unresolvedCritical.length}) entering finale. Prioritize resolution.`);
      }
    }

    // Check that Victoria confrontation happens
    if (chapter === 12) {
      const victoriaThread = context.narrativeThreads?.find(t =>
        t.description?.toLowerCase().includes('victoria') ||
        t.description?.toLowerCase().includes('blackwell')
      );
      if (!victoriaThread || victoriaThread.status !== 'resolved') {
        warnings.push('Final chapter should include climactic confrontation involving Victoria Blackwell');
      }
    }

    return { issues, warnings };
  }

  /**
   * Attempt to fix content that failed validation
   * NOW INCLUDES A+ QUALITY GUIDANCE for fixing prose issues
   */
  async _fixContent(content, issues, context, isDecisionPoint) {
    // Categorize issues for targeted fixing
    const proseIssues = issues.filter(i =>
      i.includes('metaphor') || i.includes('sensory') || i.includes('I-stacking') ||
      i.includes('sentence') || i.includes('opener') || i.includes('atmosphere') ||
      i.includes('dialogue') || i.includes('monotonous') || i.includes('Generic')
    );
    const consistencyIssues = issues.filter(i => !proseIssues.includes(i));

    // Build quality guidance for prose fixes
    const proseGuidance = proseIssues.length > 0 ? `
## A+ PROSE QUALITY REQUIREMENTS
Your rewrite MUST address these prose quality issues:
${proseIssues.map(i => `- ${i}`).join('\n')}

To fix these:
1. **Metaphors**: Add modern urban-uncanny imagery (reflections misbehaving, signage “almost” shifting, paper/ink that feels alive)
2. **Sensory details**: Engage sight, sound, smell, touch, taste
3. **Sentence variety**: Mix short punchy sentences (3-7 words) with longer flowing ones
4. **Opener diversity**: Vary how sentences and paragraphs begin (not all "I" or "The")
5. **Atmospheric grounding**: Open scenes with weather, lighting, physical setting
6. **Dialogue**: Break up exchanges with action beats (what characters DO while talking)

Example texture to emulate:
"Ashport looked ordinary until you stared long enough. Reflections didn't match their sources. A street sign held a curve that belonged on paper, not metal. The city kept pretending nothing was happening."
` : '';

    const fixPrompt = `The following generated story content contains violations that must be fixed.

## CONSISTENCY ISSUES TO FIX:
${consistencyIssues.length > 0 ? consistencyIssues.map(i => `- ${i}`).join('\n') : '(none)'}
${proseGuidance}

## CRITICAL RULES:
1. Maintain the exact plot and story events
2. Keep all character names spelled correctly
3. Use exact canonical numbers when they matter (do not “round” or invent durations)
4. Stay in third-person limited past tense (close on Jack)
5. Never use forbidden words: delve, unravel, tapestry, myriad, whilst, realm

## ORIGINAL CONTENT:
${JSON.stringify(content, null, 2)}

Rewrite the narrative to fix ALL issues while maintaining the story's thriller tone and progression.`;

    const responseSchema = isDecisionPoint
      ? DECISION_CONTENT_SCHEMA
      : STORY_CONTENT_SCHEMA;

    const response = await llmService.complete(
      [{ role: 'user', content: fixPrompt }],
      {
        systemPrompt: 'You are an expert thriller editor. Fix all issues while enhancing atmosphere and clarity. Never change the plot, only improve the writing.',
        maxTokens: GENERATION_CONFIG.maxTokens.subchapter,
        responseSchema,
      }
    );

    return this._parseGeneratedContent(response.content, isDecisionPoint);
  }

  // ==========================================================================
  // BOARD GENERATION (Puzzle data)
  // ==========================================================================

  /**
   * Generate board data for the puzzle
   * Now uses static word list (puzzle redesign pending)
   *
   * @param {boolean} isDecisionPoint - Whether this is a decision subchapter
   * @param {object} decision - Decision data for decision points
   */
  _generateBoardData(isDecisionPoint, decision) {
    // Static word list for evidence board puzzle (puzzle redesign pending)
    const staticWords = [
      'SHADOW', 'TRUTH', 'GLYPH', 'SILVER', 'TOKEN', 'ANCHOR',
      'THRESHOLD', 'PATTERN', 'WITNESS', 'CIPHER', 'SIGNAL', 'TRACE',
      'HIDDEN', 'PASSAGE', 'ARCHIVE', 'REFLECT'
    ];

    // Shuffle the static words
    const shuffledWords = this._shuffleArray([...staticWords]);

    // Build 4x4 grid
    const grid = [];
    for (let row = 0; row < 4; row++) {
      grid.push(shuffledWords.slice(row * 4, (row + 1) * 4));
    }

    // First 4 words are "outliers" (placeholder until puzzle redesign)
    const outlierWords = shuffledWords.slice(0, 4);

    const boardResult = {
      outlierWords,
      grid,
      outlierTheme: {
        name: 'INVESTIGATION',
        icon: '\ud83d\udd0e',
        summary: 'Follow the clues...',
      },
    };

    // For decision points, split outliers into two sets
    if (isDecisionPoint && decision?.options?.length >= 2) {
      boardResult.branchingOutlierSets = [
        {
          optionKey: decision.options[0].key || 'A',
          key: decision.options[0].key || 'A',
          label: decision.options[0].key || 'A',
          theme: {
            name: 'PATH A',
            icon: '\ud83d\udd34',
            summary: decision.options[0].focus || 'Option A',
          },
          words: outlierWords.slice(0, 2),
          descriptions: {},
        },
        {
          optionKey: decision.options[1].key || 'B',
          key: decision.options[1].key || 'B',
          label: decision.options[1].key || 'B',
          theme: {
            name: 'PATH B',
            icon: '\ud83d\udd35',
            summary: decision.options[1].focus || 'Option B',
          },
          words: outlierWords.slice(2, 4),
          descriptions: {},
        },
      ];
    }

    return boardResult;
  }

  // ==========================================================================
  // UTILITY METHODS
  // ==========================================================================

  async _updateStoryContext(entry) {
    const context = this.storyContext || {
      characters: {},
      plotPoints: [],
      revelations: [],
      relationships: {},
      // Backward-compat rolling facts (do not use for generation anymore).
      consistencyFacts: [],
      // Preferred: facts keyed by cumulative branch key.
      consistencyFactsByPathKey: {},
    };

    context.lastGeneratedChapter = entry.chapter;
    context.lastGeneratedSubchapter = entry.subchapter;
    context.lastPathKey = entry.pathKey;

    // Store consistency facts
    if (entry.consistencyFacts?.length > 0) {
      const pk = entry.pathKey || 'ROOT';
      if (!context.consistencyFactsByPathKey || typeof context.consistencyFactsByPathKey !== 'object') {
        context.consistencyFactsByPathKey = {};
      }

      const existing = context.consistencyFactsByPathKey[pk];
      const existingFacts = Array.isArray(existing?.facts) ? existing.facts : Array.isArray(existing) ? existing : [];
      const merged = [...existingFacts, ...entry.consistencyFacts].slice(-50); // Keep last 50 per path
      context.consistencyFactsByPathKey[pk] = {
        facts: merged,
        updatedAt: entry.generatedAt || new Date().toISOString(),
      };

      // Keep the legacy rolling array too (for older code paths / debug tooling),
      // but generation should NOT consume it (it causes branch bleed).
      context.consistencyFacts = [
        ...(context.consistencyFacts || []),
        ...entry.consistencyFacts,
      ].slice(-50);

      // Bound total number of stored paths to prevent unbounded growth from prefetching.
      try {
        const keys = Object.keys(context.consistencyFactsByPathKey || {});
        const MAX_PATHS = 24;
        if (keys.length > MAX_PATHS) {
          // Prefer to keep prefixes of the current path (they're always relevant),
          // then keep the most recently updated remaining paths.
          // Always keep ROOT - it contains pre-branch facts from Chapters 1-2.
          const current = String(context.lastPathKey || 'ROOT');
          const keep = new Set(keys.filter((k) => k === 'ROOT' || current.startsWith(k)));
          const rest = keys
            .filter((k) => !keep.has(k))
            .sort((a, b) => {
              const ta = new Date(context.consistencyFactsByPathKey[a]?.updatedAt || 0).getTime();
              const tb = new Date(context.consistencyFactsByPathKey[b]?.updatedAt || 0).getTime();
              return tb - ta; // newest first
            });
          for (const k of rest) {
            if (keep.size >= MAX_PATHS) break;
            keep.add(k);
          }
          for (const k of keys) {
            if (!keep.has(k)) delete context.consistencyFactsByPathKey[k];
          }
        }
      } catch (e) {
        // Never block story saving for pruning issues.
      }
    }

    this.storyContext = context;
    await saveStoryContext(context);
  }

  /**
   * Return persisted consistency facts relevant to a given cumulative pathKey.
   *
   * We only include facts for path keys that are prefixes of the current pathKey,
   * because those represent decisions the player actually made on the way here.
   * This prevents branch bleed from background prefetching alternative paths.
   */
  _getRelevantPersistedConsistencyFacts(pathKey) {
    const pk = String(pathKey || 'ROOT');
    const ctx = this.storyContext || {};
    const map = ctx.consistencyFactsByPathKey;

    // Backward compatibility: old installs only have a single rolling array.
    if (!map || typeof map !== 'object') {
      return Array.isArray(ctx.consistencyFacts) ? ctx.consistencyFacts.slice(-50) : [];
    }

    const facts = [];
    for (const [k, v] of Object.entries(map)) {
      if (!k) continue;
      // Always include ROOT facts (pre-branch content from Chapters 1-2)
      // plus facts from any path that is a prefix of the current path
      if (k !== 'ROOT' && !pk.startsWith(k)) continue;
      if (Array.isArray(v)) {
        facts.push(...v);
      } else if (Array.isArray(v?.facts)) {
        facts.push(...v.facts);
      }
    }
    // Deduplicate while preserving insertion order-ish.
    return [...new Set(facts)].slice(-80);
  }

  /**
   * Compute the cumulative branch key for a chapter from choice history.
   *
   * Decisions are recorded on caseNumbers like "001C", "002C", etc.
   * The decision at chapter N determines the branch identity for chapter N+1.
   * Therefore, the branch key for chapter K is the concatenation of optionKeys for all decision chapters < K.
   *
   * This replaces the old "previous decision only" pathing and prevents branch collisions.
   */
  _getPathKeyForChapter(chapter, choiceHistory) {
    const targetChapter = Number(chapter) || 1;
    const history = Array.isArray(choiceHistory) ? choiceHistory : [];
    if (targetChapter <= 1 || history.length === 0) return 'ROOT';

    const sorted = [...history].sort((a, b) => {
      const ca = this._extractChapterFromCase(a?.caseNumber);
      const cb = this._extractChapterFromCase(b?.caseNumber);
      return ca - cb;
    });

    const letters = [];
    for (const entry of sorted) {
      const decisionChapter = this._extractChapterFromCase(entry?.caseNumber);
      if (decisionChapter > 0 && decisionChapter < targetChapter) {
        const ok = entry?.optionKey === 'A' || entry?.optionKey === 'B';
        if (ok) letters.push(entry.optionKey);
      }
    }

    return letters.join('') || 'ROOT';
  }

  _extractChapterFromCase(caseNumber) {
    if (!caseNumber) return 1;
    const chapterPart = caseNumber.slice(0, 3);
    return parseInt(chapterPart, 10) || 1;
  }

  /**
   * Get the path-specific decision data for a case, using the player's actual branching path.
   *
   * For pathDecisions format: looks up the player's specific path (e.g., "1B-2C") from branchingChoices
   * Falls back to canonical "1A-2A" if no branchingChoice exists, then to legacy decision format.
   *
   * @param {Object} entry - The story entry containing pathDecisions or decision
   * @param {string} caseNumber - The case number to look up (e.g., "001C")
   * @param {Array} branchingChoices - Player's branching choices array
   * @returns {Object|null} The decision data (intro, optionA, optionB, or options array)
   */
  _getPathDecisionData(entry, caseNumber, branchingChoices = []) {
    if (!entry) return null;

    // Legacy format: single decision object
    if (!entry.pathDecisions) {
      return entry.decision || null;
    }

    // New format: 9 path-specific decisions
    // Find the player's branching choice for this case
    const branchingChoice = branchingChoices.find(bc => bc.caseNumber === caseNumber);
    const playerPath = branchingChoice?.secondChoice || null;

    // Support both array format (new) and object format (legacy pathDecisions)
    if (Array.isArray(entry.pathDecisions)) {
      // Array format: find by pathKey property
      if (playerPath) {
        const pathSpecific = entry.pathDecisions.find(d => d.pathKey === playerPath);
        if (pathSpecific) return pathSpecific;
      }
      // Fallback chain: canonical path -> first entry
      return entry.pathDecisions.find(d => d.pathKey === '1A-2A')
        || entry.pathDecisions[0]
        || entry.decision
        || null;
    } else {
      // Object format: lookup by key
      if (playerPath && entry.pathDecisions[playerPath]) {
        return entry.pathDecisions[playerPath];
      }
      return entry.pathDecisions['1A-2A'] || entry.decision || null;
    }
  }

  _shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  /**
   * Log the complete prompt sent to the LLM for debugging.
   * This outputs the EXACT prompt the LLM receives, including system instruction,
   * cached content, and dynamic prompt.
   *
   * @param {Object} options - Logging options
   * @param {string} options.caseNumber - Case being generated
   * @param {number} options.chapter - Chapter number
   * @param {number} options.subchapter - Subchapter number
   * @param {string} options.cacheKey - Cache key if using cached generation
   * @param {string} options.dynamicPrompt - Dynamic prompt content
   * @param {string} options.fullPrompt - Full prompt for non-cached generation
   * @param {boolean} options.isCached - Whether using cached generation
   */
  _logCompletePrompt({ caseNumber, chapter, subchapter, cacheKey, dynamicPrompt, fullPrompt, isCached }) {
    const separator = '='.repeat(80);
    const subSeparator = '-'.repeat(80);

    console.log(`\n${separator}`);
    console.log(`[FULL PROMPT] ${caseNumber} (Chapter ${chapter}.${subchapter}) - ${isCached ? 'CACHED' : 'NON-CACHED'} GENERATION`);
    console.log(`${separator}\n`);

    if (isCached && cacheKey) {
      // For cached generation, retrieve and log the cache content
      const cacheContent = this.chapterStartCacheContent.get(cacheKey);

      console.log(`${subSeparator}`);
      console.log('[PART 1: SYSTEM INSTRUCTION]');
      console.log(`${subSeparator}`);
      if (cacheContent?.systemInstruction) {
        console.log(cacheContent.systemInstruction);
      } else {
        console.log('(System instruction from cache - content not available locally)');
        console.log('Note: buildMasterSystemPrompt() is used as the system instruction.');
      }

      console.log(`\n${subSeparator}`);
      console.log('[PART 2: CACHED CONTENT (Static + Story Context)]');
      console.log(`${subSeparator}`);
      if (cacheContent?.content) {
        console.log(cacheContent.content);
      } else {
        console.log(`(Cached content not available locally - cache key: ${cacheKey})`);
        console.log('Cache was created in a previous session or content was not stored.');
      }

      console.log(`\n${subSeparator}`);
      console.log('[PART 3: DYNAMIC PROMPT (Sent with this request)]');
      console.log(`${subSeparator}`);
      if (dynamicPrompt) {
        console.log(dynamicPrompt);
      } else {
        console.log('(No dynamic prompt)');
      }

    } else {
      // For non-cached generation, log the system prompt and full prompt
      console.log(`${subSeparator}`);
      console.log('[PART 1: SYSTEM PROMPT]');
      console.log(`${subSeparator}`);
      console.log(buildMasterSystemPrompt());

      console.log(`\n${subSeparator}`);
      console.log('[PART 2: USER PROMPT (Full generation prompt)]');
      console.log(`${subSeparator}`);
      if (fullPrompt) {
        console.log(fullPrompt);
      } else {
        console.log('(No prompt content)');
      }
    }

    console.log(`\n${separator}`);
    console.log(`[END OF FULL PROMPT] ${caseNumber}`);
    console.log(`${separator}\n`);
  }
}

// Singleton instance
export const storyGenerationService = new StoryGenerationService();
export default storyGenerationService;
